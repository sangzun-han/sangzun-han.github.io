<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Dev Note]]></title><description><![CDATA[개발일기]]></description><link>https://github.com/sangzun-han</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 07 Jun 2022 14:58:52 GMT</lastBuildDate><item><title><![CDATA[01. JavaScript Challenge]]></title><description><![CDATA[라이브러리나 프레임워크 사용 없이 모던자바스크립트만으로 하루에 하나씩 30일동안 30가지 미니 프로젝트를 만드는 챌린지입니다. 프로젝트 아이디어를 떠올리기 어려워 주제와 디자인이 정해진 미니 프로젝트를 따라 만들어보는것으로 시작했습니다. 0…]]></description><link>https://github.com/sangzun-han/프로젝트/drumkit/</link><guid isPermaLink="false">https://github.com/sangzun-han/프로젝트/drumkit/</guid><pubDate>Mon, 06 Jun 2022 15:00:00 GMT</pubDate><content:encoded>&lt;p&gt;라이브러리나 프레임워크 사용 없이 모던자바스크립트만으로 하루에 하나씩 30일동안 30가지 미니 프로젝트를 만드는 챌린지입니다. 프로젝트 아이디어를 떠올리기 어려워 주제와 디자인이 정해진 미니 프로젝트를 따라 만들어보는것으로 시작했습니다.&lt;/p&gt;
&lt;h3 id=&quot;01-drum-kit&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#01-drum-kit&quot; aria-label=&quot;01 drum kit permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;01. drum-kit&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;keydown&lt;/code&gt;이벤트를 이용해서 입력값을 받아서 정해진 오디오를 재상한다.&lt;/li&gt;
&lt;li&gt;오디오를 재생할 때 해당 키에 .playing 이라는 클래스를 추가해주고 오디오 재생이 끝나면 .playing클래스를 제거한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;transitionend&lt;/code&gt;는 transition의 완료를 감지할 수 있는 이벤트이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const play = (event) =&gt; {
  const audio = document.querySelector(`audio[data-key=&quot;${event.keyCode}&quot;]`);
  const key = document.querySelector(`.key[data-key=&quot;${event.keyCode}&quot;]`);

  if (!audio) return;
  audio.currentTime = 0;
  audio.play();
  key.classList.add(&quot;playing&quot;);
};

const removeTransition = (event) =&gt; {
  if (event.propertyName === &quot;transform&quot;)
    event.target.classList.remove(&quot;playing&quot;);
};

const pianoKeys = document.querySelectorAll(&quot;.key&quot;);
pianoKeys.forEach((el) =&gt;
  el.addEventListener(&quot;transitionend&quot;, removeTransition)
);

window.addEventListener(&quot;keydown&quot;, play);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[오픈마켓]]></title><description><![CDATA[…]]></description><link>https://github.com/sangzun-han/프로젝트/market/</link><guid isPermaLink="false">https://github.com/sangzun-han/프로젝트/market/</guid><pubDate>Sat, 04 Jun 2022 15:00:00 GMT</pubDate><content:encoded>&lt;p&gt;리액트를 이용하여 간단히 몇가지 기능이 있는 마켓을 만들었습니다.&lt;/p&gt;
&lt;h2 id=&quot;구현사항&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B5%AC%ED%98%84%EC%82%AC%ED%95%AD&quot; aria-label=&quot;구현사항 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;구현사항&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;쇼핑 아이템 목록 페이지 구현&lt;/li&gt;
&lt;li&gt;아이템의 상세페이지 구현&lt;/li&gt;
&lt;li&gt;상세페이지 내에서 옵션,갯수 선택 가능&lt;/li&gt;
&lt;li&gt;옵션과 아이템 선택 갯수에 따라 상품의 총액 계산 노출&lt;/li&gt;
&lt;li&gt;장바구니 담기 구현&lt;/li&gt;
&lt;li&gt;아이템 상세에서 장바구니에 담기를 클릭하면 상단에 구현된 장바구니 아이콘 옆에 담긴 상품 갯수 노출&lt;/li&gt;
&lt;li&gt;장바구니 목록 페이지 구현&lt;/li&gt;
&lt;li&gt;장바구니 목록에는 아이템명과 아이템의 옵션, 수량, 개별금액, 총 금액 노출&lt;/li&gt;
&lt;li&gt;총 3개의 페이지 구현 → 목록 / 상세 / 장바구니&lt;/li&gt;
&lt;li&gt;금액은 노출될때 천원단위 콤마 표시&lt;/li&gt;
&lt;li&gt;상품목록 정렬기능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;프로젝트를-진행하면서-남겨두었던-기록입니다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EB%A9%B4%EC%84%9C-%EB%82%A8%EA%B2%A8%EB%91%90%EC%97%88%EB%8D%98-%EA%B8%B0%EB%A1%9D%EC%9E%85%EB%8B%88%EB%8B%A4&quot; aria-label=&quot;프로젝트를 진행하면서 남겨두었던 기록입니다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로젝트를 진행하면서 남겨두었던 기록입니다.&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/channel/UCfYXOsh_ySGqR7Wy8Qw1vPg/videos&quot;&gt;Youtube&lt;/a&gt;
&lt;a href=&quot;https://github.com/sangzun-han/open-market&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[02. 타입스크립트 타입 시스템]]></title><description><![CDATA[…]]></description><link>https://github.com/sangzun-han/타입스크립트/2.타입스크립트 설정/</link><guid isPermaLink="false">https://github.com/sangzun-han/타입스크립트/2.타입스크립트 설정/</guid><pubDate>Fri, 22 Apr 2022 03:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-타입은-값들의-집합&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%83%80%EC%9E%85%EC%9D%80-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9&quot; aria-label=&quot;1 타입은 값들의 집합 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 타입은 값들의 집합&lt;/h1&gt;
&lt;p&gt;타입스크립트의 타입은 &lt;code class=&quot;language-text&quot;&gt;할당 가능한 값들의 집합&lt;/code&gt;이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;never&lt;/code&gt;타입은 값들이 없는 집합 즉 공집합이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const x: never = 12; // error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;unknown&lt;/code&gt;은 어떠한 값이든 할당할 수 있는 집합 즉 전체집합이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const x: unknown = &quot;aa&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그 다음으로 작은 집합은 한가지 값만 포함하는 리터럴타입이다. 두개 혹은 세 개로 묶으려면 &lt;code class=&quot;language-text&quot;&gt;유니온(union)&lt;/code&gt; 타입을 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;type A = &quot;A&quot;;
type B = &quot;B&quot;;
type Twelve = 12;
type AB = &quot;A&quot; | &quot;B&quot;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;amp;&lt;/code&gt;연산자는 두 타입의 교집합이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person &amp;amp; Lifespan;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 보면 공통을 가지는 속성이 없기 때문에 &lt;code class=&quot;language-text&quot;&gt;never&lt;/code&gt;타입이 될것같지만 타입 연산자는 인테페이스의 속성이 아닌 타입의 범위에 적용된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다 따라서 Person과 Lifespan을 둘다 가지는 값은 PersonSpan 타입에 속하게 된다.&lt;/p&gt;
&lt;p&gt;따라서 아래의 코드는 정상적으로 작동한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const ps: PersonSpan = {
  name: &quot;Kim&quot;,
  birth: new Date(&apos;1919/01/01&apos;),
  death: new Date(&apos;1920/02/01&apos;),
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 사용하는것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;즉 A는 B를 상속 = A는 B에 할당 가능 = A는 B의 서브타입 = A는 B의 부분집합 모두 같은 의미이다.&lt;/p&gt;
&lt;h1 id=&quot;2-타입공간-값공간&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%83%80%EC%9E%85%EA%B3%B5%EA%B0%84-%EA%B0%92%EA%B3%B5%EA%B0%84&quot; aria-label=&quot;2 타입공간 값공간 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 타입공간 값공간&lt;/h1&gt;
&lt;p&gt;타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한곳에 존재한다. 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius:number, height:number) =&gt; ({radius,height});&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 inteface Cylinder에서 Cylinder는 타입으로 쓰인다. const Cylinder에서 Cylinder와 이름은 같지만 아무련 관련도 없다. 이런 부분이 가끔 오류를 야기한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function calculateVolumn(shap: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 instanceof를 이용해서 shape가 Cylinder타입인지 체크하려고 한다. 그러나 instanceof는 자바스크립트의 런타임 연산자이고, 값에 대해서 연산을 한다. 따라서 instanceof Cylinder는 타입이 아니라 함수를 참조한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 값은 타입을 가지지만 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.&lt;/li&gt;
&lt;li&gt;class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-타입-단언--타입-선언&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8--%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8&quot; aria-label=&quot;3 타입 단언  타입 선언 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 타입 단언 &amp;#x3C; 타입 선언&lt;/h1&gt;
&lt;p&gt;타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Person {name: string};

const alice: Person = {name: &apos;Alice&apos;}; // type: Person
const bob = {name: &apos;Bob&apos;} as Person; // type: Person&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 가지 방법은 결과가 같아 보이지만 그렇지 않다. 첫번째 alice는 변수에 &lt;code class=&quot;language-text&quot;&gt;타입 선언(: Type)&lt;/code&gt;을 붙여서 그 값이 선언된 타입을 명시하는것이고 두번째 as Person은 &lt;code class=&quot;language-text&quot;&gt;타입 단언(as Type)&lt;/code&gt;을 수행한다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.&lt;/p&gt;
&lt;p&gt;타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다. 타입 단언은 강제로 타입을 지정했기 때문에 타입체커는 오류를 무시한다.&lt;/p&gt;
&lt;p&gt;화살표 함수에서 타입선언은 단언문을 쓰지 않고 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Person {name: string};

const people: Person[] = [&apos;alice&apos;, &apos;bob&apos;, &apos;jan&apos;].map(
  (name): Person =&gt; ({name})
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-객체-래퍼-타입-피하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0&quot; aria-label=&quot;4 객체 래퍼 타입 피하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 객체 래퍼 타입 피하기&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 쓰인다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.&lt;/li&gt;
&lt;li&gt;타입스크립트 객체 래퍼 타입은 지양하고, 기본형 타입을 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;5-잉여-속성-체크의-한계&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84&quot; aria-label=&quot;5 잉여 속성 체크의 한계 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 잉여 속성 체크의 한계&lt;/h1&gt;
&lt;p&gt;타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 타입의 속성이 있는지, 그 외의 속성은 없는지 확인한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Person {
  name: string;
  age: number;
}

const kim: Person = {
  name: &apos;kim&apos;,
  age: 30,
  gender: &quot;male&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;변수에 타입을 선언함과 동시에 오브젝트 리터럴로 만들게 되면 &lt;code class=&quot;language-text&quot;&gt;잉여 속성 체크&lt;/code&gt;된다. 하지만 아래의 코드는 잉여 속성 체크가 되지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const kim = {
  name: &apos;kim&apos;,
  age: 35,
  gender: &apos;male&apos;
}

const jun: Person = kim;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정상적으로 jun 변수에 kim이 할당되었고 이 과정에서 잉여 속성 체크는 진행되지 않았다. 잉여 속석 체크는 타입 단언문을 사용할 때도 적용되지 않는다. 따라서 단언문보다 선언문을 사용해야 하는 이유 중 하나이다.&lt;/p&gt;
&lt;p&gt;잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 사용하는 방법이 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Options {
  darkMode?: boolean;
  [otherOptions:string]: unknown;
}

const o: Options = {darkMode: true};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;6-함수-표현식에-타입-적용&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%81%EC%9A%A9&quot; aria-label=&quot;6 함수 표현식에 타입 적용 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 함수 표현식에 타입 적용&lt;/h1&gt;
&lt;p&gt;자바스크립트에서는 함수 문장과 함수 표현식을 다르게 인식한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function rollDice1(sides:number): number {} // 문장
const rollDice2 = function(sides: number): number {} // 표현식
const rollDice3 = (sides: number): number =&gt; {} // 표현식&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;타입스크립트에서는 함수 표현식을 사용하는것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;type DiceRollFn = (sides: number) =&gt; number;
const rollDice: DiceRollFn = sides =&gt; {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아본다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;type BinaryFn = (x:number, y:numbe) =&gt; number;

const add: BinaryFn = (a,b) =&gt; a+b;
const sub: BinaryFn = (a,b) =&gt; a-b;
const mul: BinaryFn = (a,b) =&gt; a*b;
const div: BinaryFn = (a,b) =&gt; a/b;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;7-타입과-인터페이스의-차이점&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%ED%83%80%EC%9E%85%EA%B3%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90&quot; aria-label=&quot;7 타입과 인터페이스의 차이점 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 타입과 인터페이스의 차이점&lt;/h1&gt;
&lt;p&gt;타입스크립트에서 named type을 정의하는 방법은 두 가지이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;type Tstate = {
  name: string;
  capital: string;
}

interface IState = {
  name: string;
  capital: string;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;대부분의 경우 타입과 인터페이스 어느것을 선택하여 사용해도 상관없다. 그러나 같은 상황에서는 동일한 방법으로 타입을 정의해 일관성을 유지해야 한다.&lt;/p&gt;
&lt;p&gt;type은 일반적으로 interface보다 쓰임새가 많다. type 키워드는 유니온이 될 수도있고 매핑된 타입 또는 조건부 타입같은 기능에 활용되기도 한다. 튜플과 배열 타입도 type 키워드를 이용해 더 간결하게 표현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;type Pair = [number,number];
type StringList = string[];
type NameNums = [string, ...number[]];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;type과 interface는 타입을 확장하는 방법에 차이가 있다. type은 &lt;code class=&quot;language-text&quot;&gt;&amp;amp;&lt;/code&gt;연산자 interface는 &lt;code class=&quot;language-text&quot;&gt;extends&lt;/code&gt;를 이용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface IStudent2 extends IStudent  {
  age: number;
}

type TStudent2 = TStudent &amp;amp; {
  age: number;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한 interface는 동일한 이름으로 다시 interface를 정의해 확장하는것이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface IState {
  name: string;
  capital: string;
}

interface IState {
  population: number;
}

const wyoming: IState = {
  name: &quot;Wyoming&quot;,
  capital: &quot;Cheyenne&quot;,
  population: 500_500;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[01. 타입스크립트 알아보기]]></title><description><![CDATA[타입스크립트 vs…]]></description><link>https://github.com/sangzun-han/타입스크립트/1.타입스크립트 알아보기/</link><guid isPermaLink="false">https://github.com/sangzun-han/타입스크립트/1.타입스크립트 알아보기/</guid><pubDate>Fri, 15 Apr 2022 03:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;타입스크립트-vs-자바스크립트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-vs-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8&quot; aria-label=&quot;타입스크립트 vs 자바스크립트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;타입스크립트 vs 자바스크립트&lt;/h1&gt;
&lt;p&gt;모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 반대는 성립하지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function greet(who: string) {
  console.log(&quot;Hello&quot;, who);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt;은 타입스크립트에서 쓰이는 타입 구문이다. 따라서 자바스크립트에서는 오류를 출력한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let city = &quot;new york city&quot;;
console.log(city.toUppercase());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 타입 구문이 없지만 타입 체커는 문제점을 찾아낸다. city 변수가 문자열이라는 것을 알려주지 않아도 타입스크립트는 초기값으로부터 타입을 추론한다.&lt;/p&gt;
&lt;p&gt;또한 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다. 하지만 모든 오류를 찾지는 못한다. 타입 체커를 통과해도 오류를 발생시키는 코드는 충분히 존재할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;1-타입스크립트-설정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95&quot; aria-label=&quot;1 타입스크립트 설정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 타입스크립트 설정&lt;/h1&gt;
&lt;p&gt;타입스크립트 컴파일러는 많은 설정을 가지고 있다. &lt;code class=&quot;language-text&quot;&gt;tsconfing.json&lt;/code&gt;파일을 통해서 설정하거나 커맨드라인에서 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;설정을 사용하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;noImplicitAny&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;strictNullChecks&lt;/code&gt;를 이해해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function add(x,y) {
  return a+b;
}

function add(x:nubmer, y:number) {
  return x+y;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;noImplicitAny&lt;/code&gt;는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 판단한다. noImplicitAny가 해제되어 있을때 위의 첫번째 코드는 유효하다.&lt;/p&gt;
&lt;p&gt;타입스크립트는 타입 정보를 가질때 효과적인인 언어기 때문에 noImplicitAny를 설정하는것이 좋다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;strictNullChecks&lt;/code&gt;는 null과 undefined을 모든 타입에서 허용되는지 여부를 설정한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const x: number = null;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;strictNullChecks가 해제되었다면 위의 코드는 유효한 값이지만 strictNullChecks를 설정하면 오류가된다.&lt;/p&gt;
&lt;h1 id=&quot;2-코드-생성과-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85&quot; aria-label=&quot;2 코드 생성과 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 코드 생성과 타입&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;코드 생성은 타입 시스템과 무관하다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.&lt;/li&gt;
&lt;li&gt;타입오류가 존재하더라도 컴파일은 가능하다.&lt;/li&gt;
&lt;li&gt;타입스크립트 타입은 런타임에 사용할 수 없다. 런타임에 타입을 지정하려면 타입 정보 유지를 위한 별도의 방법이 필요하며 일반적으로는 태그된 유니온과 속성 체크 방법을 사용한다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 속성 체크 방법
interface Square {
    width: number;
}

interface Retangle extends Square {
    height: number;
}

type Shape = Square | Retangle;

function calculateArea(shape:Shape) {
    if (&apos;height&apos; in shape) {
        shape;
        return shape.width * shape.height;
    } else {
        shape;
        return shape.width * shape.width;
    }
}

// 태그된 유니온
interface Square {
    kind: &apos;square&apos;;
    width: number;

}

interface Retangle {
    kind: &apos;retangle&apos;;
    height: number;
    width: number;

}

type Shape = Square | Retangle;

function calculateArea(shape: Shape) {
    if (shape.kind === &apos;retangle&apos;) {
        shape;
        return shape.width * shape.height;
    } else {
        shape;
        return shape.width * shape.width;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-구조적-타이핑&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91&quot; aria-label=&quot;3 구조적 타이핑 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 구조적 타이핑&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;duck typing&lt;/code&gt; : 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는것으로 간주하는 방식&lt;/p&gt;
&lt;p&gt;자바스크립트는 덕타이핑 기반이다. 어떤 함수의 매개변수 값이 모두 제대로 주어진다면 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Vector2D {
  x: number;
  y: number;
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

const v: NamedVector = {x: 3, y: 4, name: &apos;Zee&apos; };
calculateLength(v); //5&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 NamedVector의 구조가 Vector2D와 호환되기 때문에 calculateLength 호출이 가능하다. 즉 타입스크립트 타입시스템은 &lt;code class=&quot;language-text&quot;&gt;구조적으로&lt;/code&gt;타입이 맞기만 한다면 이를 허용한다 이것이 구조적 타이핑이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트는 덕타이핑 기반이고 타입스크립트는 구조적 타이핑을 사용한다.&lt;/li&gt;
&lt;li&gt;타입은 &lt;code class=&quot;language-text&quot;&gt;봉인&lt;/code&gt; 되어 있지 않다.&lt;/li&gt;
&lt;li&gt;클래스 또한 구조적 타이핑을 따르고 있으므로 클래스의 인스턴스가 예상과 다를 수 있다.&lt;/li&gt;
&lt;li&gt;구조적 타이핑은 유닛테스트시에 유용하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;4-any-타입-지양&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91&quot; aria-label=&quot;4 any 타입 지양 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. any 타입 지양&lt;/h1&gt;
&lt;p&gt;타입스크립트의 타입 시스템은 &lt;code class=&quot;language-text&quot;&gt;gradual&lt;/code&gt;이고 &lt;code class=&quot;language-text&quot;&gt;optional&lt;/code&gt;이다. 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다. 이것들의 핵심은 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt;타입을 사용하면 타입체커와 타입스크립트의 여러가지 서비스를 무력화시킨다. any타입은 문제점을 감추고 타입 시스템의 신뢰도를 떨어뜨린다. 사용을 자제하는것이 좋다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[00. 타입스크립트]]></title><description><![CDATA[1. 타입스크립트 What & Why ? Typed superset of Javascript Complies down to plain JavaScript Relation to JavaScript Optional static typing and type…]]></description><link>https://github.com/sangzun-han/타입스크립트/0.타입스크립트/</link><guid isPermaLink="false">https://github.com/sangzun-han/타입스크립트/0.타입스크립트/</guid><pubDate>Wed, 13 Apr 2022 03:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-타입스크립트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8&quot; aria-label=&quot;1 타입스크립트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 타입스크립트&lt;/h1&gt;
&lt;h3 id=&quot;what--why-&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#what--why-&quot; aria-label=&quot;what  why  permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;What &amp;#x26; Why ?&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Typed superset of Javascript&lt;/li&gt;
&lt;li&gt;Complies down to plain JavaScript&lt;/li&gt;
&lt;li&gt;Relation to JavaScript&lt;/li&gt;
&lt;li&gt;Optional static typing and type interface&lt;/li&gt;
&lt;li&gt;IDE support&lt;/li&gt;
&lt;li&gt;Rapid growth and use&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;variable-types&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#variable-types&quot; aria-label=&quot;variable types permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Variable Types&lt;/h3&gt;
&lt;p&gt;타입스크립트가 지원하는 데이터타입은 &lt;code class=&quot;language-text&quot;&gt;number&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;boolean&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;array&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;tuple&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;enum&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;void&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;never&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;object&lt;/code&gt; 와 같은것들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;number, string, boolean원시데이터 타입 &lt;code class=&quot;language-text&quot;&gt;number&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;boolean&lt;/code&gt; 을 명시적으로 설정한 변수 선언은 아래와 같이 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let isBeginner: boolean = true;
let total: number = 0;
let name: string = &apos;Vishwas&apos;;
let sentence: string = `My name is ${name} I am a beginner`;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;any : 변수 선언시 어떤 타입을 할당해야 할지 알지 못할경우 어떤 타입도 할당 가능하도록 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt; 를 설정할 수 있다. 변수 선언과 초기화 과정에서 값을 할당하지 않으면 암묵적으로 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt; 타입이 지정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let value: any = 100;
value = true;

let value;
value = false;
value = &apos;nono&apos;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;array : 타입스크립트에서 &lt;code class=&quot;language-text&quot;&gt;array&lt;/code&gt; 을 선언하는 방법은 아래와 같이 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let list1: number[] = [1, 2, 3]; // 숫자만 허용
let list2: Array&amp;lt;number&gt; = [1, 2, 3]; // 숫자만 허용
let selects: (number | string)[] = [102, &apos;o&apos;]; // 특정 데이터 타입만 허용&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;tuple : &lt;code class=&quot;language-text&quot;&gt;tuple&lt;/code&gt; 은 배열타입을 보다 특수한 형태로 사용할 수 있는 타입이다. &lt;code class=&quot;language-text&quot;&gt;tuple&lt;/code&gt;에 명시적으로 지정된 형식에 따라 순서를 설정해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let person: [string, number] = [&apos;kim&apos;, 12];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;enum : &lt;code class=&quot;language-text&quot;&gt;enum&lt;/code&gt; 은 열거형 데이터 타입이다. 멤버라 불리는 값의 집합을 이루는 자료형이다. 기억하기 어려운 숫자나 문자대신 이름으로 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;enum Color {
  Red,
  Blue,
  Green,
}

let green: number = Color.Green; // 2

enum Color {
  Red,
  Blue = 7,
  Green,
}

let green: number = Color.Green; // 8&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;null,undefined : &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 은 각각 하나의 타입으로 처리되며 아래와 같이 사용할 수 있다. &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 로 타입이 설정된 변수에 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 값이 아닌 값이 할당되면 오류를 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let myNull: null = null;
let myUndefined: undefined = undefined;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;tsconfig.json&lt;/code&gt; 에서 strickNullChecks가 true로 설정되어 있으면 모든 데이터 타입은 null, undefined을 할당받을 수 없다. 이를 해결 하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;any&lt;/code&gt; 또는 &lt;code class=&quot;language-text&quot;&gt;|&lt;/code&gt; 을 이용해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let myName: string | null = null;
if (!myName) myName = &apos;kim&apos;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;never : &lt;code class=&quot;language-text&quot;&gt;never&lt;/code&gt; 는 일반적으로 함수의 리턴 타입으로 사용된다. 함수의 리턴타입을 &lt;code class=&quot;language-text&quot;&gt;never&lt;/code&gt; 가 사용될 경우 항상 오류를 출력하거나 리턴값을 절대로 내보내지 않음을 뜻한다. 즉 무한루프와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;never&lt;/code&gt; 타입을 지정한 변수에 다른타입은 할당할 수 없다.&lt;/p&gt;
&lt;h3 id=&quot;functions&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#functions&quot; aria-label=&quot;functions permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Functions&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function add(num1: number,num2: number) {
	return num1 + num2;
}

add(5,10);
add(5,&apos;10&apos;); // error&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;타입스크립트는 모든 파라미터가 함수에 전달되어야 한다고 가정한다. 따라서 함수를 실행할 때 매개변수의 숫자와 함수의 파라미터의 수가 일치해야 한다. 이때 파라미터 변수 뒤에 &lt;code class=&quot;language-text&quot;&gt;?&lt;/code&gt; 를붙이면 Optional을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;?&lt;/code&gt; 는 매개변수의 값이 있을수도 있고 없을수도 있는 상황에서 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function add(num1: number, num2?: number) {
	if(num2) return num1+num2;
	else return num1;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;interface&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#interface&quot; aria-label=&quot;interface permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Interface&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;interface&lt;/code&gt; 는 변수의 타입으로 사용할 수 있다. 이 때 인터페이스를 타입으로 선언한 변수는 interface를 준수해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface Todo {
	id: number;
	content: string;
	completed: boolean;
}

let todo:Todo;

todo = {id:1, content: &apos;ts&apos;, completed: false};

let todos: Todo[] = [];
function addTodo(todo: Todo) {
	todos = [...todos, todo];
}

const newTodo: Todo = {id:1, content: &apos;ts&apos;, completed: false};
addTodo(newTodo)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;class&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#class&quot; aria-label=&quot;class permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Class&lt;/h3&gt;
&lt;p&gt;타입스크립트의 클래스는 접근제어자를 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt; : 클래스 외부에서 접근 가능 (기본값)&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;private&lt;/code&gt; : 클래스 내부에서만 접근 가능&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;protected&lt;/code&gt; : 자신 클래스를 포함한 서브클래스에서만 접근 가능&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Employee {
	employeeName: string;

	constructor(name: string) {
		this.employeeName = name;
	}

	greet() {
		console.log(`Good Morning ${this.employeeName}`);
	}
}

let emp1 = new Employee(&apos;Kim&apos;); // Kim
emp1.greet() // Good Moring Kim&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Manager extends Employee {
    constructor(managerName: string) {
        super(managerName);
    }

    delegateWork() {
        console.log(`Manager delegation tasks`)
    }
}

let m1 = new Manager(&apos;Lee&apos;);
m1.delegateWork(); // Manager delegation tasks
m1.greet(); // Good Morning Lee
console.log(m1.employeeName) // Lee&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[40. 이벤트]]></title><description><![CDATA[1. 이벤트 브라우저는 특정 일이 발생하면 이를 감지하여 이벤트를 발생시킨다. 이벤트가 발생했을 때 호출될 함수를  라 하고 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을  이라 한다.…]]></description><link>https://github.com/sangzun-han/자바스크립트/40.이벤트/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/40.이벤트/</guid><pubDate>Thu, 24 Mar 2022 21:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-이벤트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%9D%B4%EB%B2%A4%ED%8A%B8&quot; aria-label=&quot;1 이벤트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 이벤트&lt;/h1&gt;
&lt;p&gt;브라우저는 특정 일이 발생하면 이를 감지하여 이벤트를 발생시킨다. 이벤트가 발생했을 때 호출될 함수를 &lt;code class=&quot;language-text&quot;&gt;이벤트 핸들러(event handler)&lt;/code&gt; 라 하고 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 &lt;code class=&quot;language-text&quot;&gt;이벤트 핸들러 등록&lt;/code&gt; 이라 한다.&lt;/p&gt;
&lt;h1 id=&quot;2-이벤트-핸들러-등록&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EB%93%B1%EB%A1%9D&quot; aria-label=&quot;2 이벤트 핸들러 등록 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 이벤트 핸들러 등록&lt;/h1&gt;
&lt;p&gt;이벤트 핸들러를 등록하는 방법은 3가지다.&lt;/p&gt;
&lt;h3 id=&quot;2-1-이벤트-핸들러-어트리뷰트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8&quot; aria-label=&quot;2 1 이벤트 핸들러 어트리뷰트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. 이벤트 핸들러 어트리뷰트&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&gt;
&amp;lt;html&gt;
  &amp;lt;body&gt;
    &amp;lt;button onclick=&quot;sayHi(&apos;LEE&apos;)&quot;&gt;Click&amp;lt;/button&gt;
  &amp;lt;/body&gt;
  &amp;lt;script&gt;
    function sayHi(name) {
      console.log(`Hi ${name}`);
    }
  &amp;lt;/script&gt;
&amp;lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HTML과 자바스크립트는 관심사가 다르므로 분리하는것이 좋다. 따라서 이벤트 핸들러 어트리뷰트 방식은 사용하지 않는것이 좋다.&lt;/p&gt;
&lt;h3 id=&quot;2-2-이벤트-핸들러-프로퍼티-방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;2 2 이벤트 핸들러 프로퍼티 방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. 이벤트 핸들러 프로퍼티 방식&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&gt;
&amp;lt;html&gt;
  &amp;lt;body&gt;
    &amp;lt;button&gt;Click&amp;lt;/button&gt;
  &amp;lt;/body&gt;
  &amp;lt;script&gt;
    const $button = document.querySelector(&apos;button&apos;);
    $button.onclick = function () {
      console.log(&apos;click&apos;);
    };
  &amp;lt;/script&gt;
&amp;lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이벤트 핸들러 어트리뷰트 방식도 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 이벤트 핸들러 프로퍼티 방식과 동일하다고 할 수 있다. &lt;code class=&quot;language-text&quot;&gt;이벤트 핸들러 프러퍼티 방식&lt;/code&gt;은 이벤트 핸들러 어트리뷰트 방식의 HTML과 자바스크립트가 혼재되는 문제를 해결할 수 있지만 이벤트 핸들러 프러퍼티에 하나의 이벤트 핸들러만 바인딩 할 수 있다는 단점이 존재한다.&lt;/p&gt;
&lt;h3 id=&quot;addeventlistener-메서드-방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#addeventlistener-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;addeventlistener 메서드 방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;addEventListener 메서드 방식&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&gt;
&amp;lt;html&gt;
  &amp;lt;body&gt;
    &amp;lt;button&gt;Click&amp;lt;/button&gt;
  &amp;lt;/body&gt;
  &amp;lt;script&gt;
    const $button = document.querySelector(&apos;button&apos;);
    $button.addEventListener(&apos;click&apos;, function () {
      console.log(&apos;Click&apos;);
    });
  &amp;lt;/script&gt;
&amp;lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;동일한 HTML 요소에서 동일한 이벤트에 대해 &lt;code class=&quot;language-text&quot;&gt;addEventListener&lt;/code&gt;메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;3-이벤트-핸들러-제거&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%A0%9C%EA%B1%B0&quot; aria-label=&quot;3 이벤트 핸들러 제거 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 이벤트 핸들러 제거&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;addEventListener&lt;/code&gt; 메서드르 등록한 이벤트 핸들러를 제거하려면 &lt;code class=&quot;language-text&quot;&gt;removeEventListener&lt;/code&gt;메서드를 사용한다. 단 addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치해야 한다. 따라서 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.&lt;/p&gt;
&lt;p&gt;또한 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 removeEventListener로 제거할 수 없다 제거하려면 이벤트 핸들러 프로퍼티에 null을 할당해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&gt;
&amp;lt;html&gt;
  &amp;lt;body&gt;
    &amp;lt;button&gt;Click&amp;lt;/button&gt;
  &amp;lt;/body&gt;
  &amp;lt;script&gt;
    const $button = document.querySelector(&apos;button&apos;);
    const handleClick = () =&gt; {
      console.log(&apos;Click&apos;);
    };
    $button.onclick = null;
  &amp;lt;/script&gt;
&amp;lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-이벤트-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;4 이벤트 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 이벤트 객체&lt;/h1&gt;
&lt;p&gt;이벤트가 발생하면 이벤트에 관련된 정보를 담고 있는 이벤트 객체가 동적으로 생성되며 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.&lt;/p&gt;
&lt;p&gt;이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 객체를 전달받으려면 이벤트 핸들러의 첫번째 매개변수는 반드시 event여야 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/onclick.png&quot; alt=&quot;onclick&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;5이벤트-전파&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%A0%84%ED%8C%8C&quot; aria-label=&quot;5이벤트 전파 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5.이벤트 전파&lt;/h1&gt;
&lt;p&gt;DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 &lt;code class=&quot;language-text&quot;&gt;이벤트 전파(event propagation&lt;/code&gt;라고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;캡쳐링 단계(capturing phase) : 이벤트가 상위 요소에서 하위 요소 방향으로 전파&lt;/li&gt;
&lt;li&gt;타깃 단계(target phase) : 이벤트가 이벤트 타깃에 도달&lt;/li&gt;
&lt;li&gt;버블링 단계(bubbling phase) : 이벤트가 하위 요소에서 상위 요소 방향으로 전파&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 핸들러 어트리뷰트/프러퍼티 방식으로 등록한 이벤트는 타깃단계와 버블링 단계의 이벤트만 캐치 할수 있다. 하지만 addEventListener 메서드 방식으로 등록한 이벤트 핸들러는 3번째 인수로 true를 전달하면 캡쳐링 단계의 이벤트도 캐치할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!DOCTYPE html&gt;
&amp;lt;html&gt;
  &amp;lt;body&gt;
    &amp;lt;ul id=&quot;fruits&quot;&gt;
      &amp;lt;li id=&quot;apple&quot;&gt;Apple&amp;lt;/li&gt;
      &amp;lt;li id=&quot;banana&quot;&gt;Banana&amp;lt;/li&gt;
      &amp;lt;li id=&quot;orange&quot;&gt;Orange&amp;lt;/li&gt;
    &amp;lt;/ul&gt;
    &amp;lt;script&gt;
      const $fruits = document.getElementById(&apos;fruits&apos;);
      const $banana = document.getElementById(&apos;banana&apos;);

      // 캡처링 단계의 이벤트를 캐치한다.
      $fruits.addEventListener(
        &apos;click&apos;,
        (e) =&gt; {
          console.log(`이벤트 단계: ${e.eventPhase}`); // 1: 캡처링 단계
          console.log(`이벤트 타깃: ${e.target}`);
          console.log(`커런트 타깃: ${e.currentTarget}`);
        },
        true,
      );

      // 타깃 단계의 이벤트를 캐치한다.
      $banana.addEventListener(&apos;click&apos;, (e) =&gt; {
        console.log(`이벤트 단계: ${e.eventPhase}`); // 2: 타깃 단계
        console.log(`이벤트 타깃: ${e.target}`);
        console.log(`커런트 타깃: ${e.currentTarget}`);
      });

      // 버블링 단계의 이벤트를 캐치한다.
      $fruits.addEventListener(&apos;click&apos;, (e) =&gt; {
        console.log(`이벤트 단계: ${e.eventPhase}`); // 3: 버블링 단계
        console.log(`이벤트 타깃: ${e.target}`);
        console.log(`커런트 타깃: ${e.currentTarget}`);
      });
    &amp;lt;/script&gt;
  &amp;lt;/body&gt;
&amp;lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;이벤트는 이벤트를 발생시킨 이벤트 타킷은 물론 상위 DOM 요소에서도 캐치 할 수 있다.&lt;/code&gt; 대부분의 이벤트는 캡처링과 버블링을 통해 전파된다. 하지만 몇개의 이벤트는 버블링을 통해 전파되지 않는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;foucs/blur&lt;/li&gt;
&lt;li&gt;load/unload/abort/error&lt;/li&gt;
&lt;li&gt;mouseenter/mouseleave&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 이벤트는 버블링 되지 않으므로 이벤트 타깃의 상위 요소에서 위 이벤트를 캐치하려면 캡쳐링 단계의 이벤트를 캐치해야 한다. 만약 상위 요소에서 캐치 해야한다면 focusin/focusout, mouseover/mouseout으로 대체할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;6이벤트-위임&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84&quot; aria-label=&quot;6이벤트 위임 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6.이벤트 위임&lt;/h1&gt;
&lt;p&gt;이벤트 위임은 여러개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소애 이벤트 핸들러를 등록하는 방법을 말한다.&lt;/p&gt;
&lt;p&gt;이벤트 위임을 통해 하위 DOM 요소에서 발생한 이벤트를 처리할 때는 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트를 실제로 발생시킨 DOM 요소가 기대한 DOM 요소가 아닐 수도 있다. 따라서 이벤트에 반응이 필요한 DOM 요소에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function activate({ target }) {
  // 이벤트를 발생시킨 요소(target)이 ul#fruits의 자식 요소가 아니라면 무시한다.
  if (!target.matches(&apos;#fruits &gt; li&apos;)) return;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;7-dom-요소의-기본동작-조작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-dom-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B8%B0%EB%B3%B8%EB%8F%99%EC%9E%91-%EC%A1%B0%EC%9E%91&quot; aria-label=&quot;7 dom 요소의 기본동작 조작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. DOM 요소의 기본동작 조작&lt;/h1&gt;
&lt;p&gt;DOM 요소는 저마다 기본동작이 있다. a 요소는 href 어트리뷰트에 지정된 링크로 이동하고 checkbox, radio요소는 클릭하면 체크 또는 해제 된다. &lt;code class=&quot;language-text&quot;&gt;preventDefault&lt;/code&gt;메서드는 이러한 DOM 요소의 기본 동작을 중단시킨다.&lt;/p&gt;
&lt;p&gt;어느 한 요소를 이용하여 이벤트를 처리한 후 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단시키기 위해서는 &lt;code class=&quot;language-text&quot;&gt;stopPropagation&lt;/code&gt;메서드를 이용한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[38~39. 브라우저의 렌더링 과정, DOM]]></title><description><![CDATA[1. 브라우저의 렌더링 과정 브라우저는 html,css,js,이미지,폰트 파일등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다. 브라우저의 렌더링 엔진은 서버로부터 응답된 html과 css를 파싱하여 DOM과 CSSOM…]]></description><link>https://github.com/sangzun-han/자바스크립트/38.브라우저의 렌더링/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/38.브라우저의 렌더링/</guid><pubDate>Mon, 21 Mar 2022 21:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-브라우저의-렌더링-과정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95&quot; aria-label=&quot;1 브라우저의 렌더링 과정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 브라우저의 렌더링 과정&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;브라우저는 html,css,js,이미지,폰트 파일등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.&lt;/li&gt;
&lt;li&gt;브라우저의 렌더링 엔진은 서버로부터 응답된 html과 css를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합한 렌더 트리를 생성한다.&lt;/li&gt;
&lt;li&gt;브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.&lt;/li&gt;
&lt;li&gt;렌더 트리를 기반으로 html 요소의 레이아웃을 계산하고 브라우저 화면에 html 요소를 페인팅한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-dom&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-dom&quot; aria-label=&quot;2 dom permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. DOM&lt;/h1&gt;
&lt;p&gt;HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다. 노드 객체들로 구성된 트리 자료구조를 &lt;code class=&quot;language-text&quot;&gt;DOM(Document Object Model)&lt;/code&gt; 이라 한다. 노드 객체의 트리로 구조화되어 있기 때문에 DOM을 DOM트리 라고 부른다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/domtree.png&quot; alt=&quot;domtree&quot;&gt;&lt;/p&gt;
&lt;p&gt;DOM 컬렉션 객체인 HTMLCollection과 NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체다. HTMLCollection은 언제나 live 객체로 동작하고 NodeList는 대부분 non-live 객체로 동작한다.&lt;/p&gt;
&lt;h3 id=&quot;2-1-dom-조작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-dom-%EC%A1%B0%EC%9E%91&quot; aria-label=&quot;2 1 dom 조작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. DOM 조작&lt;/h3&gt;
&lt;p&gt;DOM 조작은 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는것이다. DOM에 새로운 노드가 추가되거나 삭제되면 리플로우, 리페인트가 발생하므로 성능에 영향을 준다. 따라서 복잡한 DOM 조작은 주의해서 사용해야 한다.&lt;/p&gt;
&lt;h4 id=&quot;innerhtml&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#innerhtml&quot; aria-label=&quot;innerhtml permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;innerHTML&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;장점&lt;/th&gt;
&lt;th&gt;단점&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DOM 조작 방식에 비해 빠르고 간편하다.&lt;/td&gt;
&lt;td&gt;XSS 공격에 취약하다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다.&lt;/td&gt;
&lt;td&gt;해당 요소의 내용을 덮어쓴다.(=HTML을 다시 파싱한다.)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;dom-조작방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#dom-%EC%A1%B0%EC%9E%91%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;dom 조작방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;DOM 조작방식&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;장점&lt;/th&gt;
&lt;th&gt;단점&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;특정 노드 한개를 DOM에 추가할때 적합하다.&lt;/td&gt;
&lt;td&gt;innerHTML보다 느리고 더 많은 코드가 필요하다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;insertadjacenthtml&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#insertadjacenthtml&quot; aria-label=&quot;insertadjacenthtml permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;insertAdjacentHTML()&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;장점&lt;/th&gt;
&lt;th&gt;단점&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다.&lt;/td&gt;
&lt;td&gt;XSS 공격에 취약하다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[37. Set과 Map]]></title><description><![CDATA[1. Set Set 객체는  유일한 값들의 집합이다. 구분 배열 Set 객체 동일한 값을 중복하여 포함할 수 있다. O X 요소 순서에 의미가 있다. O X 인덱스로 요소에 접근할 수 있다. O X Set…]]></description><link>https://github.com/sangzun-han/자바스크립트/37.Set과 Map/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/37.Set과 Map/</guid><pubDate>Thu, 17 Mar 2022 21:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-set&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-set&quot; aria-label=&quot;1 set permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Set&lt;/h1&gt;
&lt;p&gt;Set 객체는 &lt;code class=&quot;language-text&quot;&gt;중복되지 않는&lt;/code&gt; 유일한 값들의 집합이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구분&lt;/th&gt;
&lt;th&gt;배열&lt;/th&gt;
&lt;th&gt;Set 객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;동일한 값을 중복하여 포함할 수 있다.&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;요소 순서에 의미가 있다.&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;인덱스로 요소에 접근할 수 있다.&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const set = new Set([1, 2, 3, 3]);
console.log(set); // Set(3) {1,2,3}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-set-객체-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-set-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;2 set 객체 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Set 객체 메서드&lt;/h1&gt;
&lt;p&gt;Set 객체의 요소 개수를 확인할때는 &lt;code class=&quot;language-text&quot;&gt;Set.prototype.size&lt;/code&gt; 프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const set = new Set[1, 2, 3, 3]);
console.log(set.size); //

set.size = 10; // 무시됨&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Set 객체에 요소를 추가할 때는 &lt;code class=&quot;language-text&quot;&gt;Set.prototype.add&lt;/code&gt; 메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다.&lt;/p&gt;
&lt;p&gt;Set 객체에 특정 요소가 존재하는지 확인하려면 &lt;code class=&quot;language-text&quot;&gt;Set.prototype.has&lt;/code&gt; 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.&lt;/p&gt;
&lt;p&gt;Set 객체의 특정 요소를 삭제하려면 &lt;code class=&quot;language-text&quot;&gt;Set.prototype.delete&lt;/code&gt; 메서드를 사용한다 delete 메서드는 불리언 값을 반환한다.&lt;/p&gt;
&lt;p&gt;Set 객체의 모든 요소를 일괄 삭제하려면 &lt;code class=&quot;language-text&quot;&gt;Set.prototype.clear&lt;/code&gt; 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다.&lt;/p&gt;
&lt;p&gt;Set 객체의 요소를 순회하려면 &lt;code class=&quot;language-text&quot;&gt;Set.prototype.forEach&lt;/code&gt; 메서드를 사용한다. Set 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 디스트럭처링의 대상이 될 수도 있다.&lt;/p&gt;
&lt;p&gt;Set 객체는 수학적 집합을 구현하기 위한 자료구조이다. 따라서 Set 객체를 통해 교집합, 합집합, 차집합등을 구현할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;3-map&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-map&quot; aria-label=&quot;3 map permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Map&lt;/h1&gt;
&lt;p&gt;Map 객체는 &lt;code class=&quot;language-text&quot;&gt;키와 값의 쌍&lt;/code&gt;으로 이루어진 컬렉션이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구분&lt;/th&gt;
&lt;th&gt;객체&lt;/th&gt;
&lt;th&gt;Map 객체&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;키로 사용할 수 있는 값&lt;/td&gt;
&lt;td&gt;문자열 또는 심벌 값&lt;/td&gt;
&lt;td&gt;객체를 포함한 모든 값&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;이터러블&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;요수 개수 확인&lt;/td&gt;
&lt;td&gt;Object.keys(obj).length&lt;/td&gt;
&lt;td&gt;map.size&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되느 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.&lt;/p&gt;
&lt;p&gt;Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const map = new Map([[&apos;key1&apos;, &apos;value1&apos;], [&apos;key2&apos;, &apos;value2&apos;]]);
console.log(map); // {&apos;key1&apos; =&gt; &apos;value1&apos;, &apos;key2&apos; =&gt; &apos;value2&apos;}

const map = new Map([[&apos;key1&apos;, &apos;value1&apos;], [&apos;key1&apos;, &apos;value2&apos;]]);
console.log(map); //  {&apos;key1&apos; =&gt; &apos;value2&apos;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-map-객체-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-map-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;4 map 객체 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. Map 객체 메서드&lt;/h1&gt;
&lt;p&gt;Map 객체의 요소 개수를 확인할 때는 &lt;code class=&quot;language-text&quot;&gt;Map.prototype.size&lt;/code&gt; 프로퍼티를 사용한다.&lt;/p&gt;
&lt;p&gt;Map 객체의 요소를 추가할 때는 &lt;code class=&quot;language-text&quot;&gt;Map.prototype.set&lt;/code&gt; 메서드를 사용한다. set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다. 따라서 set 메서드를 연속적으로 호출할 수 있다.&lt;/p&gt;
&lt;p&gt;Map 객체에서 특정 요소를 취득할 때는 &lt;code class=&quot;language-text&quot;&gt;Map.prototype.get&lt;/code&gt; 메서드를 사용한다. get 메서드는 인수로 전달한 키를 갖는 값을 반환하고 인수로 전달한 키를 갖는 요소가 존재하지 않으면 undefined를 반환한다.&lt;/p&gt;
&lt;p&gt;Map 객체에서 특정 요소가 존재하는지 확인하려면 &lt;code class=&quot;language-text&quot;&gt;Map.prototype.has&lt;/code&gt; 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.&lt;/p&gt;
&lt;p&gt;Map 객체의 요소를 삭제하려면 &lt;code class=&quot;language-text&quot;&gt;Map.prototype.delete&lt;/code&gt; 메서드를 사용한다. delete 메서드는 불리언 값을 반환한다.&lt;/p&gt;
&lt;p&gt;Map 객체의 요소를순회하려면 &lt;code class=&quot;language-text&quot;&gt;Map.prototype.forEach&lt;/code&gt; 메서드를 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;첫번째 인수 : 현재 순회중인 요소 값&lt;/li&gt;
&lt;li&gt;두번째 인수 : 현재 순회중인 요소 키&lt;/li&gt;
&lt;li&gt;세번째 인수 : 현재 순회중인 Map 객체&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const lee = { name : &apos;Lee&apos; };
const kim = { name : &apos;Kim&apos; };

const map = new Map([[lee, &apos;developer&apos;], [kim, &apos;designer&apos;]]);

map.forEach((v,k,map) =&gt; console.log(v,k,map))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Map 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[36. 디스트럭처링 할당]]></title><description><![CDATA[디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.…]]></description><link>https://github.com/sangzun-han/자바스크립트/36.디스트럭쳐링 할당/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/36.디스트럭쳐링 할당/</guid><pubDate>Fri, 11 Mar 2022 21:00:00 GMT</pubDate><content:encoded>&lt;p&gt;디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.&lt;/p&gt;
&lt;h1 id=&quot;1-배열-디스트럭처링-할당&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B0%B0%EC%97%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9&quot; aria-label=&quot;1 배열 디스트럭처링 할당 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 배열 디스트럭처링 할당&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [1, 2, 3];

const [one, two, three] = arr;
console.log(one, two, three); // 1 2 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다.&lt;/p&gt;
&lt;p&gt;배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가
반드시 일치할 필요는 없다.&lt;/p&gt;
&lt;p&gt;배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const [x, y] = [1,2];
const [x, y]; // SyntaxError
const [a, b] = {}; // TypeError

const [c, d] = [1];
console.log(c, d); // 1 undefined;

const [e, f] = [1,2,3];
console.log(e, f); // 1 2

const [a, b , c = 3] = [1,2];
console.log(a, b, c); // 1 2 3

const [e,f = 10, g = 3] = [1, 2];
console.log(e, f, g); // 1 2 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 &lt;code class=&quot;language-text&quot;&gt;Rest 요소&lt;/code&gt; …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const [x, ...y] = [1, 2, 3];
console.log(x, y); // 1 [2, 3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-객체-디스트럭처링-할당&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EA%B0%9D%EC%B2%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9&quot; aria-label=&quot;2 객체 디스트럭처링 할당 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 객체 디스트럭처링 할당&lt;/h1&gt;
&lt;p&gt;객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 순서는 의미가 없으며 선언된 변수이름과 프로퍼티 키가 일치하면 할당된다.&lt;/p&gt;
&lt;p&gt;객체 디스트럭처링 할당을 위해서는 변수를 객체 리터럴 형태로 선언해야 한다. 이때 우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const { lastName, firstName } = { firstName:&apos;Ungmo&apos;, lastName: &apos;Lee&apos; };&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 아래와 같이 변수를 선언한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const user = { firstName: &apos;Ungmo&apos;, lastName: &apos;Lee&apos; };

const { lastName: ln, firstName: fn } = user;
console.log(fn,ln); // Ungmo Lee&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체 디스트럭처링은 변수에 기본값을 설정할 수 있다. 또한 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const { firstName = &apos;Ungmo&apos;, lastName } = { lastName: &apos;Lee&apos; };
console.log(firstName, lastName); // Ungmo Lee

function printTodo(todo) {
  console.log(`할일 ${todo.content}은 ${todo.completed ? &apos;완료&apos; : &apos;미완료&apos;} 상태입니다.`);
}

printTodo({id: 1, content: &apos;설거지&apos;, completed: true}); // 할일 설거지은 완료 상태입니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;배열의 요소가 객체인 경우에 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const todos = [
  {
    id: 1, content: &apos;HTML&apos;, completed: true
  },
  {
    id: 2, content: &apos;CSS&apos;, completed: false
  },
  {
    id: 3, content: &apos;JS&apos;, completed: false
  }
];

// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만 추출
const [, { id }] = todos;
console.log(id); // 2

// 중첩 객체
const user = {
  name: &apos;Lee&apos;,
  address: {
    zipCode: &apos;03068&apos;,
    city: &apos;Seoul&apos;
  }
};

// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출
const { address: { city } } = user;
console.log(city); // Seoul&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터나 Rest 요소와 유사하게 &lt;code class=&quot;language-text&quot;&gt;Rest 프로퍼티 ...&lt;/code&gt; 을 사용할 수 있다.
Rest 프로퍼티는 Rest 파라미터나 Rest 요소와 맟나가지로 반드시 마지막에 위치해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const { x, ...rest } = { x: 1, y: 2, z: 3};
console.log(x, rest); // 1 {y: 2, z: 3}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[35. 스프레드 문법]]></title><description><![CDATA[ES6에서 도입된 스프레드 문법(spread syntax)는 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM…]]></description><link>https://github.com/sangzun-han/자바스크립트/35.스프레드 문법/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/35.스프레드 문법/</guid><pubDate>Fri, 25 Feb 2022 21:00:00 GMT</pubDate><content:encoded>&lt;p&gt;ES6에서 도입된 스프레드 문법(spread syntax)는 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for … of 문으로 순회할 수 있는 이터러블에 한정된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(...[1,2,3]); // 1 2 3
console.log(...&apos;Hello&apos;); // H e l l o&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;스프레드 문법의 결과는 값이 아니다. 따라서 스프레드 문법의 결과는 변수에 할당 할 수 없다. 스프레드 문법의 결과물은 값으로 사용할 수 없고, 쉼표로 구분한 값의 목록을 사용하는 문백에서만 사용할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 호출문의 인수 목록&lt;/li&gt;
&lt;li&gt;배열 리터럴의 요소 목록&lt;/li&gt;
&lt;li&gt;객체 리터럴의 프로퍼티 목록&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-함수-호출문의-인수-목록&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EB%AC%B8%EC%9D%98-%EC%9D%B8%EC%88%98-%EB%AA%A9%EB%A1%9D&quot; aria-label=&quot;1 함수 호출문의 인수 목록 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 함수 호출문의 인수 목록&lt;/h1&gt;
&lt;p&gt;Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 만약 Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할수 없으므로 NaN을 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Math.max([1,2,3]); // NaN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;스프레드 문법 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달하고 싶은 경우 Function.prototype.apply를 사용했다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var arr = [1,2,3];
var max = Math.max.apply(null, arr); // 3

const arr = [1,2,3];
const max = Math.max(...arr); // 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-배열-리터럴-내부에서-사용하는-경우&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EB%B0%B0%EC%97%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0&quot; aria-label=&quot;2 배열 리터럴 내부에서 사용하는 경우 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 배열 리터럴 내부에서 사용하는 경우&lt;/h1&gt;
&lt;h3 id=&quot;2-1-concat&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-concat&quot; aria-label=&quot;2 1 concat permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. concat&lt;/h3&gt;
&lt;p&gt;2개의 배열을 1개의 배열로 결합하고 싶은 경우 concat 메서드를 사용했지만 스프레드 문법을 사용하면 별도의 메서드를 사용하지 않고 결합할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var arr = [1,2].concat([3,4]);
console.log(arr); // [1,2,3,4]

//ES6
const arr = [...[1,2], ...[3,4]];
console.log(arr); // [1,2,3,4]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-2-splice&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-splice&quot; aria-label=&quot;2 2 splice permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. splice&lt;/h3&gt;
&lt;p&gt;배열의 중간에 다른 배열의 요소를 추가하거나 제거하려면 splice 메서드를 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//ES5
var arr1 = [1,4];
var arr2 = [2,3];

Array.prototype.splice.apply(arr1, [1,0].concat(arr2));
console.log(arr1); // [1,2,3,4]

//ES6

const arr1 = [1,4];
const arr2 = [2,3];

arr1.splice(1, 0, ... arr2);
console.log(arr1); // [1,2,3,4]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-3-배열-복사&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-3-%EB%B0%B0%EC%97%B4-%EB%B3%B5%EC%82%AC&quot; aria-label=&quot;2 3 배열 복사 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-3. 배열 복사&lt;/h3&gt;
&lt;p&gt;배열을 복사하려면 slice 메서드를 사용한다. 이 때 원본 배열의 각 요소를 얕은 복사하여 새로운 복사본을 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//ES5
var origin = [1,2];
var copy = origin.slice();

//ES6
const origin [1,2];
const copy = [...orign];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-4-이터러블을-배열로-변환&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-4-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98&quot; aria-label=&quot;2 4 이터러블을 배열로 변환 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-4. 이터러블을 배열로 변환&lt;/h3&gt;
&lt;p&gt;이터러블을 배열로 변환하려면 Function.prototype.apply 또는 Function.prototype.call 메서드를 사용하여 slice 메서드를 호출해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;//ES5
function sum() {
  var args = Array.prototype.slice.call(arguments);

  return args.reduce(function (pre, cur) {
    return pre+cur;
  }, 0);
}
console.log(sum(1,2,3)); // 6

//ES6
function sum() {
  return [...arguments].reduce((pre,cur) =&gt; pre + cur, 0);
}

console.log(sum(1,2,3)); // 6

// Rest 파라미터
const sum = (...args) =&gt; args.reduce((pre, cur) =&gt; pre + cur ,0);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;단 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.&lt;/strong&gt; 이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 Array.from 메서드를 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arrayLike = {
  0: 1,
  1: 2,
  2: 3,
  length: 3
}
Array.from(arrayLike); // [1,2,3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-객체-리터럴-내부에서-사용하는-경우&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0&quot; aria-label=&quot;3 객체 리터럴 내부에서 사용하는 경우 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 객체 리터럴 내부에서 사용하는 경우&lt;/h1&gt;
&lt;p&gt;스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const obj = {x: 1, y: 2};
const copy = {...obj};
console.log(copy); // {x: 1, y: 2}

const merged = {x: 1, y:2, ...{a: 3, b: 4}};
console.log(merged); // {x: 1, y: 2, a: 3, b: 4}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;스프레드 프로퍼티가 제안되기 전에는 Object.assign 메서드를 사용하여 여러개의 객체를 병합하거나 특정 프로퍼티를 변경, 추가했다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.
const merged = Object.assign({}, {x: 1, y: 2},{y: 10, z: 3});
console.log(merged) // {x: 1, y: 10, z: 3}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[34. 이터러블]]></title><description><![CDATA[1. 이터레이션 프로토콜 ES6에서 도입된 iteration protocol은 순회 가능한 데이터 컬렉션을 만들기 위해 EMCAScript 사양에 정의하여 미리 약속한 규칙이다. ES6 이전의 배열, 문자열, 유사 배열 객체, DOM…]]></description><link>https://github.com/sangzun-han/자바스크립트/34.이터러블/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/34.이터러블/</guid><pubDate>Fri, 18 Feb 2022 21:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-이터레이션-프로토콜&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot; aria-label=&quot;1 이터레이션 프로토콜 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 이터레이션 프로토콜&lt;/h1&gt;
&lt;p&gt;ES6에서 도입된 iteration protocol은 순회 가능한 데이터 컬렉션을 만들기 위해 EMCAScript 사양에 정의하여 미리 약속한 규칙이다.&lt;/p&gt;
&lt;p&gt;ES6 이전의 배열, 문자열, 유사 배열 객체, DOM 컬렉션등은 통일된 규약 없이 각자 나름의 구조를 가지고 for문, for … in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다.&lt;/p&gt;
&lt;p&gt;ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for … of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iterable protocol : Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. &lt;strong&gt;이러한 규약을 이터러블 프로토콜이라 한다. 이터러블 프로토콜을 준수한 객체를 &lt;code class=&quot;language-text&quot;&gt;이터러블&lt;/code&gt;이라 한다.&lt;/strong&gt;
&lt;code class=&quot;language-text&quot;&gt;이터러블&lt;/code&gt;은 for … of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;iterator protocol : 이터러블의 Symbol.iteraotor 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 메서드를 소유하여 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 iterator result object를 반환한다. &lt;strong&gt;이러한 규약을 이터레이터 프로토이라 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/iteration.jpeg&quot; alt=&quot;iteration&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-1-이터러블&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-1-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94&quot; aria-label=&quot;1 1 이터러블 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-1. 이터러블&lt;/h1&gt;
&lt;p&gt;이터러블 프로토콜을 준수한 객체를 이터러블이라 한다. 이터러블인지 확인하는 함수는 아래 코드와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const isIterable = v =&gt; v !== null &amp;amp;&amp;amp; typeof v[Symbol.iterator] === &apos;function&apos;;

isIterable([]); // true
isIterable(&apos;&apos;); // true
isIterable(new Map()); // true
isIterable(new Set()); // true
isIterable({}); // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 for … of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-2-이터레이터&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-2-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0&quot; aria-label=&quot;1 2 이터레이터 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-2. 이터레이터&lt;/h1&gt;
&lt;p&gt;이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터러블의 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const array = [1,2,3];

const iterator = array[Symbol.iterator]();

console.log(&apos;next&apos; in iterator); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이터레이터의 next 메서드는 이터러블의 각 요소를 순회하기 위한 포인터의 역할을 한다. next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 &lt;code class=&quot;language-text&quot;&gt;iterator result object&lt;/code&gt;를 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const array = [1,2,3];
const iterator = array[Symbol.iterator]();

console.log(iterator.next()); // {value: 1, done: false}
console.log(iterator.next()); // {value: 2, done: false}
console.log(iterator.next()); // {value: 3, done: false}
console.log(iterator.next()); // {value: undefined, done: false}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이터레이터의 next 메서드가 반환하는 iterator result object의 value 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내며 done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.&lt;/p&gt;
&lt;h1 id=&quot;2-for--of-문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-for--of-%EB%AC%B8&quot; aria-label=&quot;2 for  of 문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. for … of 문&lt;/h1&gt;
&lt;p&gt;for … of 문은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;for (변수선언문 of 이터러블) {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for … of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 iterator result object의 value 프로퍼티 값을 for … of 문의 변수에 할당한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;for (const item of [1,2,3]) {
  console.log(item); // 1 2 3
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-이터러블과-유사-배열-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EA%B3%BC-%EC%9C%A0%EC%82%AC-%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;3 이터러블과 유사 배열 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 이터러블과 유사 배열 객체&lt;/h1&gt;
&lt;p&gt;유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있꼬 length 프로퍼티 값을 갖는 객체이다. 따라서 유사 배열 객체는 for문으로 순회할 수 있고 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;유사 배열 객체는 이터러블이 아닌 일반 객체다. 따라서 for … of 문으로 순회할 수 없다. 하지만 arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다.&lt;/p&gt;
&lt;p&gt;—&gt; ES6에서 이터러블이 도입되면서 유사 배열 객체인 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. &lt;code class=&quot;language-text&quot;&gt;모든 유사 배열 겍체가 이터러블인 것은 아니다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES6에서 도입된 Array.from 메서드를 사용하여 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arrayLike = {
  0:1,
  1:2,
  2:3,
  length:3
};

const arr = Array.from(arrayLike);
console.log(arr)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-이터레이션-프로토콜의-필요성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1&quot; aria-label=&quot;4 이터레이션 프로토콜의 필요성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 이터레이션 프로토콜의 필요성&lt;/h1&gt;
&lt;p&gt;이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 &lt;code class=&quot;language-text&quot;&gt;데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 한다.&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;5-사용자-정의-이터러블&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94&quot; aria-label=&quot;5 사용자 정의 이터러블 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 사용자 정의 이터러블&lt;/h1&gt;
&lt;p&gt;이터레이션 프로토콜을 준수하지 않는 일반 객체도 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 된다. 아래의 코드는 피보나치 수열을 구현한 사용자 정의 이터러블이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const fibonacci = {
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10;

    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        return { value: cur, done: cur &gt;= max};
      }
    };
  }
};

for (const num of fibonacci) {
  console.log(num); // 1 2 3 5 8
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 fibonacci 이터러블은 내부에 수열의 최대값 max를 가지고 있다. max값은 고정된 값으로 전달한 값으로 변경할 방법이 없는것이 아쉽다. 수열의 최대값을 외부에서 전달하는 방법은 아래 코드와 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const fibonacci = function(max) {
  let [pre, cur] = [0, 1];

  return {
    [Symbol.iterator]() {
      return {
        next() {
          [pre, cur] = [cur, pre + cur];
          return { value: cur, done: cur &gt;= max};
        }
      };
    }
  };
};

for (const num of fibonacci(10)) {
  console.log(num); // 1 2 3 5 8
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이이터러블이면서 이레터인 객체를 생성하면 Symbol.iterator 메서드를 호출하지 않아도 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const fibonacciFunc = function(max) {
  let [pre, cur] = [0, 1];

  return {
    [Symbol.iterator]() {return this;},
    next() {
      [pre, cur] = [cur, pre + cur];
      return {value: cur, done: cur &gt;= max};
    }
  };
};

let iter = fibonacciFunc(10); // iter는 이터러블이면서 이터레이터이다.

for (const num of iter) {
  console.log(num); // 1 2 3 5 8
}

iter = fibonacciFunc(10);

console.log(iter.next()); // {value: 1, done: false }
console.log(iter.next()); // {value: 2, done: false }
console.log(iter.next()); // {value: 3, done: false }
console.log(iter.next()); // {value: 5, done: false }
console.log(iter.next()); // {value: 8, done: false }
console.log(iter.next()); // {value: 13, done: true }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;무한 이터러블을 생성하는 함수를 통해 무한 수열을 간단히 구현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const fibonacciFunc = function(max) {
  let [pre, cur] = [0, 1];

  return {
    [Symbol.iterator]() {return this;},
    next() {
      [pre, cur] = [cur, pre + cur];
      return {value: cur}; // 무한을 구현하기 위해 done을 생략한다.
    }
  };
};

for (const num of fibonacciFunc()) {
  if (num &gt; 10000) break;
  console.log(num);
}

// 배열 디스트럭처링 할당을 통해 무한 이터러블에서 3개의 요소만 가져올 수 있다.
const [f1,f2,f3] = fibonacciFunc();
console.log(f1,f2,f3) // 1 2 3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;지연 평가(lazy evaluation)&lt;/code&gt;는 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가 데이터가 필요한 시점이 되면 그때서야 데이터를 생성하는 기법이다.&lt;/p&gt;
&lt;p&gt;fibonacciFunc 함수가 생성한 무한 이터러블은 데이터를 공급하는 메커니즘을 구현한 것으로 데이터 소비자인 for … of 문이나 배열 디스트럭처링 할당등이 실행되기 이전까지 데이터를 생성하지 않는다. for … of 문의 경우 이터러블을 순회할 때 내부에서 이터레이터의 next 메서드를 호출하는데 이때 데이터가 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;지연평가를 사용하면 불필요한 데이터를 미리 생성하지 않고 필요한 데이터를 필요한 순간에 생성하므로 빠른 실행속도를 기대할 수 있고 불필요한 메모리를 소비하지 않으며 무한도 표현할 수 있다는 장점이 있다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[33. Symbol]]></title><description><![CDATA[1. 심벌이란?  은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. 심벌값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.…]]></description><link>https://github.com/sangzun-han/자바스크립트/33.Sybmol/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/33.Sybmol/</guid><pubDate>Mon, 17 Jan 2022 21:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-심벌이란&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%8B%AC%EB%B2%8C%EC%9D%B4%EB%9E%80&quot; aria-label=&quot;1 심벌이란 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 심벌이란?&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;symbol&lt;/code&gt; 은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. 심벌값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.&lt;/p&gt;
&lt;h1 id=&quot;2-심벌값-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%8B%AC%EB%B2%8C%EA%B0%92-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;2 심벌값 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 심벌값 생성&lt;/h1&gt;
&lt;p&gt;심벌 값은 Symbol 함수를 호출하여 생성한다. 이 때 생성된 심벌 값은 &lt;strong&gt;외부로 노출되지 않아 확인할 수 없다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const mySymbol = Symbol();
console.log(typeof mySymbol); // symbol
console.log(mySymbol);// Symbol()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설며으로 디버깅 용도로만 사용되며 심벌 값 생성에는 영향을 끼치지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 심벌값에 대한 설명이 같더라도 유일무이한 심벌 값을 생성

const mySymbol1= Symbol(&apos;mySymbol&apos;);
const mySymbol2= Symbol(&apos;mySymbol&apos;);

console.log(mySymbol1===mySymbol2) // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;심벌값도 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다. 심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.
단 boolean 타입으로는 암묵적으로 타입 변환된다. 이를 통해 if문에서 존재 확인이 가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const mySymbol= Symbol();
console.log(!!mySymbol); //true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Symbol.for&lt;/code&gt; 메서드는 인수로 전달받은 문자열을 사용하여 키와 심벌 값의 쌍들이 저장되어있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;검색에 성공하면 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환한다.&lt;/li&gt;
&lt;li&gt;검색에 실패하면 새로운 심벌 값을 생성하여 &lt;code class=&quot;language-text&quot;&gt;Symbol.for&lt;/code&gt; 메서드의 인수로 전달된 키로 전역심벌 레지스트리에 저장한 후 생성된 심벌 값을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const s1 = Symbol.for(&apos;mySymbol&apos;);
const s2 = Symbol.for(&apos;mySymbol&apos;);

console.log(s1 === s2); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Symbol.for&lt;/code&gt; 메서드를 사용하면 애플리케이션 전역에서 중복되지 않는 유일무이한 상수인 심벌 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Symbol.keyFor&lt;/code&gt; 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출 할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;3-심벌과-상수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%8B%AC%EB%B2%8C%EA%B3%BC-%EC%83%81%EC%88%98&quot; aria-label=&quot;3 심벌과 상수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 심벌과 상수&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const Direction = {
  UP: 1,
  DOWN: 2,
  LEFT: 3,
  RIGHT: 4
}

const myDirection = Direction.UP;

if(myDirection === Direction.UP) {
  console.log(&quot;UP&quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;값에는 특별한 값이 없고 상수 이름 자체에 의미가 있는 경우가 있다. 이러한 경우 변경/중복 될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일무이한 심벌 값을 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const Direction = {
  UP: Symbol(&apos;up&apos;),
  DOWN: Symbol(&apos;down&apos;),
  LEFT: Symbol(&apos;left&apos;),
  RIGHT: Symbol(&apos;right&apos;)
}

const myDirection = Direction.UP;

if(myDirection === Direction.UP) {
  console.log(&quot;UP&quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-심벌과-프로퍼티-키&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EC%8B%AC%EB%B2%8C%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%82%A4&quot; aria-label=&quot;4 심벌과 프로퍼티 키 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 심벌과 프로퍼티 키&lt;/h1&gt;
&lt;p&gt;객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값으로 만들 수 있으며, 동적으로 생성 할 수도 있다.
심벌 값을 프로퍼티 키로 사용하라면 프로퍼티 키로 사용할 심벌 값에 대괄호를 사용해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const obj = {
  [Symbol.for(&apos;mySymbol&apos;)]: 1
};

obj[Symbol.for(&apos;mySymbol&apos;)]; // 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;심벌 값은 유일무이한 값이므로 심벌 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;5-심벌과-프로퍼티-은닉&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EC%8B%AC%EB%B2%8C%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9D%80%EB%8B%89&quot; aria-label=&quot;5 심벌과 프로퍼티 은닉 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 심벌과 프로퍼티 은닉&lt;/h1&gt;
&lt;p&gt;심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티는 은닉할 수 있다. ES6에서 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 심벌 값을 프로퍼티 키로 사용하여 생성한 프로퍼티를 찾을 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const obj = {
  [Symbol(&apos;mySymbol&apos;)]: 1
}

for (const key in obj) {
  console.log(key); //
}

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []

console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;6-심벌과-표준-빌트인-객체-확장&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%EC%8B%AC%EB%B2%8C%EA%B3%BC-%ED%91%9C%EC%A4%80-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4-%ED%99%95%EC%9E%A5&quot; aria-label=&quot;6 심벌과 표준 빌트인 객체 확장 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 심벌과 표준 빌트인 객체 확장&lt;/h1&gt;
&lt;p&gt;표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하여 확장하는것은 권장하지 않는다. 그 이유는 개발자가 직접 추가한 메서드와 미래에 표준 사양으로 추가될 메서드의 이름이 중복될 수 있기 때문이다.&lt;/p&gt;
&lt;p&gt;하지만 중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는것은 물론 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[32. String]]></title><description><![CDATA[1. String 생성자 함수 표준 빌트인 객체인 String 객체는 생성자 함수 객체다. new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다. String 생성자 함수에 인수를 전달하지 않고 new…]]></description><link>https://github.com/sangzun-han/자바스크립트/32.String/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/32.String/</guid><pubDate>Thu, 06 Jan 2022 13:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-string-생성자-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-string-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98&quot; aria-label=&quot;1 string 생성자 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. String 생성자 함수&lt;/h1&gt;
&lt;p&gt;표준 빌트인 객체인 String 객체는 생성자 함수 객체다. new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;String 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다.&lt;/p&gt;
&lt;p&gt;인수를 전달하면 [[StringData]] 내부 슬롯에 인수로 전달받은 문자열을 할당한 String 래퍼 객체를 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const strObj = new String(&apos;Han&apos;);
console.log(strObj);

// String {&apos;Han&apos;} 0: &quot;H&quot; 1: &quot;a&quot; 2: &quot;n&quot; length: 3 [[PrimitiveValue]]: &quot;Han&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;String 래퍼 객체는 유사 배열 객체이면서 이터러벌이다. 따라서 인덱스를 사용하여 각 문자에 접근할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;2-length-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-length-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 length 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. length 프로퍼티&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;lenght&lt;/code&gt; 프로퍼티는 문자열의 문자 개수를 반환한다.&lt;/p&gt;
&lt;h1 id=&quot;3-string-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-string-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;3 string 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. String 메서드&lt;/h1&gt;
&lt;p&gt;배열에는 &lt;code class=&quot;language-text&quot;&gt;mutator method&lt;/code&gt;(원본배열 직접변경)와 &lt;code class=&quot;language-text&quot;&gt;accessor method&lt;/code&gt;(새로운 배열 생성)가 있다.&lt;/p&gt;
&lt;p&gt;String 객체에는 원본 String 래퍼 객체를 직접 변경하는 메서드는 존재하지 않는다. 문자열은 변경 &lt;code class=&quot;language-text&quot;&gt;immutable&lt;/code&gt;한 값이기 때문에 &lt;strong&gt;&lt;em&gt;String 래퍼 객체도 읽기 전용 객체로 제공된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const strObj = new String(&apos;Lee&apos;);
console.log(Object.getOwnPropertyDescriptors(strObj));

//
{
  0: {value: &apos;L&apos;, writable: false, enumerable: true, configurable: false}
  1: {value: &apos;e&apos;, writable: false, enumerable: true, configurable: false}
  2: {value: &apos;e&apos;, writable: false, enumerable: true, configurable: false}
  length: {value: 3, writable: false, enumerable: false, configurable: false}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.indexOf&lt;/code&gt; : 대상 문자열에서 인수로 전달받은 문자열을 검색하여 &lt;strong&gt;첫번째 인덱스&lt;/strong&gt;를 반환한다. 검색에 실패하면 -1를 반환한다. indexOf 메서드의 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &apos;Hello Hello&apos;;
str.indexOf(&apos;l&apos;); // 2
str.indexOf(&apos;l&apos;,7) // 8&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;indexOf&lt;/code&gt; 메서드는 대상 문자열에 특정 문자열이 존재하는지 확인할 때 유용하며 ES6에서 도입된 &lt;code class=&quot;language-text&quot;&gt;String.prototype.includes&lt;/code&gt; 메서드를 사용하면 가독성이 더 좋다. &lt;code class=&quot;language-text&quot;&gt;includes&lt;/code&gt;는 결과를 true false로 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if(str.includes(&apos;Hello&apos;) {

})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.search&lt;/code&gt; : 대상 문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.startsWith&lt;/code&gt; : ES6에서 도입된 메서드로 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 true, false로 반환한다. 2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &apos;HaHa&apos;
str.startsWith(&apos;Ha&apos;) // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.endsWith&lt;/code&gt; : ES6에서 도입된 메서드로 대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 true, false로 반환한다. 2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.charAt&lt;/code&gt; : 대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환한다. 인덱스는 문자열의 범위 사이의 정수이어야 하며 인덱스가 문자열의 범위를 벗어난 경우 빈 문자열을 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &apos;HaHa&apos;

for (let i=0; i&amp;lt;str.length; i++) {
  console.log(str.charAt(i)); // H a H a
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.substring&lt;/code&gt; : 대상 문자열에서 첫번째 인수로 전달받은 인덱스에 위치하는 문자부터 두번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전까지 부분 문자열을 반환한다. 두번째 인수는 생략 할 수 있다. 이때 첫번째 인수로 전달한 인덱스에 위치하는 문자부터 마지막문자까지 부분 문자열을 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &apos;Hello World&apos;;

// 인덱스 1부터 인덱스 5 이전까지의 부분 문자열을 반환
str.substring(1,5) // &apos;ello&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.slice&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;substring&lt;/code&gt;과 동일하게 동작한다. 하지만 &lt;code class=&quot;language-text&quot;&gt;slice&lt;/code&gt; 메서드는 음수인 인수를 전달할 수 있다. 음수인 인수를 전달하면 대상 문자열의 가장 뒤에서부터 시작해서 문자열을 잘라내어 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &apos;Hello world&apos;;

// 뒤에서 5자리를 잘라내어 반환한다.
str.slice(-5); // &apos;world&apos;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.toUpperCase&lt;/code&gt; : 대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.
&lt;code class=&quot;language-text&quot;&gt;String.prototype.toLowerCase&lt;/code&gt; : 대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.
&lt;code class=&quot;language-text&quot;&gt;String.prototype.trim&lt;/code&gt; : 대상 문자열 앞뒤에 공백을 제거한 문자열을 반환한다.
&lt;code class=&quot;language-text&quot;&gt;String.prototype.repeat&lt;/code&gt; : ES6에서 도입된 &lt;code class=&quot;language-text&quot;&gt;repeat&lt;/code&gt; 메서드는 대상 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반홚나다. 전달받은 정수가 0 이면 빈 문자열을 반환하고 음수이면 &lt;code class=&quot;language-text&quot;&gt;RangeError&lt;/code&gt; 를 발생시킨다. 인수를 생략하면 0이 설정된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &apos;basic&apos;;

str.repeat(); // &apos;&apos;
str.repeat(0); // &apos;&apos;
str.repeat(1); // &apos;basic&apos;
str.repeat(2); // &apos;basicbasic&apos;
str.repeat(-1); // RangeError&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.replace&lt;/code&gt;: 대상 문자열에서 첫번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두번째 인수로 전달한 문자열로 치환한 문자열을 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.split&lt;/code&gt;: 첫번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다. 인수로 빈 문자열을 전달하면 각 문자를 모두 분리하고 인수를 생략하면 문자열 전체를 단일 요소로 하는 배열을 반환한다. 두번째 인수로 배열의 길이를 지정할 수 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[31. RegExp]]></title><description><![CDATA[1. 정규표현식 정규 표현식은 문자열을 대상으로 패턴 매칭 기능을 제공한다.  : 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능 2. 정규표현식 생성 정규 표현식 객체(RegExp…]]></description><link>https://github.com/sangzun-han/자바스크립트/31.RegExp/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/31.RegExp/</guid><pubDate>Tue, 04 Jan 2022 13:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-정규표현식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D&quot; aria-label=&quot;1 정규표현식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 정규표현식&lt;/h1&gt;
&lt;p&gt;정규 표현식은 문자열을 대상으로 &lt;strong&gt;&lt;em&gt;패턴 매칭 기능&lt;/em&gt;&lt;/strong&gt;을 제공한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;패턴매칭기능&lt;/code&gt; : 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능&lt;/p&gt;
&lt;h1 id=&quot;2-정규표현식-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;2 정규표현식 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 정규표현식 생성&lt;/h1&gt;
&lt;p&gt;정규 표현식 객체(RegExp 객체)를 생성하기 위해서는 &lt;strong&gt;&lt;em&gt;정규 표현식 리터럴&lt;/em&gt;&lt;/strong&gt;과 RegExp 생성자 함수를 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/regexp.jpg&quot; alt=&quot;regexp&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;Is this all there is?&apos;;

const regexp = /is/i; // 패턴 : is, 플래그 : i =&gt; 대소문자를 구별하지 않고 검색한다.

regexp.test(target); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;Is this all there is?&apos;;

const regexp = new RegExp(/is/i);

regexp.test(target);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-정규표현식-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;3 정규표현식 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 정규표현식 메서드&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;RegExp.protytpe.exec&lt;/code&gt; : 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다. 문자열 내의 모든 패턴을 검색하는 g플래그를 지정해도 첫번째 매칭 결과만 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;Is this all there is?&apos;;
const regExp = /is/;

regExp.exec(target);
// [&apos;is&apos;, index: 5, input: &apos;Is this all there is?&apos;, groups: undefined]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;RegExp.prototype.test&lt;/code&gt; : 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 boolean 값으로 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;String.prototype.match&lt;/code&gt; : 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다. g플래그가 지정되면 모든 매칭 결과를 배열로 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;Is this all there is?&apos;;
const regExp = /is/;

target.match(regExp);
// [&apos;is&apos;, index: 5, input: &apos;Is this all there is?&apos;, groups: undefined]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;Is this all there is?&apos;;
const regExp = /is/g;

target.match(regExp); //[&apos;is&apos;, &apos;is&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-플래그&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%ED%94%8C%EB%9E%98%EA%B7%B8&quot; aria-label=&quot;4 플래그 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 플래그&lt;/h1&gt;
&lt;p&gt;패턴과 함께 정규 표현식을 구성하는 플래그는 정규 표현식의 검색 방식을 설정하기 위해 사용한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;플래그&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;ignore case&lt;/td&gt;
&lt;td&gt;대소문자를 구별하지 않고 패턴을 검색한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;Global&lt;/td&gt;
&lt;td&gt;대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;Multi line&lt;/td&gt;
&lt;td&gt;문자열의 행이 바뀌더라도 패턴 검색을 계속한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;플래그는 옵션이므로 선택적으로 사용할 수 있으며 순서와 상관없이 하나 이상의 플래그를 동시에 설정할 수도 있다. 어떠한 플래그도 사용하지 않은 경우에 대소문자를 구별해서 패턴을 검색하며 패턴 검색 매칭 대상이 1개 이상 존재해도 첫번째 매칭한 대상만 검색하고 종료한다.&lt;/p&gt;
&lt;h1 id=&quot;5-패턴&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%ED%8C%A8%ED%84%B4&quot; aria-label=&quot;5 패턴 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 패턴&lt;/h1&gt;
&lt;p&gt;정규표현식의 패턴은 문자열의 일정한 규칙을 표현하기 위해 사용한다.&lt;/p&gt;
&lt;h3 id=&quot;5-1-임의의-문자열-검색&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-1-%EC%9E%84%EC%9D%98%EC%9D%98-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%80%EC%83%89&quot; aria-label=&quot;5 1 임의의 문자열 검색 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5-1. 임의의 문자열 검색&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; 은 임의의 문자 한개를 의미한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;Is this all there is?&apos;;

const regExp = /.../g;

target.match(regExp);

// [&apos;Is &apos;, &apos;thi&apos;, &apos;s a&apos;, &apos;ll &apos;, &apos;the&apos;, &apos;re &apos;, &apos;is?&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;5-2-반복-검색&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-2-%EB%B0%98%EB%B3%B5-%EA%B2%80%EC%83%89&quot; aria-label=&quot;5 2 반복 검색 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5-2. 반복 검색&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;{m,n}&lt;/code&gt;은 앞선 패턴이 최소 m번, 최대n번 반복되는 문자열을 의미한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;A AA B BB Aa Bb AAA&apos;;

// A가 최소1번 최대2번 반복되는 문자열
const regExp = /A{1,2}/g;

target.match(regExp)
// [&apos;A&apos;, &apos;AA&apos;, &apos;A&apos;, &apos;AA&apos;, &apos;A&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;{n}&lt;/code&gt;은 앞선 패턴이 n번 반복되는 문자열을 의미한다. 즉 &lt;code class=&quot;language-text&quot;&gt;{n}&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;{n,n}&lt;/code&gt;과 같다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;{n,}&lt;/code&gt;은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;+&lt;/code&gt; 는 앞선패턴이 최소 한번 이상 반복되는 문자열을 의미한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;A AA B BB Aa Bb AAA&apos;;


//&apos;A&apos;가 최소 한번 이상 반복되는 문자열을 전역 검색한다.
const regExp = /A+/g;

target.match(regExp);
//[&apos;A&apos;, &apos;AA&apos;, &apos;A&apos;, &apos;AAA&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;?&lt;/code&gt;는 앞선 패턴이 최대 한번(0번 포함) 이상 반복되는 문자열을 의미한다. 즉 &lt;code class=&quot;language-text&quot;&gt;{0,1}&lt;/code&gt;과 같다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;color colour&apos;;

// &apos;u&apos;가 최대 한번(0번 포함) 이상 반복되고 &apos;r&apos;이 이어지는 문자열 검색
const regExp = /colou?r/g;

target.match(regExp); // [&apos;color&apos;, &apos;colour&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;!&lt;/code&gt;는 or의 의미를 갖는다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[]&lt;/code&gt; 내의 문자는 or로 동작한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;A AA B BB Aa Bb&apos;;

const regExp = /[AB]+/g;

target.match(regExp);

//[&apos;A&apos;, &apos;AA&apos;, &apos;B&apos;, &apos;BB&apos;, &apos;A&apos;, &apos;B&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;범위를 지정하려면 &lt;code class=&quot;language-text&quot;&gt;[]&lt;/code&gt;내에 &lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;를 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;AA BB Ab Bb 12&apos;;

// &apos;A&apos; ~ &apos;Z&apos;가 한번 이상 반복되는 문자열 전역 검색
const regExp = /[A-Z]+/g;

target.match(regExp);

// [&apos;AA&apos;, &apos;BB&apos;, &apos;A&apos;, &apos;B&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/d&lt;/code&gt;는 숫자를 의미한다. 즉 &lt;code class=&quot;language-text&quot;&gt;/d&lt;/code&gt;는 `[0-9]와 같다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/D&lt;/code&gt;는 숫자가 아닌 문자를 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/w&lt;/code&gt;는 알파벳,숫자,언더스코어를 의미한다. 즉 &lt;code class=&quot;language-text&quot;&gt;/w&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;[A-Za-z0-9_]&lt;/code&gt;와 같다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;/W&lt;/code&gt;는 알파벳,숫자,언더스코어가 아닌 문자를 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[...]&lt;/code&gt; 내의 &lt;code class=&quot;language-text&quot;&gt;^&lt;/code&gt;는 not의 의미를 갖는다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[...]&lt;/code&gt; 밖의 &lt;code class=&quot;language-text&quot;&gt;^&lt;/code&gt;는 문자열의 시작을 의미한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const target = &apos;https://pi.com&apos;;

// https로 시작하는지
const regExp = /^https/;

target.test(target) // true;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;$&lt;/code&gt;는 문자열의 마지막을 의미한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[30. Date]]></title><description><![CDATA[표준 빌트인 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수이다. 1. Date 생성자 함수 Date 생성자 함수로 생성한 Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다.
1970년 1월…]]></description><link>https://github.com/sangzun-han/자바스크립트/30.Date/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/30.Date/</guid><pubDate>Mon, 03 Jan 2022 13:00:00 GMT</pubDate><content:encoded>&lt;p&gt;표준 빌트인 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수이다.&lt;/p&gt;
&lt;h1 id=&quot;1-date-생성자-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-date-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98&quot; aria-label=&quot;1 date 생성자 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Date 생성자 함수&lt;/h1&gt;
&lt;p&gt;Date 생성자 함수로 생성한 Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다.
1970년 1월 1일 00:00:00(UTC)을 기점으로 Date 객체가 나타내는 날짜와 시간까지의 밀리초를 나타낸다.&lt;/p&gt;
&lt;p&gt;Date 생성자 함수로 생성한 Date 객체는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다.&lt;/p&gt;
&lt;h3 id=&quot;1-1-new-date&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-1-new-date&quot; aria-label=&quot;1 1 new date permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-1. new Date()&lt;/h3&gt;
&lt;p&gt;new 연산자와 함께 호출하면 Date 객체를 그렇지 않으면 문자열을 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Date(); // Mon Jan 03 2022 21:35:24 GMT+0900 (한국 표준시)
Date(); //&apos;Mon Jan 03 2022 21:35:43 GMT+0900 (한국 표준시)&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;1-2-new-datemilliseconds&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-2-new-datemilliseconds&quot; aria-label=&quot;1 2 new datemilliseconds permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-2. new Date(milliseconds)&lt;/h3&gt;
&lt;p&gt;Date 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 UTC를 기준으로 인수로 전달된만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Date(86400000); // Fri Jan 02 1970 09:00:00 GMT+0900 (한국 표준시)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;1-3-new-datedatestring&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-3-new-datedatestring&quot; aria-label=&quot;1 3 new datedatestring permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-3 new Date(dateString)&lt;/h3&gt;
&lt;p&gt;문자열을 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date객체를 반환한다. 인수로 전달한 문자열은 Date.parse에 의해 해석 가능한 형식이어야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Date(&apos;May 26, 2020 10:00:00&apos;); // Tue May 26 2020 10:00:00 GMT+0900 (한국 표준시)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;1-4-new-dateyear-month-dayhourminutesecondmillisecond&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-4-new-dateyear-month-dayhourminutesecondmillisecond&quot; aria-label=&quot;1 4 new dateyear month dayhourminutesecondmillisecond permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-4. new Date(year, month, [,day,hour,minute,second,millisecond])&lt;/h3&gt;
&lt;p&gt;year,month는 반드시 지정해야하며 month(0 ~ 11, 0은 1월 11은 12월)&lt;/p&gt;
&lt;h1 id=&quot;2-date-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-date-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;2 date 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Date 메서드&lt;/h1&gt;
&lt;h3 id=&quot;2-1-datenow&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-datenow&quot; aria-label=&quot;2 1 datenow permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. Date.now&lt;/h3&gt;
&lt;p&gt;1970.01.01 00:00:00을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Date.now(); // 1641214945803&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-2-dateparse&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-dateparse&quot; aria-label=&quot;2 2 dateparse permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. Date.parse&lt;/h3&gt;
&lt;p&gt;1970.01.01 UTC를 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.&lt;/p&gt;
&lt;h3 id=&quot;2-3-dateutc&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-3-dateutc&quot; aria-label=&quot;2 3 dateutc permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-3. Date.UTC&lt;/h3&gt;
&lt;p&gt;1970.01.01 UTC를 기점으로 인수로 전달된 지정시간까지의 밀리초를 숫자로 반환한다. Date.UTC 메서드는 new Date(year, month, [day,hour,minute,second,millisecond])와 같은 형식의 인수를 사용해야 하며 UTC로 인식된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getFullYear&lt;/code&gt; : Date 객체의 연도를 나타내는 정수를 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setFullYear&lt;/code&gt; : Date 객체에 연도를 나타내는 정수를 설정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getFullYear&lt;/code&gt; : Date 객체에 연도를 나타내는 정수를 설정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getMonth&lt;/code&gt; : Date 객체의 월을 나타내는 0~11의 정수를 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setMonth&lt;/code&gt; : Date 객체의 월을 나타내는 0~11의 정수를 설정&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getDay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setDay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getHours&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setHours&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getMinutes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setMinutes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getSeconds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setSeconds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getMilliseconds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setMilliseconds&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.setTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.getTimezoneoffset&lt;/code&gt; : UTC와 Date 객체에 지정된 locale 시간과의 차이를 분단위로 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const today = new Date();

today.getTimezoneOffset() / 60; // -9&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.toDateString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.toTimeString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.toISOString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.toLocaleString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Date.prototype.toLocaleTimeString&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-date를-이용한-시계&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-date%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%8B%9C%EA%B3%84&quot; aria-label=&quot;3 date를 이용한 시계 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Date를 이용한 시계&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function printNow() {
  const today = new Date();

  const dayNames = [
    &apos;(일요일)&apos;,
    &apos;(월요일)&apos;,
    &apos;(화요일)&apos;,
    &apos;(수요일)&apos;,
    &apos;(목요일)&apos;,
    &apos;(금요일)&apos;,
    &apos;(토요일)&apos;,
  ];

  const day = dayNames[today.getDay()];

  const year = today.getFullYear();
  const month = today.getMonth() + 1;
  const date = today.getDate();

  let hour = today.getHours();
  let minute = today.getMinutes();
  let second = today.getSeconds();

  const ampm = hour &gt;= 12 ? &apos;pm&apos; : &apos;am&apos;;

  hour %= 12;
  hour = hour || 12;


  minute = minute &amp;lt; 10 ? &apos;0&apos; + minute : minute;
  second = second &amp;lt; 10 ? &apos;0&apos; + second : second;

  const now = `${year}년 ${month}월 ${date}일 ${day}
  ${hour} ${minute} ${second} ${ampm}`;

  console.log(now);
  setTimeout(printNow, 1000);
})();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[29. Math]]></title><description><![CDATA[1. Math 프로퍼티 2. Math 메서드  : 인수로 전달된 숫자의 절대값을 반환 (절대값은 반드시…]]></description><link>https://github.com/sangzun-han/자바스크립트/29.Math/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/29.Math/</guid><pubDate>Sun, 02 Jan 2022 13:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-math-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-math-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;1 math 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Math 프로퍼티&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Math.PI // 3.141592653589793&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-math-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-math-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;2 math 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Math 메서드&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.abs&lt;/code&gt; : 인수로 전달된 숫자의 절대값을 반환 (절대값은 반드시 0또는 양수)&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.round&lt;/code&gt;: 인수로 전달된 숫자의 소수점 이하를 반올림한 정수를 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.floor&lt;/code&gt; : 인수로 전달된 숫자의 소수점 이하를 내림한 정수를 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.ceil&lt;/code&gt; : 인수로 전달된 숫자의 소수점 이하를 올림한 정수를 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Math.ceil(1.4); // 2
Math.ceil(-1.4); // -1
Math.ceil(); // NaN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.sqrt&lt;/code&gt; : 인수로 전달된 숫자의 제곱근을 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.random&lt;/code&gt; : 임의의 난수(0이상 ~ 1미만)를 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.pow&lt;/code&gt; : 첫번째 인수를 밑으로 두번째 인수를 지수로 거듭제곱한 결과를 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Math.pow(2,8); // 256
Math.pow(2); // NaN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.max&lt;/code&gt; : 전달받은 인수 중 가장 큰 수 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Math.max(1,2); // 1
Math.max(); // -Infinity&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Math.min&lt;/code&gt; : 전달받은 인수 중 가장 작은 수 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Math.min(1,2); // 1
Math.min();// Infinity&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[28. Number]]></title><description><![CDATA[1. Number 생성자 함수 표준 빌트인 객체인 Number 객체는 생성자 함수 객체다. 따라서 new 연산자와 함께 Number 인스턴스를 생성할 수 있다. Number 생성자 함수에 인수를 전달하지 않고 new…]]></description><link>https://github.com/sangzun-han/자바스크립트/28.Number/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/28.Number/</guid><pubDate>Fri, 24 Dec 2021 01:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-number-생성자-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-number-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98&quot; aria-label=&quot;1 number 생성자 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. Number 생성자 함수&lt;/h1&gt;
&lt;p&gt;표준 빌트인 객체인 Number 객체는 생성자 함수 객체다. 따라서 new 연산자와 함께 Number 인스턴스를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;Number 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[NumberData]] 내부슬롯에 0을 할당한 Number 래퍼 객체를 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const numObj = new Number();
console.log(numObj); // Number {0}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Number 생성자 함수에 숫자가 아닌 값을 전달하면 강제로 숫자로 변환하고 숫자로 변환할 수 없다면 NaN을 내부슬롯에 할당한 Number 래퍼 객체를 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Number(&apos;0&apos;); // 0
Number(&apos;10.53&apos;); // 10.53
Number(true); // 1
Number(&apos;aaa&apos;); // NaN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-number-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-number-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 number 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. Number 프로퍼티&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.EPSILON&lt;/code&gt;: EPSILON은 1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.
EPSILON은 부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;0.1 + 0.2; // 0.30000000000000004
0.1 + 0.2 === 0.3 // false

function isEqual(a,b) {
  return Math.abs(a-b) &amp;lt; Number.EPSILON;
}

isEqual(0.1+0.2, 0.3); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.MAX_VALUE&lt;/code&gt; : 자바스크립트에서 표현할 수 있는 가장 큰 양수값&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Infinity &gt; Number.MAX_VALUE // ture&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.MIN_VALUE&lt;/code&gt; : 자바스크립트에서 표현할 수 있는 가장 작은 양수값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.MAX* SAFE* INTEGER&lt;/code&gt; : 자바스크립트에서 안전하게 표현할 수 있는 가장 큰 정수값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.MIN* SAFE* INTEGER&lt;/code&gt; : 자바스크립트에서 안전하게 표현할 수 있는 가장 작은 정수값&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.POSITIVE_INFINITY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.NEGATIVE_INFINITY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.NaN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-number-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-number-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;3 number 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Number 메서드&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.isFinite&lt;/code&gt; : 인수로 전달된 값이 유한수라면 true 아니라면 false 빌트인 전역함수 isFinite와는 차이가 있다.
전역함수 isFinite는 전달받은 인수를 숫자로 암묵적 타입 변환하여 검사를 수행하지만 Number.isFinite는 전달받은 인수를 숫자로 암묵적 타입 변환 하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.isNaN&lt;/code&gt; : 암묵적 타입변환 하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.isSafeInter&lt;/code&gt; : 암묵적 타입변환 하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.prototype.toExponetial&lt;/code&gt; : 숫자를 지수 표기법으로 변환하여 문자열로 반환한다. &lt;strong&gt;&lt;em&gt;숫자 리터럴과 함께 사용할 경우 에러가 발생한다.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;77.toExpoential(); // Syntax Error
(77).toExpoential(); // 7.7e+1
77 .toExpoential(); // 7.7e+1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.prototype.toFixed&lt;/code&gt; : 숫자를 반올림하여 문자열로 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(123456.789).toFixed(); // 123457
(123456.789).toFixed(1); // 소수점 이하 1자리까지 유효, 나머지 반올림123456.8&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.prototype.toPrecision()&lt;/code&gt; : 인수로 전달받은 전체자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(12345.6789).toPrecision(); // 12345.6789
(12345.6789).toPrecision(1); // 전체 1자릿수 유효, 나머지 반올림 1e+4&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Number.prototype.toString()&lt;/code&gt; : 숫자를 문자열로 반환한다. 진법을 나타내는 2~36사이의 정수값을 인자로 전달할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[27. 배열]]></title><description><![CDATA[1. 배열 배열은 여러 개의 값을 순차적으로 나열한 자료구조이다. 배열은 인덱스와 length 프로퍼티를 갖기 때문에 for문을 통해 순차적으로 접근할 수 있다. 배열은 객체 타입이다. 배열 리터럴, Array 생성자 함수, Array.of…]]></description><link>https://github.com/sangzun-han/자바스크립트/27.배열/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/27.배열/</guid><pubDate>Tue, 21 Dec 2021 03:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-배열&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B0%B0%EC%97%B4&quot; aria-label=&quot;1 배열 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 배열&lt;/h1&gt;
&lt;p&gt;배열은 여러 개의 값을 순차적으로 나열한 자료구조이다. 배열은 인덱스와 length 프로퍼티를 갖기 때문에 for문을 통해 순차적으로 접근할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];
for (let i=0; i &amp;lt; arr.length; i++) {
  console.log(arr[i])
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;배열은 객체 타입이다. 배열 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;2-자바스크립트의-배열&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%B0%B0%EC%97%B4&quot; aria-label=&quot;2 자바스크립트의 배열 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 자바스크립트의 배열&lt;/h1&gt;
&lt;p&gt;자바스크립트의 배열은 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 즉 &lt;strong&gt;&lt;em&gt;희소 행렬(sparse array)이다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느린 구조적인 단점이 있다. 하지만 특정 요소를 검색하거나 삽입,삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;3-length프로퍼티-희소행렬&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-length%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%9D%AC%EC%86%8C%ED%96%89%EB%A0%AC&quot; aria-label=&quot;3 length프로퍼티 희소행렬 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. length프로퍼티, 희소행렬&lt;/h1&gt;
&lt;p&gt;length 프로퍼티 값은 배열의 길이를 바탕으로 결정되지만 임의의 숫자 값을 명시적으로 할당할 수 도 있다.&lt;/p&gt;
&lt;p&gt;현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.&lt;/p&gt;
&lt;p&gt;현재 length 프로퍼티 값보다 큰 값을 할당하면 값은 변경되지만 배열의 길이가 늘어나지는 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [1,2,3,4,5];

arr.length = 3;

console.log(arr); // [1,2,3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;희소배열은 legnth와 배열 요소의 개수가 일치하지 않는다. 희소 배열의 legnth는 희소 배열의 실제 요소개수보다 언제나 크다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;배열을 생성할 때는 희소 배열을 생성하지 않도록 주의해야한다.&lt;/p&gt;
&lt;h1 id=&quot;4-배열-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%B0%B0%EC%97%B4-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;4 배열 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 배열 생성&lt;/h1&gt;
&lt;h3 id=&quot;4-1-배열리터럴&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-1-%EB%B0%B0%EC%97%B4%EB%A6%AC%ED%84%B0%EB%9F%B4&quot; aria-label=&quot;4 1 배열리터럴 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-1. 배열리터럴&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [1,2,3];&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-2-array-생성자-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-2-array-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98&quot; aria-label=&quot;4 2 array 생성자 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-2. Array 생성자 함수&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = new Array(10);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 때 생성된 배열은 희소 배열이다. length프로퍼티 값은 0이 아니지만 실제로 배열의 요소는 존재하지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;new Array(1,2,3); // [1,2,3]

Array(1,2,3); // [1,2,3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-3-arrayof&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-3-arrayof&quot; aria-label=&quot;4 3 arrayof permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-3. Array.of&lt;/h3&gt;
&lt;p&gt;ES6에서 도입된 Array.of 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Array.of(1); // [1]
Array.of(&apos;string&apos;) // [&apos;string&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-4-arrayfrom&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-4-arrayfrom&quot; aria-label=&quot;4 4 arrayfrom permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-4. Array.from&lt;/h3&gt;
&lt;p&gt;ES6에서 도입된 Array.from 메서드는 유사배열객체(array-like-object) 또는 이터러블 객체(iterable object)를 인수로 전달받아 배열러 변환하여 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Array.from({length: 2, 0: &apos;a&apos;, 1: &apos;b&apos;}) //[&apos;a&apos;,&apos;b&apos;];
Array.from(&apos;Hello&apos;) // [&apos;H&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;5-배열-요소-추가-갱신-삭제&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EB%B0%B0%EC%97%B4-%EC%9A%94%EC%86%8C-%EC%B6%94%EA%B0%80-%EA%B0%B1%EC%8B%A0-%EC%82%AD%EC%A0%9C&quot; aria-label=&quot;5 배열 요소 추가 갱신 삭제 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 배열 요소 추가 갱신 삭제&lt;/h1&gt;
&lt;p&gt;배열에도 요소를 동적으로 추가할 수 있다.&lt;/p&gt;
&lt;p&gt;만약 현재 배열의 length프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소배열이 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr =[0];
arr[100] = 100;
console.log(arr); // (101) [0, empty × 99, 100]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;배열은 객체이기 때문에 delete 연산자를 사용할 수 있다. delete 연산자는 객체의 프로퍼티를 삭제한다. 따라서 배열에서 delete 연산자를 사용할 경우 희소배열을 만들 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 희소배열을 만들지 않기 위해 Array.prototype.splice 메서드를 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [1,2,3];

arr.splice(1,1) // arr[1]부터 1개의 요소 삭제
console.log(arr) // [1,3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;6-배열-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;6 배열 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 배열 메서드&lt;/h1&gt;
&lt;p&gt;배열에는 원본배열을 직접 변경하는 메서드(mutator method)와 원본배열을 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드(accessor method)가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.isArray&lt;/code&gt; : 전달된 인수가 Array이면 true 아니면 false&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.indexOf&lt;/code&gt; : 원본배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.push&lt;/code&gt; : 인수로 전달받은 모든값을 원본배열의 마지막 요소로 추가하고 length 프로퍼티 값을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.pop&lt;/code&gt; : 원본배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.unshift&lt;/code&gt; : 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 length 프로퍼티 값을 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.shift&lt;/code&gt; : 원본배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.concat&lt;/code&gt; : 인수로 전달된 값들을 원본배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 원본배열은 변경되지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.splice&lt;/code&gt; : splice(start, deleteCount, items) start 인덱스부터 deleteCount만큼 원본배열에서 요소를 제거한다. 제거한 위치에 items를 원본배열에 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.slice&lt;/code&gt; : 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. 원본배열은 변경되지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.join&lt;/code&gt; : 원본 배열의 모든 요소를 문자열로 변환한 후 구분자로 연결한 문자열을 반환한다. 구분자는 생략가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [1,2,3];

arr.join(); // &apos;1,2,3,4&apos;;
arr.join(&apos;&apos;); // &apos;1234&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.reverse&lt;/code&gt; : 원본 배열의 순서를 반대로 뒤집는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.fill&lt;/code&gt; : 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. 원본 배열이 변경된다. 두번째 인수로 요소채우기를 시작할 인덱스를 전달 할 수 있고 세번째 인수로 요소 채우기를 멈출 인덱스를 전달 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [1,2,3];

arr.fill(&apos;a&apos;);
console.log(arr); // [&apos;a&apos;,&apos;a&apos;,&apos;a&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.includes&lt;/code&gt; : 배열 내에 특정 요소가 있다면 true 아니면 false 두번째 인수로 검색을 시작할 인덱스를 전달 할 수 있다. 음수를 전달하면 (length + index)를 검색 시작 인덱스로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.flat&lt;/code&gt; : 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[1,[2,3,4,5]].flat(); // [1,2,3,4,5];

[1,[2,[3,[4]]]].flat(Infinity); // [1,2,3,4]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;7-배열-고차함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%EB%B0%B0%EC%97%B4-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98&quot; aria-label=&quot;7 배열 고차함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 배열 고차함수&lt;/h1&gt;
&lt;p&gt;고차함수는 함수를 인수로 전달받거나 함수를 반환하는 함수이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.sort&lt;/code&gt; : 배열의 요소를 정렬한다. 원본배열을 직접 변경하며 정렬된 배열을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;sort 메서드는 유니코드 코드 포인트의 순서를 따른다. 따라서 배열의 요소가 숫자타입이라면 주의가 필요하다.&lt;/p&gt;
&lt;p&gt;숫자 요소를 정렬할 때는 sort 메서드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const arr = [40,100,1,5,2,25,10];
arr.sort((a,b) =&gt; a - b); // [1, 2, 5, 10, 25, 40, 100]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.forEach&lt;/code&gt; : 자신의 내부에서 반복문을 실행한다. forEach는 원본배열을 변경하지 않지만 콜백함수를 통해 원본 배열을 변경 할 수는 있다. forEach 메서드는 break, continue 문을 사용할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const numbers = [1,2,3];
const pows = [];

numbers.forEach(item =&gt; pows.push(item ** 2));
console.log(pows) // 1,4,9&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const numbers = [1,2,3];

numbers.forEach(item, index, arr) =&gt; {arr[index] = item ** 2}
// 세번째 인자 arr는 원본배열을 가리킨다.
console.log(numbers) // 1,4,9&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.map&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수를 반복 호출한다. 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다. &lt;strong&gt;&lt;em&gt;원본 배열은 변경되지 않는다.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.filter&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백함수를 반복 호출한다. 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. &lt;strong&gt;&lt;em&gt;원본 배열은 변경되지 않는다.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.reduce&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백함수를 반복 호출한다. 콜백 함수의 반환값을 다음 순회시에 콜백함수의 첫번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환한다. &lt;strong&gt;&lt;em&gt;원본 배열은 변경되지 않는다.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const sum = [1,2,3,4].reduce((accumulator, currentValue, index, arr) =&gt; accumulator + currentValue , 0)

console.log(sum) // 10&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.some&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백함수를 반복 호출한다. 콜백 함수의 반환값이 단 한번이라도 참이라면 true 모두 거짓이면 false를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.every&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하며 인수로 전달받은 콜백함수를 반복 호출한다 콜백 함수의 반환값이 모두 참이라면 true 단 한번이라도 거짓이라면 false를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.find&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 true인 첫번째 요소를 반환한다. 반환값이 true인 요소가 없다면 undefined를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.findIndex&lt;/code&gt; : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 true인 첫번째 요소의 인덱스를 반환한다. 반환값이 true인 요소가 없다면 -1를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Array.prototype.flatMap&lt;/code&gt; : map 메서드를 통해 생성된 새로운 배열을 평탄화 한다. 즉 map 메서드와 flat 메서드를 순차적으로 실행하는 효과가 있다. (ES10)&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[26. ES6 함수의 추가 기능]]></title><description><![CDATA[ES6 이전의 함수는 사용 목적에 따라 명확히 구분되지 않는다. 즉 ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. ES6이전의 모든 함수는 callable이면서 constructor…]]></description><link>https://github.com/sangzun-han/자바스크립트/26.ES6 함수의 추가 기능/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/26.ES6 함수의 추가 기능/</guid><pubDate>Mon, 20 Dec 2021 10:00:00 GMT</pubDate><content:encoded>&lt;p&gt;ES6 이전의 함수는 사용 목적에 따라 명확히 구분되지 않는다. 즉 ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. ES6이전의 모든 함수는 callable이면서 constructor이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var obj = {
  x:10,
  f: fucntion() { return this.x }
}
console.log(obj.f()); // 10

var bar = obj.f;
console.log(bar()); //undefined
cosole.log(new obj.f()); // f{}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체에 바인딩된 함수를 생성자 함수로 호출하는 경우가 흔치는 않지만 문법상 가능하다. 그리고 이는 성능면에서 문제가 있다.&lt;/p&gt;
&lt;p&gt;객체에 바인딩된 함수가 constructor라는것은 prototype 프로퍼티를 가지며 프로토타입 객체를 생성한다는 것을 의미한다. 따라서 불필요한 프로타티입 객체를 생성한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ES6 함수의 구분&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;constructor&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;prototype&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;super&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;arguments&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;일반함수&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;메서드&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;화살표함수&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;1-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;1 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 메서드&lt;/h1&gt;
&lt;p&gt;ES6 이전에는 메서드에 대한 명확한 정의가 없었다. 일반적으로 메서드는 객체에 바인딩 된 함수를 가리켰다.
ES6에서는 메서드에 대한 정의를 &lt;strong&gt;&lt;em&gt;메서드 축약 표현으로 정의된 함수만을 의미한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ES6에서 정의한 메서드는 &lt;strong&gt;&lt;em&gt;인스턴스를 생성할 수 없는 non-constructor&lt;/em&gt;&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯[[HomeObject]]를 갖는다.&lt;/em&gt;&lt;/strong&gt; super 참조는 내부 슬롯 [[HomeObject]]를 사용하여 수퍼클래스의 메서드를 참조한다.&lt;/p&gt;
&lt;h1 id=&quot;2-화살표-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98&quot; aria-label=&quot;2 화살표 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 화살표 함수&lt;/h1&gt;
&lt;p&gt;화살표 함수(arrow function)은 function 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다. &lt;/p&gt;
&lt;p&gt;화살표 함수는 표현만 간략한것이 아니라 내부 동작도 기존의 함수보다 간략하다.&lt;/p&gt;
&lt;h3 id=&quot;2-1-화살표-함수-정의&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98-%EC%A0%95%EC%9D%98&quot; aria-label=&quot;2 1 화살표 함수 정의 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. 화살표 함수 정의&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const multiply = (x,y) =&gt; x * y;
multiply(2,3) // 6&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;매개변수가 여러개 인 경우 () 안에 매개변수를 선언한다.&lt;/li&gt;
&lt;li&gt;매개변수가 한개인 경우 () 생략 가능하다.&lt;/li&gt;
&lt;li&gt;매개변수가 없는 경우 () 생략 불가능하다.&lt;/li&gt;
&lt;li&gt;함수의 몸체가 하나의 문으로 구성된다면 {}를 생략할 수 있다.&lt;/li&gt;
&lt;li&gt;{} 생략됐다면 함수 몸체 내부의 문이 표현식이 아니라면 에러가 발생한다. 표현식이 아니라면 반환할 수 없기 때문이다.&lt;/li&gt;
&lt;li&gt;객체 리터럴을 반환하는 경우 ()로 감싸주어야 한다.&lt;/li&gt;
&lt;li&gt;화살표 함수도 즉시 실행 함수로 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-2-화살표-함수-vs-일반함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98-vs-%EC%9D%BC%EB%B0%98%ED%95%A8%EC%88%98&quot; aria-label=&quot;2 2 화살표 함수 vs 일반함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. 화살표 함수 vs 일반함수&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 prototype도 생성하지 않는다.&lt;/li&gt;
&lt;li&gt;중복된 매개변수 이름을 선언할 수 없다.&lt;/li&gt;
&lt;li&gt;화살표 함수는 함수 자체의 this,arguments,super,new.target 바인딩을 갖지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-3-this&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-3-this&quot; aria-label=&quot;2 3 this permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-3. this&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Prefixer {
  constructor(prefix) {
    this.prefix = prefix;
  }

  add(arr){
    return arr.map(item =&gt; this.prefix + item)
  }
}

const prefixer = new Prefixer(&apos;-webkit-&apos;);
console.log(prefixer.add([&apos;transition&apos;, &apos;user-select&apos;]));

// [&apos;-webkit-transition&apos;, &apos;-webkit-user-select&apos;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위스코프의 this를 그대로 참조한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;화살표 함수는 this 바인딩을 갖지 않기 때문에 Function.prototype.call ,Function.prototype.apply, Function.prototype.bind 메서드를 사용해도 화살표 함수 내부의 this를 교체할 수 없다.&lt;/p&gt;
&lt;p&gt;메서드를 화살표 함수로 정의하는것은 피해야 한다. 메서드를 정의 할 때는 ES6메서드 축약표현으로 정의한 ES6 메서드를 사용하는것이 좋다.&lt;/p&gt;
&lt;p&gt;프로퍼티를 동적으로 추가할때는 ES6 메서드 정의를 사용할 수 없으므로 일반 함수를 할당한다.&lt;/p&gt;
&lt;h3 id=&quot;2-4-super&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-4-super&quot; aria-label=&quot;2 4 super permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-4. super&lt;/h3&gt;
&lt;p&gt;화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 this와 마찬가지로 상위 스코프의 super를 참조한다.&lt;/p&gt;
&lt;h3 id=&quot;2-5-arguments&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-5-arguments&quot; aria-label=&quot;2 5 arguments permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-5. arguments&lt;/h3&gt;
&lt;p&gt;화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다 따라서 화살표 함수 내부에서 arguments를 참조하면 상위 스코프의 arguments를 참조한다.&lt;/p&gt;
&lt;h1 id=&quot;3-rest-파라미터&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-rest-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0&quot; aria-label=&quot;3 rest 파라미터 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. Rest 파라미터&lt;/h1&gt;
&lt;p&gt;Rest 파라미터는 매개변수 이름앞에 …을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function foo(...rest) {
  console.log(rest); // [1,2,3,4,5]
}

foo(1,2,3,4,5)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다. 이 때 함수에 전달된 인수들은 매개벼눗와 Rest 파라미터에 순차적으로 할당된다. —&gt; Rest 파라미터는 반드시 마지막 파라미터여야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;fucntion foo(param, ...rest) {
  console.log(param); // 1
  console.log(test); // [2,3,4,5]
}

foo(1,2,3,4,5);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Rest 파라미터는 단 하나만 선언할 수 있다.&lt;/li&gt;
&lt;li&gt;Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function foo(...rest) {} // 0
console.log(foo.length)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-매개변수-기본값&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EA%B8%B0%EB%B3%B8%EA%B0%92&quot; aria-label=&quot;4 매개변수 기본값 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 매개변수 기본값&lt;/h1&gt;
&lt;p&gt;인수가 전달되지 않는 매개변수의 값은 undefined이다. 이는 의도치 않은 문제를 발생 시킬 수 있다.&lt;/p&gt;
&lt;p&gt;ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화 할 수 있다.&lt;/p&gt;
&lt;p&gt;매개변수 기본값은 함수 정의시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티와 arguments 객체에 아무런 영향을 주지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function sum(x = 0, y = 0) {
  return x + y;
}

console.log(sum(1)); // 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rest 파라미터에는 기본값을 지정할 수 없다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[25. 클래스]]></title><description><![CDATA[1. 클래스 자바스크립트에서 클래스는 생성자 함수와 유사하게 동작하지만 몇 가지 차이가 있다. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 클래스는 상속을 지원하는 extends와 super…]]></description><link>https://github.com/sangzun-han/자바스크립트/25.클래스/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/25.클래스/</guid><pubDate>Wed, 15 Dec 2021 10:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-클래스&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%81%B4%EB%9E%98%EC%8A%A4&quot; aria-label=&quot;1 클래스 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 클래스&lt;/h1&gt;
&lt;p&gt;자바스크립트에서 클래스는 생성자 함수와 유사하게 동작하지만 몇 가지 차이가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클래스를 new 연산자 없이 호출하면 에러가 발생한다.&lt;/li&gt;
&lt;li&gt;클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.&lt;/li&gt;
&lt;li&gt;클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.&lt;/li&gt;
&lt;li&gt;클래스 내의 모든 코드는 암묵적으로 strict mode가 살행된다.&lt;/li&gt;
&lt;li&gt;클래스는 열거되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 프로퍼티&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;인스턴스 프로퍼티 : constructor 내부에서 정의해야 한다.&lt;/li&gt;
&lt;li&gt;접근자 프로퍼티: 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티&lt;/li&gt;
&lt;li&gt;클래스 필드 : 클래스 기반의 객체 지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티&lt;/li&gt;
&lt;li&gt;private : private 필드의 앞에는 #을 붙여주고 참조할 때도 붙여준다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-상속에-의한-클래스-확장&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%83%81%EC%86%8D%EC%97%90-%EC%9D%98%ED%95%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%99%95%EC%9E%A5&quot; aria-label=&quot;3 상속에 의한 클래스 확장 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 상속에 의한 클래스 확장&lt;/h1&gt;
&lt;p&gt;상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 &lt;strong&gt;&lt;em&gt;확장(extends)&lt;/em&gt;&lt;/strong&gt;하여 정의하는것이다.&lt;/p&gt;
&lt;p&gt;상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Base {}

class Derived extends Base {}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;extends 키워드는 클래스뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수 도 있다.&lt;/p&gt;
&lt;p&gt;extends 키워드 다음에는 클래스뿐만 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;super 키워드는 함수처럼 호출할 수 도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드이다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;super를 호출하면 수퍼클래스의 constructor를 호출한다.&lt;/li&gt;
&lt;li&gt;super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Base {
  constructor(a,b) {
    this.a = a;
    this.b = b;
  }
}

class Derived extends Base {
  constructor(a,b,c) {
    super(a,b);
    this.c = c;
  }
}

const derived = new Derived(1,2,3);
console.log(derived); // Derived {a: 1, b: 2, c: 3}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 한다.&lt;/li&gt;
&lt;li&gt;서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.&lt;/li&gt;
&lt;li&gt;super는 반드시 서브클래스의 constructor에서만 호출한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출 할 수 있다.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[23.실행 컨텍스트]]></title><description><![CDATA[실행컨택스트(execution context) 자바스크립트의 원리를 담고 있는 핵심 개념이다. 1. 소스코드의타입 실행컨텍스트는 다음과 같은 것들을 이용하면 execution context stack에 쌓이게된다. executionstack…]]></description><link>https://github.com/sangzun-han/자바스크립트/23.실행컨텍스트/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/23.실행컨텍스트/</guid><pubDate>Tue, 14 Dec 2021 14:00:00 GMT</pubDate><content:encoded>&lt;p&gt;실행컨택스트(execution context) 자바스크립트의 원리를 담고 있는 핵심 개념이다.&lt;/p&gt;
&lt;h1 id=&quot;1-소스코드의타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%86%8C%EC%8A%A4%EC%BD%94%EB%93%9C%EC%9D%98%ED%83%80%EC%9E%85&quot; aria-label=&quot;1 소스코드의타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 소스코드의타입&lt;/h1&gt;
&lt;p&gt;실행컨텍스트는 다음과 같은 것들을 이용하면 execution context stack에 쌓이게된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/executionstack.png&quot; alt=&quot;executionstack&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전역코드&lt;/li&gt;
&lt;li&gt;함수코드&lt;/li&gt;
&lt;li&gt;eval 코드&lt;/li&gt;
&lt;li&gt;모듈 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;2-렉시컬-환경&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD&quot; aria-label=&quot;2 렉시컬 환경 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 렉시컬 환경&lt;/h1&gt;
&lt;p&gt;렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값, 상위스코프에 대한 참조를 기록하는 자료구조이다.&lt;/p&gt;
&lt;p&gt;Lexical environmet는 EnvirenmetRecore와 OuterLexicalEnvironmentReference로 구성된다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;환경레코드(Environment Recode)&lt;/em&gt;&lt;/strong&gt; : 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;외부 렉시컬 환경에 대한 참조(OuterLexicalEnvironmentReference)&lt;/em&gt;&lt;/strong&gt;: 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/executioncontext.jpg&quot; alt=&quot;executioncontext&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-environment-recode&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-environment-recode&quot; aria-label=&quot;2 1 environment recode permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. Environment Recode&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;(Environment Recode)&lt;/em&gt;&lt;/strong&gt;에는 객체 환경 레코드(Object Environment Record)와 선언적 환경 레코드(Declarative Environment Record)로 구성되어 있다.&lt;/p&gt;
&lt;p&gt;Object Environment Record에는 var로 선언된 전역변수 전역함수, 빌트인 전역 프로퍼티와 전역함수,객체를 관리하고 Declarative Environment Record는 let, const 키워드로 선언한 전역 변수를 관리한다.&lt;/p&gt;
&lt;p&gt;전역 코드 평가 과정에서 var로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 Object Environment Record에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Object%20Environment%20Record.jpg&quot; alt=&quot;ObjectEnvironmentRecord&quot;&gt;&lt;/p&gt;
&lt;p&gt;따러서 var 키워드로 선언한 변수는 코드 실행 단계에서 변수 선언문 이전에도 참조할 수 있다.&lt;/p&gt;
&lt;p&gt;let,const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않기 때문에 전역 객체의 프로퍼티로서 참조할 수 없다. 따라서 런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 &lt;strong&gt;&lt;em&gt;TDZ&lt;/em&gt;&lt;/strong&gt;에 빠지게 된다.&lt;/p&gt;
&lt;p&gt;Global Environmnet Record에 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.&lt;/p&gt;
&lt;h3 id=&quot;2-2outerlexicalenvironmentreference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2outerlexicalenvironmentreference&quot; aria-label=&quot;2 2outerlexicalenvironmentreference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2.OuterLexicalEnvironmentReference&lt;/h3&gt;
&lt;p&gt;Outer LexicalEnvironment Reference는 현재 평가중인 소스코드를 포함하는 외부 소스코드의 상위 스코프를 가리킨다.&lt;/p&gt;
&lt;h1 id=&quot;3-요약&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%9A%94%EC%95%BD&quot; aria-label=&quot;3 요약 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 요약&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;자바스크립트 엔진이 코드를 실행시킬때 Execution Context라는 실행 가능한 환경을 만들고 Execution Context를 기준으로 코드를 실행한다.&lt;/li&gt;
&lt;li&gt;전역에서 생성되는 global execution context와 함수 실행 코드를 만나면 생성되는 function execution context가 있다.&lt;/li&gt;
&lt;li&gt;생성단계일 때 Lexical Environmet를 생성한다. 이때 Lexical Environemt에는 스코프의 변수와 함수를 선언한다.&lt;/li&gt;
&lt;li&gt;실행단계일 때 스크립트를 읽으며 생성한 Lexical Environemt에 할당 및 코드를 실행한다.&lt;/li&gt;
&lt;li&gt;Execution statck이 빌 때 까지 위의 동작을 반복한다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[22.this]]></title><description><![CDATA[1. this 키워드 메서드는 프로퍼티를 참조하고 변경할 수 있어야 한다. 이 때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다. this…]]></description><link>https://github.com/sangzun-han/자바스크립트/22. this 키워드/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/22. this 키워드/</guid><pubDate>Mon, 13 Dec 2021 14:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-this-키워드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-this-%ED%82%A4%EC%9B%8C%EB%93%9C&quot; aria-label=&quot;1 this 키워드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. this 키워드&lt;/h1&gt;
&lt;p&gt;메서드는 프로퍼티를 참조하고 변경할 수 있어야 한다. 이 때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;this 바인딩 : 바인딩이랑 식별자와 값을 연결하는 과정을 의미한다. this 바인딩은 this가 가리킬 객체를 바인딩 한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 생성자 함수
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getDiameter = function () {
  return 2 * this.radius;
};

// 인스턴스 생성
const circle = new Circle(15);
console.log(circle.getDiameter()); // 30&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 즉 circle을 가리킨다. &lt;/p&gt;
&lt;p&gt;생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this는 상황에 따라 가리키는 대상이 다르다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 this는 함수가 호출되는 방식에 따라 this 바인딩이 동적으로 결정된다. 또한 strict mode는 this 바인딩에 영향을 준다.&lt;/p&gt;
&lt;h1 id=&quot;2-함수-호출-방식과-this-바인딩&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%B0%A9%EC%8B%9D%EA%B3%BC-this-%EB%B0%94%EC%9D%B8%EB%94%A9&quot; aria-label=&quot;2 함수 호출 방식과 this 바인딩 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 함수 호출 방식과 this 바인딩&lt;/h1&gt;
&lt;h3 id=&quot;2-1-일반-함수-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-%EC%9D%BC%EB%B0%98-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;2 1 일반 함수 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. 일반 함수 호출&lt;/h3&gt;
&lt;p&gt;기본적으로 this에는 전역 객체가 바인딩된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function foo() {
	console.log(this) // undefined
	function bar() {
		console.log(this) // undefined
	}
	bar()
}
foo()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중첩함수를 일반 함수로 호출하면 함수 내부의 this에는 전역객체가 바인됭된다. strict mode가 적용된 일반 함수 내부에는 undefined가 바인딩된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;메서드 내부의 중첩함수나 콜백함수의 this 바인딩을 메서드의 this 바인딩과 일치시키는 방법&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const obj = {
  value: 100,
  foo() {
    const that = this;

    setTimeout(function () {
      console.log(that.value);
    }, 1000);
  },
};

obj.foo();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-2-메서드-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;2 2 메서드 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. 메서드 호출&lt;/h3&gt;
&lt;p&gt;메서드 내부의 this에는 메서드를 호출한 객체가 바인딩 된다. 메서드 내부의 this는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체가 바인딩 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person = {
  name: &quot;Lee&quot;,
  getName() {
    return this.name;
  },
};

console.log(person.getName());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const anotherPerson = {
  name: &quot;Kim&quot;,
};

anotherPerson.getName = person.getName;

console.log(anotherPerson.getName()); // kim

const getName = person.getName;
console.log(getName()); // 일반 함수로 호출된 getName 함수는  내부의 this.name은 window.name과 같다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-3-생성자-함수-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-3-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;2 3 생성자 함수 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-3. 생성자 함수 호출&lt;/h3&gt;
&lt;p&gt;생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩된다.&lt;/p&gt;
&lt;h3 id=&quot;2-4-functionprototypeapplycallbind&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-4-functionprototypeapplycallbind&quot; aria-label=&quot;2 4 functionprototypeapplycallbind permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-4. Function.prototype.apply/call/bind&lt;/h3&gt;
&lt;p&gt;apply,call,bind 메서드는 Function.prototype의 메서드다. 따라서 이 메서드들은 모든 함수가 상속받아 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function getThisBinding() {
  return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding()); // window

console.log(getThisBinding.apply(thisArg)); // {a:1}
console.log(getThisBinding.call(thisArg)); // {a:1}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;apply와 call 메서드는 함수를 호출하는 것이다. apply와 call 메서드는 함수를 호출하면서 첫 번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function getThisBinding() {
  console.log(arguments);
  return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding());

console.log(getThisBinding.apply(thisArg, [1, 2, 3]));
console.log(getThisBinding.call(thisArg, 1, 2, 3));&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다. call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트로 전달한다.&lt;/p&gt;
&lt;p&gt;Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않고 this로 사용할 객체만 전달한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function getThisBinding() {
  return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding.bind(thisArg));
console.log(getThisBinding.bind(thisArg)()); // 명시적으로 호출&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[21. 빌트인 객체]]></title><description><![CDATA[1. 자바스크립트 객체의 분류 자바스크립트 객체는 크게 3개의 객체로 분류할 수 있다. 표준 빌트인 객체(standard built-in objects/native objects/global objects) 표준 빌트인 객체는 ECMAScript…]]></description><link>https://github.com/sangzun-han/자바스크립트/21.빌트인 객체/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/21.빌트인 객체/</guid><pubDate>Sat, 11 Dec 2021 07:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-자바스크립트-객체의-분류&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B6%84%EB%A5%98&quot; aria-label=&quot;1 자바스크립트 객체의 분류 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 자바스크립트 객체의 분류&lt;/h1&gt;
&lt;p&gt;자바스크립트 객체는 크게 3개의 객체로 분류할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;표준 빌트인 객체(standard built-in objects/native objects/global objects)&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며 자바스크립트 실행 환경과 관계없이 언제나 사용할수 있다. 별도의 선언 없이 전역 변수처럼 언제나 참조 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;호스트 객체(host objects)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;호스트 객체는 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자 정의 객체(user-defined objects)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사용자 정의 객체는 사용자가 직접 정의한 객체이다.&lt;/p&gt;
&lt;h1 id=&quot;2-표준-빌트인-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%91%9C%EC%A4%80-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;2 표준 빌트인 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 표준 빌트인 객체&lt;/h1&gt;
&lt;p&gt;자바스크립트는 Object, String, Number, Symbol, Date등 40여개의 표준 빌트인 객체를 제공한다.&lt;/p&gt;
&lt;p&gt;Math, Reflect, JSON을제외한 표준 빌트인객체는 모두 인서턴스를 생성할수 있는 생성자 함수 객체다. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-원시값과-래퍼-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EB%9E%98%ED%8D%BC-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;3 원시값과 래퍼 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 원시값과 래퍼 객체&lt;/h1&gt;
&lt;p&gt;원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없지만 원시값인 문자열은 객처럼 동작한다. 이것은 원시값인 문자열, 숫자, 불리언 값의 경우 원시값에 대해 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해주기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const str = &quot;hello&quot;;

console.log(str.length) // 5

console.log(typeof str); // string&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.&lt;/p&gt;
&lt;p&gt;이 때 생성되는 객체를 &lt;strong&gt;&lt;em&gt;래퍼 객체(wrapper object)라 한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아래의 그림은 &lt;strong&gt;문자열 래퍼 객체의 프로토타입 체인&lt;/strong&gt;을 나태난 그림이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wrapper.jpg&quot; alt=&quot;wrapper&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-전역-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;4 전역 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 전역 객체&lt;/h1&gt;
&lt;p&gt;전역 객체는 코드가 실행되기 이전에 가장 먼저 생성되는 객체이며, 어떤 객체에도 속하지 않는 최상위 객체이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전역객체는 개발자가 의도적으로 생성할 수 없다. 즉 생성자 함수가 제공되지 않는다.&lt;/li&gt;
&lt;li&gt;전역객체의 프로퍼티를 참조할때 window(또는 global)를 생략할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-1-빌트인-전역-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-1-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%A0%84%EC%97%AD-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;4 1 빌트인 전역 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-1. 빌트인 전역 프로퍼티&lt;/h3&gt;
&lt;p&gt;빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Infinity&lt;/li&gt;
&lt;li&gt;NaN&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-2-빌트인-전역-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-2-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%A0%84%EC%97%AD-%ED%95%A8%EC%88%98&quot; aria-label=&quot;4 2 빌트인 전역 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-2. 빌트인 전역 함수&lt;/h3&gt;
&lt;p&gt;빌트인 전역 함수는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로 전역 객체의 메서드다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eval : eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 전달 받는다. 문자열 코드가 여러개의 문으로 이루어져 있다면 모든 문을 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;eval(&apos;1+2;&apos;) //3

eval(&apos;var x = 5;&apos;) // undefined&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;eval 함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드에 비해 처리 속도가 느리다 따라서 eval 함수의 사용은 금지.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inFinite : 전달받은 인수가 유한수라면 true, 무한수라면 false&lt;/li&gt;
&lt;li&gt;isNaN : 전달받은 인수가 NaN이면 ture 아니라면 false&lt;/li&gt;
&lt;li&gt;parseFloat : 전달받은 문자열 인수를 실수로 해석하여 반환&lt;/li&gt;
&lt;li&gt;parseInt : 전달받은 문자열 인수를 정수로 해석하여 반환&lt;/li&gt;
&lt;li&gt;endcodeURI / decodeURI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;URI는 인터넷이 있는 자원을 나타내는 주소이다. URI의 하위개념으로 URL, URN이 있다.&lt;/p&gt;
&lt;p&gt;encodeURI는 URI를 문자열로 전달받아 인코딩한다. decodeURI는 인코딩된 URI를 인수로 전달받아 디코딩한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;인코딩이란 URI문자들을 ASCII 문자 셋으로 변환하는 것을 뜻한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-3-암묵적-전역&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-3-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%A0%84%EC%97%AD&quot; aria-label=&quot;4 3 암묵적 전역 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-3. 암묵적 전역&lt;/h3&gt;
&lt;p&gt;암묵적 전역이란 전역 객체의 프로퍼티가 되어 마치 전역변수처럼 동작하는것을 말한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(y); // y is not defined

function foo() {
  y = 20;
}
foo();

console.log(y) // 20&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;y는 변수 선언 없이 단지 전역 객체의 프로퍼티 추가되었을 뿐이다. y는 변수가 아니다 그러므로 변수 호이스팅도 발생하지 않는다.&lt;/p&gt;
&lt;p&gt;프로퍼티인 y는 delete 연산자로 삭제할 수 있다. 전역변수는 delete로 삭제할 수 없다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[20. strict mode]]></title><description><![CDATA[1. strict mode 오타나 문법 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는것이 좋다. ES5부터 strict…]]></description><link>https://github.com/sangzun-han/자바스크립트/20.strict mode/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/20.strict mode/</guid><pubDate>Fri, 10 Dec 2021 14:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-strict-mode&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-strict-mode&quot; aria-label=&quot;1 strict mode permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. strict mode&lt;/h1&gt;
&lt;p&gt;오타나 문법 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는것이 좋다.&lt;/p&gt;
&lt;p&gt;ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.&lt;/p&gt;
&lt;p&gt;ESLint 같은 린트도구를 사용해더 strict mode와 유사한 효과를 얻을 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;2-strict-mode-적용&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-strict-mode-%EC%A0%81%EC%9A%A9&quot; aria-label=&quot;2 strict mode 적용 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. strict mode 적용&lt;/h1&gt;
&lt;p&gt;strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두애 ‘use strict’;을 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&apos;use strict&apos;;

function foo() {
  x = 10; // ReferenceError 
}

foo()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;전역에 적용한 strict mode는 스크립트 단위로 적용된다.&lt;/p&gt;
&lt;p&gt;strict mode 스크립트와 non-strict mode 스크립트를 혼용하는것은 오류를 발생시킬 수 있다. 특히 외부 서드파티 라이브러리를 사용하는 경우 라이브러리가 non-strict mode인 경우도 있기 때문에 전역에 strict mode를 쓰는것은 바람직 하지 않다. &lt;/p&gt;
&lt;p&gt;대신 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() {
  &apos;use strict&apos;;

  // ~~~~
}();)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 어떤 함수는 strict mode를 적용하고 어떤 함수는 strict mode를 적용하지 않는 것은 바람직 하지 않으며 모든 함수에 일일이 strict mode를 적용하는것은 번거롭다.&lt;/p&gt;
&lt;p&gt;따라서 strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.&lt;/p&gt;
&lt;h1 id=&quot;3-strict-mode-에러&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-strict-mode-%EC%97%90%EB%9F%AC&quot; aria-label=&quot;3 strict mode 에러 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. strict mode 에러&lt;/h1&gt;
&lt;h3 id=&quot;3-1-암묵적-전역&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-1-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%A0%84%EC%97%AD&quot; aria-label=&quot;3 1 암묵적 전역 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-1. 암묵적 전역&lt;/h3&gt;
&lt;p&gt;선언하지 않은 변수를 참조하면 ReferenceError가 발생한다.&lt;/p&gt;
&lt;h3 id=&quot;3-2-삭제&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-2-%EC%82%AD%EC%A0%9C&quot; aria-label=&quot;3 2 삭제 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-2. 삭제&lt;/h3&gt;
&lt;p&gt;delete 연산자로 변수,함수,매개변수를 삭제하면 SyntaxError가 발생한다&lt;/p&gt;
&lt;h3 id=&quot;3-3-매개변수-이름-중복&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-3-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84-%EC%A4%91%EB%B3%B5&quot; aria-label=&quot;3 3 매개변수 이름 중복 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-3. 매개변수 이름 중복&lt;/h3&gt;
&lt;p&gt;중복된 매개변수 이름을 사용하면 SyntaxError가 발생한다.&lt;/p&gt;
&lt;h3 id=&quot;3-4-with-문의-사용&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-4-with-%EB%AC%B8%EC%9D%98-%EC%82%AC%EC%9A%A9&quot; aria-label=&quot;3 4 with 문의 사용 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-4. with 문의 사용&lt;/h3&gt;
&lt;p&gt;with문을 사용하면 SyntaxError가 발생한다.&lt;/p&gt;
&lt;h1 id=&quot;4-strict-mode-적용에-의한-변화&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-strict-mode-%EC%A0%81%EC%9A%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%B3%80%ED%99%94&quot; aria-label=&quot;4 strict mode 적용에 의한 변화 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. strict mode 적용에 의한 변화&lt;/h1&gt;
&lt;h3 id=&quot;4-1-일반함수의-this&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-1-%EC%9D%BC%EB%B0%98%ED%95%A8%EC%88%98%EC%9D%98-this&quot; aria-label=&quot;4 1 일반함수의 this permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-1. 일반함수의 this&lt;/h3&gt;
&lt;p&gt;strict mode에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에는 this가 필요 없기 때문이다.&lt;/p&gt;
&lt;h3 id=&quot;4-2-arguments-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-2-arguments-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;4 2 arguments 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-2. arguments 객체&lt;/h3&gt;
&lt;p&gt;strict mode에서는 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않는다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[19. 프로토타입]]></title><description><![CDATA[자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어다. ES…]]></description><link>https://github.com/sangzun-han/자바스크립트/19.프로토타입/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/19.프로토타입/</guid><pubDate>Mon, 06 Dec 2021 14:00:00 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어다.&lt;/p&gt;
&lt;p&gt;ES6에서 클래스가 도입되었지만 그렇다고 프로토타입 기반 객체지향을 폐지하고 새로운 객체지향 모델을 제공하는것은 아니다. 클래스도 함수이며 프로토타입 기반 패턴의 문법적 설탕&lt;strong&gt;&lt;em&gt;(syntactic sugar)&lt;/em&gt;&lt;/strong&gt;이다.&lt;/p&gt;
&lt;h1 id=&quot;1-객체지향-프로그래밍&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D&quot; aria-label=&quot;1 객체지향 프로그래밍 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 객체지향 프로그래밍&lt;/h1&gt;
&lt;p&gt;객체지향 프로그래밍은 여러 개의 독립적 단위, 즉 객체(Object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const circle = {
	radius: 5,
	
	getDiameter() {
		return 2 * this.radius;
	}	
	
	getPerimeter() {
		return 2 * Math.PI * this.radius;
	}
	
	getArea() {
		return Math.PI * this.radius ** 2;
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체지향 프로그래밍은 객체의 상태&lt;strong&gt;&lt;em&gt;(state)&lt;/em&gt;&lt;/strong&gt;를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작&lt;strong&gt;&lt;em&gt;(be-havior)&lt;/em&gt;&lt;/strong&gt;을 하나의 논리적인 단위로 묶어 생각한다.&lt;/p&gt;
&lt;p&gt;이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다.&lt;/p&gt;
&lt;h1 id=&quot;2-상속과-프로토타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%83%81%EC%86%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85&quot; aria-label=&quot;2 상속과 프로토타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 상속과 프로토타입&lt;/h1&gt;
&lt;p&gt;상속을 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.&lt;/p&gt;
&lt;p&gt;자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Circle(radius) {
	this.radius = radius;
	this.getArea = function() {
		return Math.PI * this.radius ** 2;
	};
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Circle 생성자 함수가 생성하는 모든객체는 radius 프로퍼티와 getArea 메서드를 갖는다. radius 프로퍼티의 값은 일반적으로 인스턴스마다 다르다. 하지만 getArea메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용한다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때 마다 getArea 메서드를 중복 생성한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Circle(radius) {
	this.radius = radius;
}

Circle.prototype.getArea = function() {
	return Math.PI * this.radius ** 2;
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 갖는다.&lt;/p&gt;
&lt;h1 id=&quot;3-프로토타입-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;3 프로토타입 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 프로토타입 객체&lt;/h1&gt;
&lt;p&gt;프로토타입 객체는 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체다.&lt;/p&gt;
&lt;p&gt;모든 객체는 하나의 프로토타입을 갖는다. 모든 프로토타입은 생성자 함수와 연결되어 있다.&lt;/p&gt;
&lt;h3 id=&quot;3-1-__proto__-접근자-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-1-__proto__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;3 1 __proto__ 접근자 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-1. _&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티&lt;/h3&gt;
&lt;p&gt;모든 객체는 _&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티를 통해 자신의 프로토타입에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;_&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 Object.prototype._&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티를 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person = { name: &apos;Lee&apos;};

console.log(person.hasOwnProperty(&apos;__proto__&apos;); // false
console.log(Object.getOwnPropertyDescriptor(Object.prototype, &apos;__proto__&apos;));
/*
	configurable: true
	enumerable: false
	get: ƒ __proto__()
	set: ƒ __proto__()
*/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;_&lt;/strong&gt;proto____ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 —&gt; 상호참조에 의해 프로토타입 체인이 생성되는것을 방지하기 위해&lt;/p&gt;
&lt;p&gt;프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 순환 참조하는 프로토타입 체인이 만드어지면 종점이 존재하지 않기 때문에 프로퍼티를 검색할 때 무한루프에 빠진다.&lt;/p&gt;
&lt;p&gt;_&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우엔 Object.getPrototypeOf 메서드를 사용하고 프로토타입을 교체하고 싶은 경우엔 Object.setPrototypeOf 메서드 사용을 권장한다.&lt;/p&gt;
&lt;h3 id=&quot;3-2-함수-객체의-prototype-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-2-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;3 2 함수 객체의 prototype 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-2. 함수 객체의 prototype 프로퍼티&lt;/h3&gt;
&lt;p&gt;prototype 프로퍼티는 생성자 함수로 호출할수 있는 객체 즉 constructor를 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없다.&lt;/p&gt;
&lt;p&gt;화살표함수와 ES6 메서드 축약 표현으로 정의된 메서드는 non-constructor로 prototype 프로퍼티가 없다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function func() {}
func.hasOwnProperty(&apos;prototype&apos;) // true

const obj = {}
obj.hasOwnProperty(&apos;prototype&apos;) // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-3-프로토타입의-constructor-프로퍼티와-생성자-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98&quot; aria-label=&quot;3 3 프로토타입의 constructor 프로퍼티와 생성자 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수&lt;/h3&gt;
&lt;p&gt;모든 프로토타입은 constructor 프로퍼티를 갖는다. 생성자 함수에 의해 생성된 객체는 constructor 프로퍼티를 통해 생성자 함수와 연결된다.
생성자 함수로 생성한 것이 아닌, 리터럴 표기법으로 생성하여도 constructor 프로퍼티가 연결된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function Person(name) {
  this.name = name
}
const me = new Person(&apos;kmj&apos;) // Person 생성자로 만들어진 me 객체
me.constructor === Person // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-리터럴-표기법-의해-생성된-객체의-생성자-함수와-프로토타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%91%9C%EA%B8%B0%EB%B2%95-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85&quot; aria-label=&quot;4 리터럴 표기법 의해 생성된 객체의 생성자 함수와 프로토타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 리터럴 표기법 의해 생성된 객체의 생성자 함수와 프로토타입&lt;/h1&gt;
&lt;p&gt;리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다.&lt;/p&gt;
&lt;h1 id=&quot;5-프로토타입의-생성-시점&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90&quot; aria-label=&quot;5 프로토타입의 생성 시점 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 프로토타입의 생성 시점&lt;/h1&gt;
&lt;p&gt;프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.&lt;/p&gt;
&lt;p&gt;생성자 함수로서 호출할 수 있는 함수, 즉 constructor 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(Person.prototype) // {constructor: ƒ}

function Person(name) {
	this.name = name;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;생성자 함수로서 호출할 수 없는함수, non-constructor는 프로토타입이 생성되지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const Person = name =&gt; {
	this.name = name;
};

console.log(Person.prototype); // undefined&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체가 생성되기 전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다.&lt;/p&gt;
&lt;h1 id=&quot;6-객체-생성-방식과-프로토타입의-결정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B2%B0%EC%A0%95&quot; aria-label=&quot;6 객체 생성 방식과 프로토타입의 결정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 객체 생성 방식과 프로토타입의 결정&lt;/h1&gt;
&lt;p&gt;객체를 생성하는 방식에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스 등 다양한 방법이 존재한다.&lt;/p&gt;
&lt;p&gt;세부적인 생성 방식에는 차이가 있으나, 모두 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.&lt;/p&gt;
&lt;h1 id=&quot;7-프로토타입-체인&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8&quot; aria-label=&quot;7 프로토타입 체인 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 프로토타입 체인&lt;/h1&gt;
&lt;p&gt;자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체의 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 &lt;strong&gt;&lt;em&gt;프로토타입 체인&lt;/em&gt;&lt;/strong&gt; 이라고 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.&lt;/p&gt;
&lt;p&gt;프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다. &lt;strong&gt;&lt;em&gt;Object.prototype을 프로토타입 체인의 종점(end of prototype chain)&lt;/em&gt;&lt;/strong&gt;이라 한다&lt;/p&gt;
&lt;h1 id=&quot;8-오버라이딩과-프로퍼티-섀도잉&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%84%80%EB%8F%84%EC%9E%89&quot; aria-label=&quot;8 오버라이딩과 프로퍼티 섀도잉 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. 오버라이딩과 프로퍼티 섀도잉&lt;/h1&gt;
&lt;p&gt;상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉(property shadowing)이라 한다.&lt;/p&gt;
&lt;h1 id=&quot;9-프로토타입의-교체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#9-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4&quot; aria-label=&quot;9 프로토타입의 교체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. 프로토타입의 교체&lt;/h1&gt;
&lt;p&gt;프로토타입은 임의의 다른 객체로 변경할 수 있다. 즉 부모 객체의 프로토타입을 동적으로 변경할 수 있다. 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 번거롭다. 따라서 직접 교체하지 않는것이 좋다.&lt;/p&gt;
&lt;h1 id=&quot;10-instaceof-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#10-instaceof-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;10 instaceof 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;10. instaceof 연산자&lt;/h1&gt;
&lt;p&gt;instaceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토티입 체인 상에 존재하면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;instanceof 연산자는 생성자 함수의 prototypedp 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.&lt;/p&gt;
&lt;h1 id=&quot;11-직접-상속&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#11-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D&quot; aria-label=&quot;11 직접 상속 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;11. 직접 상속&lt;/h1&gt;
&lt;p&gt;Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdiranyObjectCreate를 호출한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;new 연산자가 없이도 객체를 생성할 수 있다.&lt;/li&gt;
&lt;li&gt;프로토타입을 지정하면서 객체를 생성할 수 있다.&lt;/li&gt;
&lt;li&gt;객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Object.create 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문에 객체가 직접 호출하는 것을 권장하지 않는다.&lt;/p&gt;
&lt;p&gt;ES6에서는 객체 리터럴 내부에서 _&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const myProto = {x: 10};

const obj = {
	y: 20,
	__proto__: myProto
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;12-정적-프로퍼티메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#12-%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;12 정적 프로퍼티메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;12. 정적 프로퍼티/메서드&lt;/h1&gt;
&lt;p&gt;정적(static) 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/매서드를 말한다.&lt;/p&gt;
&lt;h1 id=&quot;13-프로퍼티-존재-확인&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#13-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A1%B4%EC%9E%AC-%ED%99%95%EC%9D%B8&quot; aria-label=&quot;13 프로퍼티 존재 확인 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;13. 프로퍼티 존재 확인&lt;/h1&gt;
&lt;p&gt;in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다. &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person ={
	name: &apos;Lee&apos;,
	address: &apos;Seoul&apos;
}

console.log(&apos;name&apos; in person); // true
console.log(&apos;age&apos; in person); // false
console.log(&apos;toString&apos; in person); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;person 객체에는 toString이라는 프로퍼티가 없지만 in 연산자는 person 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문에 true이다.&lt;/p&gt;
&lt;p&gt;in 연산자 대신 ES6에서 도입된 Reflect.has 메서드를 사용할 수도 있다. Reflect.has 메서드는 in 연산자와 동일하게 동작한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person ={
	name: &apos;Lee&apos;,
	address: &apos;Seoul&apos;
}

console.log(Reflect.has(person, &apos;name&apos;)); // true
console.log(Reflect.has(person, &apos;toString&apos;); // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;14-프로퍼티-열거&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#14-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%97%B4%EA%B1%B0&quot; aria-label=&quot;14 프로퍼티 열거 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;14. 프로퍼티 열거&lt;/h1&gt;
&lt;p&gt;객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for … in 문을 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person ={
	name: &apos;Lee&apos;,
	address: &apos;Seoul&apos;
};

for (const key in person) {
	console.log(key + &apos; : &apos; + person[key]);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;for … in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티를 순회하며 열거(enumeration)한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;for … in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다. 하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자인 프로퍼티 키에 대해서는 정렬을 한다.&lt;/p&gt;
&lt;p&gt;배열에는 for … in 문보다는 for문이나 for … of 또는 Array.prototypes.forEach메서드 사용을 권장한다.&lt;/p&gt;
&lt;p&gt;Object.keys 메서드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[18. 함수와 일급 객체]]></title><description><![CDATA[…]]></description><link>https://github.com/sangzun-han/자바스크립트/18.함수와 일급 객체/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/18.함수와 일급 객체/</guid><pubDate>Thu, 02 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-일급-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;1 일급 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 일급 객체&lt;/h1&gt;
&lt;p&gt;아래의 조건을 만족하는 객체를 일급 객체라 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;무명의 리터럴로 생성할 수 있다.&lt;/li&gt;
&lt;li&gt;변수나 자료구조에 저장할 수 있다.&lt;/li&gt;
&lt;li&gt;함수의 매개변수에 전달할 수 있다.&lt;/li&gt;
&lt;li&gt;함수의 반환값으로 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;자바스크립트에서 함수는 객체다. 객체이므로 값과 동일하게 취급할 수 있다. 따라서 매개변수에 함수를 전달할 수 있고 함수의 반환값으로도 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;함수와 일반객체와의 차이는 일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있다. 또한 함수는 프로퍼티를 가지고 있다.&lt;/p&gt;
&lt;h1 id=&quot;2-함수-객체의-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 함수 객체의 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 함수 객체의 프로퍼티&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function square(number) {
  return number * number;
}

console.dir(square) // ƒ square(number)

console.log(Object.getOwnPropertyDescriptors(square))
/*
  {length: {…}, name: {…}, arguments: {…}, caller: {…}, prototype: {…}}
*/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 고유 프로퍼티다.&lt;/p&gt;
&lt;h3 id=&quot;2-1-arguments-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-arguments-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 1 arguments 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. arguments 프로퍼티&lt;/h3&gt;
&lt;p&gt;arguments 프로퍼티 값은 arguments 객체다. arguments 객체는 함수 호출시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다.&lt;/p&gt;
&lt;p&gt;선언된 매개변수의 개수보다 인수를 적게 전달했을경우 매개변수는 undefined로 초기화된 상태를 유지하며 매개변수의 개수보다 많은 인수를 전달한 경우 초과된 인수는 무시한다 이 때 모든 인수는 arguments 객체의 프로퍼티로 보관된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function multiply(x,y) {
  console.log(arguments);
  return x != y;
}

console.log(multiply(1,2,3))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-2-caller-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-caller-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 2 caller 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. caller 프로퍼티&lt;/h3&gt;
&lt;p&gt;caller 프로퍼티는 ECMAScript 사양에 포함되지 않는 비표준 프로퍼티다.
함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 기리킨다.&lt;/p&gt;
&lt;h3 id=&quot;2-3-lenght-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-3-lenght-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 3 lenght 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-3. lenght 프로퍼티&lt;/h3&gt;
&lt;p&gt;함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.&lt;/p&gt;
&lt;p&gt;arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티 값은 다를 수 있다. arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고 함수 객체의 length 프로퍼티는 매개변수의 개수를 기리킨다.&lt;/p&gt;
&lt;h3 id=&quot;2-4-name-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-4-name-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 4 name 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-4 name 프로퍼티&lt;/h3&gt;
&lt;p&gt;함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. ES6에서 정식표준&lt;/p&gt;
&lt;h3 id=&quot;2-5-__proto__-접근자-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-5-__proto__-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 5 __proto__ 접근자 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-5. _&lt;strong&gt;_proto__&lt;/strong&gt; 접근자 프로퍼티&lt;/h3&gt;
&lt;p&gt;모든객체는 [[Prototype]]이라는 내부슬롯을 가진다. _&lt;strong&gt;_proto__&lt;/strong&gt;는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체이 접근하기 위해 사용하는 접근자 프로퍼티다.&lt;/p&gt;
&lt;h3 id=&quot;2-6-prototype-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-6-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;2 6 prototype 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-6 prototype 프로퍼티&lt;/h3&gt;
&lt;p&gt;prototype 프로퍼티는 생성자 함수로 호출할 수 있는 객체, 즉 constructor만이 소유하는 프로퍼티다. 함수 객체의 경우는 constructor (생성자 함수)로 호출할 수 있기때문에, prototype property를 가진다고 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[16. 프로퍼티 어트리뷰트]]></title><description><![CDATA[1. 내부슬롯과 내부메소드 프로퍼티 어트리뷰트를 이해하기 위해서는 내부 슬롯(internal slot)과 내부 메서드(internal method…]]></description><link>https://github.com/sangzun-han/자바스크립트/16.프로퍼티 어트리뷰트/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/16.프로퍼티 어트리뷰트/</guid><pubDate>Wed, 01 Dec 2021 04:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-내부슬롯과-내부메소드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%82%B4%EB%B6%80%EC%8A%AC%EB%A1%AF%EA%B3%BC-%EB%82%B4%EB%B6%80%EB%A9%94%EC%86%8C%EB%93%9C&quot; aria-label=&quot;1 내부슬롯과 내부메소드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 내부슬롯과 내부메소드&lt;/h1&gt;
&lt;p&gt;프로퍼티 어트리뷰트를 이해하기 위해서는 내부 슬롯(internal slot)과 내부 메서드(internal method)의 개념이 필요하다.&lt;/p&gt;
&lt;p&gt;내부슬롯과 내부메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사메서드이다. 이중 대괄호로 감싼 이름들이 내부슬롯과 내부메서드이다.&lt;/p&gt;
&lt;h1 id=&quot;2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부상태 값이다. 따라서 직접 접근할 수 없지만 간접적으로 확인할 수 는 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person = {
  name: &apos;Lee&apos;,
}

console.log(Object.getOwnPropertyDescriptor(person, &apos;name&apos;))

// {value: &apos;Lee&apos;, writable: true, enumerable: true, configurable: true}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 &lt;strong&gt;&lt;em&gt;프로퍼티 디스크립터(PropertyDescriptor)&lt;/em&gt;&lt;/strong&gt;객체를 반환한다.&lt;/p&gt;
&lt;h1 id=&quot;3-데이터-프로퍼티와-접근자-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;3 데이터 프로퍼티와 접근자 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 데이터 프로퍼티와 접근자 프로퍼티&lt;/h1&gt;
&lt;p&gt;데이터 프로퍼티 : 키와 값으로 구성된 프러퍼티&lt;/p&gt;
&lt;p&gt;접근자 프로퍼티 : 자체적으로 값을 갖지 않고 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티&lt;/p&gt;
&lt;h3 id=&quot;3-1-데이터-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-1-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;3 1 데이터 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-1. 데이터 프로퍼티&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;프로퍼티 어트리뷰트&lt;/th&gt;
&lt;th&gt;프로퍼티 디스크립터 객체의 프로퍼티&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[[Value]]&lt;/td&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;프로퍼티 값의 변경 가능 여부를 나타내며 boolean 값을 갖는다&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[Writable]]]&lt;/td&gt;
&lt;td&gt;writable&lt;/td&gt;
&lt;td&gt;프로퍼티 키를 통해 프로퍼티 값에 접근하면 반한되는 값&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[Enumerable]]&lt;/td&gt;
&lt;td&gt;enumrable&lt;/td&gt;
&lt;td&gt;프로퍼티의 열거 가능 여부를 나타내며 boolean 값을 갖는다&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[Configurable]]&lt;/td&gt;
&lt;td&gt;configurable&lt;/td&gt;
&lt;td&gt;프로퍼티의 재정의 가능 여부를 나타낸다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;32-접근자-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#32-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;32 접근자 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3.2 접근자 프로퍼티&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;프로퍼티 어트리뷰트&lt;/th&gt;
&lt;th&gt;프로퍼티 디스크립터 객체의 프로퍼티&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[[Get]]&lt;/td&gt;
&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[Set]]]&lt;/td&gt;
&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[Enumerable]]&lt;/td&gt;
&lt;td&gt;enumrable&lt;/td&gt;
&lt;td&gt;프로퍼티의 열거 가능 여부를 나타내며 boolean 값을 갖는다&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[[Configurable]]&lt;/td&gt;
&lt;td&gt;configurable&lt;/td&gt;
&lt;td&gt;프로퍼티의 재정의 가능 여부를 나타낸다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const person = {
  firstName: &apos;Han&apos;,
  lastName: &apos;sangjun&apos;,

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(name) {
    [this.firstName, this.lastName] = name.split(&apos; &apos;);
  }
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(person.firstName + &apos; &apos; + person.lastName) //Han sangjun
person.fullName = &quot;Heegun Lee&quot; // set함수 실행

let descriptor = Object.getOwnPropertyDescriptor(person, &apos;firstName&apos;)
console.log(descriptor)

//
  {value: &apos;Heegun&apos;, writable: true, enumerable: true, configurable: true} 
//

let descriptor = Object.getOwnPropertyDescriptor(person, &apos;fullName&apos;)
console.log(descriptor)

//
  {enumerable: true, configurable: true, get: ƒ, set: ƒ}
//&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-프로퍼티-정의&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A0%95%EC%9D%98&quot; aria-label=&quot;4 프로퍼티 정의 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 프로퍼티 정의&lt;/h1&gt;
&lt;p&gt;Object.defineProperty 메서드를 사용하여 프로퍼티 어트리뷰트를 정의할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Object.defineProperty(person, &apos;firstName&apos; , {
  value: &quot;~~~&quot;,
  writable: true of false,
  enumerable: true of false,
  configurable: true of false,
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;프로퍼티 디스크립터 객체의 프로퍼티&lt;/th&gt;
&lt;th&gt;대응하는 프로퍼티 어트리뷰트&lt;/th&gt;
&lt;th&gt;생략했을 때 기본 값&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;[[Value]]&lt;/td&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;[[Get]]&lt;/td&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;[[Set]]&lt;/td&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;writable&lt;/td&gt;
&lt;td&gt;[[Writable]]&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enumerable&lt;/td&gt;
&lt;td&gt;[[Enumerable]]&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;configurable&lt;/td&gt;
&lt;td&gt;[[Configurable]]&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Object.defineProperties 메서드를 사용하면 여러개의 프로퍼티를 한 번에 정의할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;5-객체-변경감지&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EA%B0%9D%EC%B2%B4-%EB%B3%80%EA%B2%BD%EA%B0%90%EC%A7%80&quot; aria-label=&quot;5 객체 변경감지 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 객체 변경감지&lt;/h1&gt;
&lt;p&gt;객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다. 프로퍼티를 추가하거나 삭제할 수 있고 프로퍼티 값을 갱신할 수 있으며 프로퍼티 어트리뷰트를 재정의 할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;5-1-객체-확장-금지&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-1-%EA%B0%9D%EC%B2%B4-%ED%99%95%EC%9E%A5-%EA%B8%88%EC%A7%80&quot; aria-label=&quot;5 1 객체 확장 금지 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5-1. 객체 확장 금지&lt;/h3&gt;
&lt;p&gt;Object.perventExtensions 메서드는 객체의 확장을 금지한다. &lt;strong&gt;&lt;em&gt;객체 확장 금지&lt;/em&gt;&lt;/strong&gt;란 프로퍼티 추가 금지를 의미힌다.&lt;/p&gt;
&lt;h3 id=&quot;5-2-객체-밀봉&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-2-%EA%B0%9D%EC%B2%B4-%EB%B0%80%EB%B4%89&quot; aria-label=&quot;5 2 객체 밀봉 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5-2. 객체 밀봉&lt;/h3&gt;
&lt;p&gt;Object.seal 메서드는 객체를 밀봉한다. &lt;strong&gt;&lt;em&gt;밀봉된 객체는 읽기와 쓰기만 가능하다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-3-객체-동결&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-3-%EA%B0%9D%EC%B2%B4-%EB%8F%99%EA%B2%B0&quot; aria-label=&quot;5 3 객체 동결 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5-3 객체 동결&lt;/h3&gt;
&lt;p&gt;Object.freeze 메서드는 객체를 동결한다. &lt;strong&gt;&lt;em&gt;객체 동결&lt;/em&gt;&lt;/strong&gt;이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉 &lt;strong&gt;&lt;em&gt;동결된 객체는 읽기만 가능하다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-4-불변-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-4-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;5 4 불변 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5-4. 불변 객체&lt;/h3&gt;
&lt;p&gt;중첩 객체는 Object.freeze 메서드로 객체를 동결해도 동결할 수 없다.&lt;/p&gt;
&lt;p&gt;따라서 객체의 중첩객체 까지 동결하기 위해서는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function deepFreeze(target) {
  if(target &amp;amp;&amp;amp; typeof target === &apos;object&apos; &amp;amp;&amp;amp; !Object.isFrozen(target)) {
    Object.freeze(target)
    Object.keys(target).forEach(key =&gt; deepFrreze(target[key]))
  }
  return target;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[15. let, const 키워드와 블록 레벨 스코프]]></title><description><![CDATA[1. var 키워드의 문제점 변수 중복 선언 허용 함수 레벨 스코프 : var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var…]]></description><link>https://github.com/sangzun-han/자바스크립트/15.let,const키워드와 블록레벨 스코프/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/15.let,const키워드와 블록레벨 스코프/</guid><pubDate>Tue, 30 Nov 2021 11:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-var-키워드의-문제점&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-var-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90&quot; aria-label=&quot;1 var 키워드의 문제점 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. var 키워드의 문제점&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;변수 중복 선언 허용&lt;/li&gt;
&lt;li&gt;함수 레벨 스코프 : var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x = 10;

if (true) {
  var x = 1;
}
console.log(x) // 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;변수 호이스팅 : 변수 선언문 이전에 변수를 참조하는것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;2-let-키워드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-let-%ED%82%A4%EC%9B%8C%EB%93%9C&quot; aria-label=&quot;2 let 키워드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. let 키워드&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;변수 중복 선언 금지&lt;/li&gt;
&lt;li&gt;블록 레벨 스코프&lt;/li&gt;
&lt;li&gt;변수 호이스팅 : let키워드로 선언한 변수는 &lt;strong&gt;&lt;em&gt;선언단계와 초기화단계가 분리되어 진행된다.&lt;/em&gt;&lt;/strong&gt; 만약 초기화 되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. 스코프의 시작지점부터 변수를 참조할 수 없는 구간을 &lt;strong&gt;&lt;em&gt;일시적 사각지대(Temporal Dead Zone) TDZ 라고 부른다.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-전역객체와-let&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%A0%84%EC%97%AD%EA%B0%9D%EC%B2%B4%EC%99%80-let&quot; aria-label=&quot;3 전역객체와 let permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 전역객체와 let&lt;/h1&gt;
&lt;p&gt;let 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니다.&lt;/p&gt;
&lt;h1 id=&quot;4-const-키워드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-const-%ED%82%A4%EC%9B%8C%EB%93%9C&quot; aria-label=&quot;4 const 키워드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. const 키워드&lt;/h1&gt;
&lt;p&gt;const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하는것은 아니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야한다.&lt;/li&gt;
&lt;li&gt;const 키워드로 선언한 변수는 재할당이 금지된다.&lt;/li&gt;
&lt;li&gt;const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다. —&gt; 원시값은 변경 불가능한 값이며 const는 재할당이 금지되어 있다. 따라서 const를 상수를 표현하는데 사용하기도 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;4-1-const-키워드와-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-1-const-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%99%80-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;4 1 const 키워드와 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-1. const 키워드와 객체&lt;/h3&gt;
&lt;p&gt;const 키워드로 선언된 변수에 객체를 할당한 경우에 값을 변경 할 수 있따.객체는 재할당없이도 직접 변경이 가능하기 때문이다. 즉 const 키워드는 재할당을 금지할뿐 &lt;strong&gt;&lt;em&gt;불변&lt;/em&gt;&lt;/strong&gt;은 아니다.&lt;/p&gt;
&lt;h1 id=&quot;5-var-vs-let-vs-const&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-var-vs-let-vs-const&quot; aria-label=&quot;5 var vs let vs const permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. var vs let vs const&lt;/h1&gt;
&lt;p&gt;변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는것이 좋다. const 키워드를 사용하면 의도치 않은 재할당을 방지하기 때문에 좀더 안전하다.&lt;/p&gt;
&lt;p&gt;변수를 선언하는 시점에는 재할딩이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당하는 경우가 드물다. 따라서 변수를 선언할 때는 일단 const 키워드를 사용하고 재할당이 필요하다면 let을 사용한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[14. 전역변수의 문제점]]></title><description><![CDATA[1. 변수의 생명주기 1-1. 지역변수의 생명주기 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 즉 변수는 생명주기(Life Cycle…]]></description><link>https://github.com/sangzun-han/자바스크립트/14.전역변수의 문제점/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/14.전역변수의 문제점/</guid><pubDate>Tue, 30 Nov 2021 08:30:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-변수의-생명주기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0&quot; aria-label=&quot;1 변수의 생명주기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 변수의 생명주기&lt;/h1&gt;
&lt;h3 id=&quot;1-1-지역변수의-생명주기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-1-%EC%A7%80%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0&quot; aria-label=&quot;1 1 지역변수의 생명주기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-1. 지역변수의 생명주기&lt;/h3&gt;
&lt;p&gt;변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 즉 변수는 생명주기(Life Cycle)가 있다. 변수에 생명주기가 없다면 한번 선언된 변수는 영원히 메모리 공간을 점유하게 된다.
&lt;strong&gt;&lt;em&gt;지역변수의 생명주기는 함수의 생명주기와 일치한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;변수의 생명주기는 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리풀(memory pool)에 반환되는 시점까지다.&lt;/p&gt;
&lt;p&gt;함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 할당된 메모리 공간은 더 이상 그 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다. 즉 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아 있게 된다. 마찬가지로 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.&lt;/p&gt;
&lt;h3 id=&quot;1-2-전역변수의-생명주기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-2-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0&quot; aria-label=&quot;1 2 전역변수의 생명주기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-2. 전역변수의 생명주기&lt;/h3&gt;
&lt;p&gt;전역코드는 명시적인 호출없이 실행된다. 전역코드에는 반환문을 사용할 수 없으므로 마지막문이 실행되어 더 이상 실행할 문이 없을 때 종료된다.&lt;/p&gt;
&lt;p&gt;var키워드로 선언된 전역변수는 전역 객체의 프로퍼티가 된다. 따라서 var 키워드로 선언된 전역변수의 생명주기는 전역 객체의 생명주기와 일치한다.&lt;/p&gt;
&lt;h1 id=&quot;2-전역변수의-문제점&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90&quot; aria-label=&quot;2 전역변수의 문제점 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 전역변수의 문제점&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;암묵적 결합(implic coupling) : 전역코드는 어디서든 참조하고 할당할 수 있는 변수이다. 변수의 유효범위가 크고 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성이 존재한다.&lt;/li&gt;
&lt;li&gt;긴 생명 주기 : 전역변수는 생명주기가 길다. 따라서 메모리 리소스도 오랜기간 소비한다. 또한 전역변수의 상태를 변경할 수 있는 시간도 길고 기회도
많다.&lt;/li&gt;
&lt;li&gt;스코프 체인 상에서 종점에 존재 : 변수를 검색 할 때 전역 변수가 가장 마지막에 검색되므로 검색속도가 느리다.&lt;/li&gt;
&lt;li&gt;네임스페이스 오염 : 자바스크립트는 파일이 분리되어 있다해도 하나의 전역스코프를 공유한다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역변수나 전역함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;3-전역변수-사용을-억제하는-방법&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%A0%84%EC%97%AD%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%96%B5%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95&quot; aria-label=&quot;3 전역변수 사용을 억제하는 방법 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 전역변수 사용을 억제하는 방법&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;즉시 실행 함수&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;함수정의와 동시에 동시에 호출되는 즉시 실행 함수는 단 한번만 호출된다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역변수가 된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(function() {
  var foo = 10;
}());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;네임스페이스 객체&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역변수처럼 사용하고싶은 변수를 프로퍼티로 추가한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var MYAPP = {};
MYAPP.name = &apos;Haa&apos;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;모듈 패턴&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 전역변수의 억제느 물론 캡슐화 까지 구현할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var Counter = (function() {
  // private
  var num = 0;

  return (
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
}());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;ES6 모듈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ES6모듈을 사용하면 전역변수를 사용할 수 없다. ES6모듈은 파일 자체의 독자적인 모듈스코프를 제공한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script type=&quot;module&quot; src=&quot;test.mjs&quot;&gt;&amp;lt;/script&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[11. 원시 값과 객체의 비교]]></title><description><![CDATA[원시타입의 값은 변경 불가능한 값(immutable value…]]></description><link>https://github.com/sangzun-han/자바스크립트/11.원시 값과 객체의 비교/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/11.원시 값과 객체의 비교/</guid><pubDate>Sun, 21 Nov 2021 01:00:00 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;원시타입의 값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값이다.&lt;/li&gt;
&lt;li&gt;원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.&lt;/li&gt;
&lt;li&gt;원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 &lt;strong&gt;값에 의한 전달(pass by value)&lt;/strong&gt;라고 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 &lt;strong&gt;참조에 의한 전달(pass by reference)&lt;/strong&gt;라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;1-원시-값&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%9B%90%EC%8B%9C-%EA%B0%92&quot; aria-label=&quot;1 원시 값 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 원시 값&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;원시 타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값이다. (read only) 데이터의 신뢰성 보장&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;변경 불가능하다는 것은 변수가 아니라 값에 의한 진술이다.
&lt;img src=&quot;/primitive.jpg&quot; alt=&quot;primitive&quot;&gt;&lt;/p&gt;
&lt;p&gt;변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 만약 원시값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요없이 원시 값 자체를 변경하면 된다.&lt;/p&gt;
&lt;h3 id=&quot;1-1-문자열과-불변성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-1-%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC-%EB%B6%88%EB%B3%80%EC%84%B1&quot; aria-label=&quot;1 1 문자열과 불변성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-1. 문자열과 불변성&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var str = &apos;string&apos;;

str[0] = &apos;S&apos;;
console.log(str); // string&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문자열은 변경 불가능한 값이기 때문에 일부 문자를 변경해도 반영되지 않는다. 그러나 변수에 새로운 문자열을 재할당하는것은 가능하다. 이것은 기존 문자열을 변경하는것이 아니라 재할당 하는것이기 때문이다.&lt;/p&gt;
&lt;h3 id=&quot;1-2-값에-의한-전달&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-2-%EA%B0%92%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC&quot; aria-label=&quot;1 2 값에 의한 전달 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-2. 값에 의한 전달&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var score = 80;

var copy = score;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달된다. 이를 &lt;strong&gt;값에 의한전달&lt;/strong&gt;이라한다.  score 변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값이다. 따라서 &lt;strong&gt;score 변수의 값을 변경햐도 copy 변수의 값에는 어떠한 영향도 주지 않는다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/passbyvalue.jpg&quot; alt=&quot;passbyvalue&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;2 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 객체&lt;/h1&gt;
&lt;p&gt;객체는 프로퍼타의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;2-1-변경-가능한-값&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%ED%95%9C-%EA%B0%92&quot; aria-label=&quot;2 1 변경 가능한 값 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. 변경 가능한 값&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;객체(참조)타입의 값, 객체는 변경 가능한 값(mutable value)&lt;/strong&gt;이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var person = {
  name: &apos;Lee&apos;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수가 기억하는 메모리주소를 통해 메모리 공간에 접근하여 &lt;strong&gt;참조 값(reference value)&lt;/strong&gt;에 접근할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/referencevalue.jpg&quot; alt=&quot;referencevalue&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;원시 값은 변경 불가능한 값이므로 원시 값을 갖는 변수의 값을 변경하려면 재할당 외에는 방법이 없다. 하지만 객체는 변경 가능한 값이다. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. 즉 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;person.name = &apos;Kim&apos;;
person.address = &apos;Incheon&apos;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이때 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변하지 않는다. 객체는 구조적단점에 따른 부작용이 있다. &lt;strong&gt;여러 개의 식별자가 하나의 객체를 공유할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-참조에-의한-전달&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-2-%EC%B0%B8%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%A0%84%EB%8B%AC&quot; aria-label=&quot;2 2 참조에 의한 전달 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-2. 참조에 의한 전달&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var person = {
  name: &apos;Lee&apos;;
}

var copy = person;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달되고 이를 참조에 의한 전달이라고 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/referencevalue2.jpg&quot; alt=&quot;referencevalue2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.&lt;/strong&gt; 다만 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있다. &lt;strong&gt;따라서 자바스크립트에는 값에 의한 전달만 존재한다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[10. 객체 리터럴]]></title><description><![CDATA[1. 객체 자바스크립트는 객체(Object) 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 ‘모든 것’이 객체다 원시값을 제외한 나머지값은 모두 객체다. 객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 key와 value…]]></description><link>https://github.com/sangzun-han/자바스크립트/10.객체 리터럴/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/10.객체 리터럴/</guid><pubDate>Fri, 19 Nov 2021 14:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;1 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 객체&lt;/h1&gt;
&lt;p&gt;자바스크립트는 객체(Object) 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 ‘모든 것’이 객체다 원시값을 제외한 나머지값은 모두 객체다.&lt;/p&gt;
&lt;p&gt;객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 key와 value로 구성된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var person = {
  name : &apos;Lee&apos;,
  age: 20
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;프로퍼티의 값이 함수일 경우. 일반 함수와 구분하기 위해 메서드(method)라고 부른다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var counter = {
  num: 0,
  increase: function() {
    this.num++;
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-객체-리터럴에-의한-객체-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;2 객체 리터럴에 의한 객체 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 객체 리터럴에 의한 객체 생성&lt;/h1&gt;
&lt;p&gt;자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체 리터럴&lt;/li&gt;
&lt;li&gt;Object 생성 함수&lt;/li&gt;
&lt;li&gt;생성자 함수&lt;/li&gt;
&lt;li&gt;Object.create 메서드&lt;/li&gt;
&lt;li&gt;클래스 (ES6)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;객체 리터럴은 중괄호({…})내에 0개 이상의 프로퍼티를 정의한다. &lt;strong&gt;변수에 할당되는 시점에 자바스크립트 엔진은 리터럴을 해석해 객체를 생성한다&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var person = {
  name: &apos;Lee&apos;,
  sayHello: function() {
    console.log(`Hello My name is ${this.name}`);
  }
};

console.log(typeof person) // object
console.log(person) // {name: &quot;Lee&quot;, sayHello: f}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;객체 리터럴의 중괄호는 코드블록을 의미하지 않는다.&lt;/strong&gt; 코드 블록의 중괄호 뒤에는 세미콜론을 붙이지 않는다. 하지만 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체 리터럴의 닫는 중괄호 뒤에는 세미콜론을 붙인다.&lt;/p&gt;
&lt;h1 id=&quot;3-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;3 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 프로퍼티&lt;/h1&gt;
&lt;p&gt;객체는 프로퍼티의 집합이며 프로퍼티는 키(key)와 값(value)으로 구성된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값&lt;/li&gt;
&lt;li&gt;프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var person = {
  firstName: &apos;Ung-Mo&apos;,
  &apos;lst-name&apos;: &apos;Lee&apos;
};

console.log(person) // {firstName: &quot;Ung-Mo&quot;, last-name: &quot;Lee&quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;빈 문자열을 프로퍼티 키로사용해도 에러가 발생하지 않지만 키로서의 의미를 갖지못하므로 권장하지 않는다.&lt;/p&gt;
&lt;p&gt;프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변화를 통해 문자열이 된다.&lt;/p&gt;
&lt;p&gt;var, function같은 예약어를 상용해도 프로퍼티 키로 사용해도 에러가 발생하지 않지만 예상치 못한 에러가 발생할 여지가 있으므로 권장되지 않는다.&lt;/p&gt;
&lt;p&gt;이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다. 이때 에러는 발생하지 않는다.&lt;/p&gt;
&lt;h1 id=&quot;4-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;4 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 메서드&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var circle = {
  radius: 5,
  
  getDiameter: function() {
    return 2 * this.raduis;
  }
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;메서드 내부에서 사용한 this 키워드는 객체 자신을 가리키는 참조변수다.&lt;/p&gt;
&lt;h1 id=&quot;5-프로퍼티-접근&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A0%91%EA%B7%BC&quot; aria-label=&quot;5 프로퍼티 접근 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 프로퍼티 접근&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;마침표 프로퍼티 접근 연산자(.)를 사용하는 마침표 프로퍼티(dot notation)&lt;/li&gt;
&lt;li&gt;대괄호 프로퍼티 접근 연산자([…])를 사용하는 마침표 프로퍼티(bracket notation)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var person = {
  name: &apos;Lee&apos;
};

console.log(person.name); // dot notation
console.log(person[&apos;name&apos;]); // bracket notation&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다. 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이면 반드시 대괄호표기법을 사용해야한다.&lt;/p&gt;
&lt;h1 id=&quot;6-프로퍼티-동적-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%8F%99%EC%A0%81-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;6 프로퍼티 동적 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 프로퍼티 동적 생성&lt;/h1&gt;
&lt;p&gt;존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.&lt;/p&gt;
&lt;h1 id=&quot;7-프로퍼티-삭제&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%82%AD%EC%A0%9C&quot; aria-label=&quot;7 프로퍼티 삭제 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 프로퍼티 삭제&lt;/h1&gt;
&lt;p&gt;delete 연산자는 객체의 프로퍼티를 삭제한다. 이때 delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다.&lt;/p&gt;
&lt;h1 id=&quot;8-객체-리터럴의-확장기능&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4%EC%9D%98-%ED%99%95%EC%9E%A5%EA%B8%B0%EB%8A%A5&quot; aria-label=&quot;8 객체 리터럴의 확장기능 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. 객체 리터럴의 확장기능&lt;/h1&gt;
&lt;p&gt;ES6에서 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.&lt;/p&gt;
&lt;p&gt;ES6에서는 프로퍼티 값으로 변수를 사용하는 경우 변수이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있따.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let x = 1, y = 2;

const obj = { x, y}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 도 있다. 단 프로퍼티 키로 사용할 표현식을 대괄호([…])로 묶어야 한다.&lt;/p&gt;
&lt;p&gt;ES6에서는 메서드를 정의할 때 function키워드를 생략한 축약 표현을 사용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const obj = {
  name: &apos;Lee&apos;,

  sayHi() {
    console.log(&apos;Hi&apos; + this.name);
  }
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[09. 타입변환과 단축 평가]]></title><description><![CDATA[1. 타입변환이란 자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입변환(explict coercion) 또는 타입 캐스팅(type…]]></description><link>https://github.com/sangzun-han/자바스크립트/09.타입변환과 단축 평가/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/09.타입변환과 단축 평가/</guid><pubDate>Thu, 18 Nov 2021 08:30:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-타입변환이란&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98%EC%9D%B4%EB%9E%80&quot; aria-label=&quot;1 타입변환이란 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 타입변환이란&lt;/h1&gt;
&lt;p&gt;자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 &lt;strong&gt;명시적 타입변환(explict coercion) 또는 타입 캐스팅(type casting)&lt;/strong&gt;이라 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x = 10;

var str = x.toString();
console.log(typeof str, str) // 변수x의 값이 변경된것은 아니다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;명시적 타입 변환이나 암묵적 타입 변환이 기존 원시값을 직접 변경하는 것은 아니다. &lt;strong&gt;원시 값은 변경 불가능한 값이므로 변경할 수 없다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x= 10;
var str = x + &apos;&apos;;
console.log(typeof str, str); // string 10&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자바스크립트 엔진은 x + ’ ‘을 평가하기 위해 x 변수의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’+ ’ ‘을 평가한다. 이때
‘10’은 x변수에 재할당되지 않는다.&lt;/p&gt;
&lt;p&gt;즉 암묵적 타입변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다.&lt;/p&gt;
&lt;h1 id=&quot;2-암묵적-타입-변환&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%95%94%EB%AC%B5%EC%A0%81-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98&quot; aria-label=&quot;2 암묵적 타입 변환 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 암묵적 타입 변환&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&apos;10&apos; + 2 // &apos;102&apos;
5 * &apos;10 // 50

!0 // true
if(1){}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다.&lt;/p&gt;
&lt;p&gt;자바스크립트 엔진은 boolean 타입이 아닌 값을 Truthy값 또는 Falsy값으로 구분한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Falsy로 평가되는 값
- false
- undefined
- null
- 0, -0
- NaN
- &apos;&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-명시적-타입-변환&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EB%AA%85%EC%8B%9C%EC%A0%81-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98&quot; aria-label=&quot;3 명시적 타입 변환 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 명시적 타입 변환&lt;/h1&gt;
&lt;p&gt;개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다. 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법과 빌트인 메서드를 사용하는 방법, 그리고 암묵적 타입 변환을 이용하는 방법이 있다.&lt;/p&gt;
&lt;h3 id=&quot;표준-빌트인-생성자-함수와-빌트인-메서드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%91%9C%EC%A4%80-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EB%A9%94%EC%84%9C%EB%93%9C&quot; aria-label=&quot;표준 빌트인 생성자 함수와 빌트인 메서드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;표준 빌트인 생성자 함수와 빌트인 메서드&lt;/h3&gt;
&lt;p&gt;표준 빌트인 생성저 함수와 표준 빌트인 메서드는 자바스크립트에서 기본 제공하는 함수다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new 연산자와 함께 호출한다. 표준 빌트인 메서드는 자바스크립틍서 기본 제공하는 빌트인 객체의 메서드다.&lt;/p&gt;
&lt;h3 id=&quot;3-1-문자열-타입으로-변환&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-1-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98&quot; aria-label=&quot;3 1 문자열 타입으로 변환 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-1. 문자열 타입으로 변환&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;String 생성자 함수를 new 연산자 없이 호출하는 방법&lt;/li&gt;
&lt;li&gt;Object.prototypes.toString메서드를 사용하는 방법&lt;/li&gt;
&lt;li&gt;문자열 연결 연산자를 이용하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;3-2-숫자-타입으로-변환&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-2-%EC%88%AB%EC%9E%90-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98&quot; aria-label=&quot;3 2 숫자 타입으로 변환 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-2. 숫자 타입으로 변환&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Number 생성자 함수를 new 연산자 없이 호출하는 방법&lt;/li&gt;
&lt;li&gt;parseInt parseFloat 함수를 사용하는 방법(문자열만 숫자타입으로 변환 가능)&lt;/li&gt;
&lt;li&gt;+단항 산술 연산자를 이용하는 방법&lt;/li&gt;
&lt;li&gt;*산술 연산자를 이용하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;3-3-boolean-타입으로-변환&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-3-boolean-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98&quot; aria-label=&quot;3 3 boolean 타입으로 변환 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-3. boolean 타입으로 변환&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Boolean 생성자 함수를 new 연산자 없이 호출하는 방법&lt;/li&gt;
&lt;li&gt;! 부정 논리 연산자를 두번 사용하는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;4-단축-평가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80&quot; aria-label=&quot;4 단축 평가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 단축 평가&lt;/h1&gt;
&lt;p&gt;논리합 또는 논리곱 연산자 표현식의 평가값은 boolean값이 아닐 수 도 있다. 논리합 또는 논리곱 연산자 표현식은 언제나 2개의 피연산자중 어느 한쪽으로 평가된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&apos;Cat&apos; &amp;amp;&amp;amp; &apos;Dog&apos; // &apos;Dog&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;논리곱 연산자는 두 개의 피연산자 모두 true로 평가될때 true를 반환한다.
논리곱 연산자는 두번째 피연산자가 논리곱 연산자의 평가 결과를 반환한다.
논리합 연산자도 논리곱 연산자와 동일하게 작용한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이처럼 논리연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는것을 단축평가(short-circuit evaluation)이라고 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;단축평가를 사용하면 if문을 대체할 수 있다.&lt;/p&gt;
&lt;p&gt;어떤 조건이 Truthy일 때 무언가를 해야한다면 논리곱을 조건이 Falsy일 때 무언가를 해야한다면 논리합을 이용할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var done = true;
var message = &apos;&apos;;

if (done) message =&apos;완료&apos;;

message = done &amp;amp;&amp;amp; &apos;완료&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;객체를-가리키기를-기대하는-변수가-null-또는-undefined가-아닌지-확인하기-프로퍼티를-참조할때&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B0%80%EB%A6%AC%ED%82%A4%EA%B8%B0%EB%A5%BC-%EA%B8%B0%EB%8C%80%ED%95%98%EB%8A%94-%EB%B3%80%EC%88%98%EA%B0%80-null-%EB%98%90%EB%8A%94-undefined%EA%B0%80-%EC%95%84%EB%8B%8C%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%A0%EB%95%8C&quot; aria-label=&quot;객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하기 프로퍼티를 참조할때 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하기 프로퍼티를 참조할때&lt;/h3&gt;
&lt;p&gt;객체는 키(key)와 값(value)으로 구성된 프로퍼티의 집합이다. 만약 객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null 또는 undefined인 경우 객체의 프로퍼티를 찾모하면 TypeError가 발생한다.&lt;/p&gt;
&lt;p&gt;이때 단축평가를 사용하면 에러가 발생하지 않는다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var elem = null;

var value = elem &amp;amp;&amp;amp; elem.value // null&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;함수-매개변수에-기본값을-설정할-때&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%A8%EC%88%98-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%97%90-%EA%B8%B0%EB%B3%B8%EA%B0%92%EC%9D%84-%EC%84%A4%EC%A0%95%ED%95%A0-%EB%95%8C&quot; aria-label=&quot;함수 매개변수에 기본값을 설정할 때 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;함수 매개변수에 기본값을 설정할 때&lt;/h2&gt;
&lt;p&gt;함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다. 이 때 단축평가를 사용해 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function getStringLength(str) {
  str = str || &apos;&apos;;
  return str.length;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;4-1-옵셔널-체이닝-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-1-%EC%98%B5%EC%85%94%EB%84%90-%EC%B2%B4%EC%9D%B4%EB%8B%9D-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;4 1 옵셔널 체이닝 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4-1. 옵셔널 체이닝 연산자&lt;/h3&gt;
&lt;p&gt;ES11에서 도입된 optional chaning 연산자 ?.는 좌항의 피연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티를 참조한다.&lt;/p&gt;
&lt;p&gt;optional chaing 연산자는 좌항 피연산자가 false로 평가되는 Falsy값이라도 null 또는 undefined가 아니면 우항의 프로퍼티를 참조한다.&lt;/p&gt;
&lt;h3 id=&quot;42-null-병합-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#42-null-%EB%B3%91%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;42 null 병합 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4.2 null 병합 연산자&lt;/h3&gt;
&lt;p&gt;ES11에서 도입된 &lt;strong&gt;null 병합(nullish coalescing)&lt;/strong&gt; 연산자 ?? 는 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고 그렇지 않으면 좌항의 피연산자를 반환한다. &lt;strong&gt;변수에 기본값을 설정할 때 유용하다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var foo = null ?? &apos;default string&apos;;
console.log(foo) // default string&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;좌항의 피연산자가 false로 평가되는 Falsy값이라도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다.&lt;/p&gt;
&lt;p&gt;optional chaing, null coalescing 연산자가 도입되기 전에는 논리연산자 &amp;#x26;&amp;#x26;와 ||을 사용하여 변수가 null 또는 undefined인지 확인했다.&lt;/p&gt;
&lt;p&gt;||를 사용한 단축평가의 경우 0이나 ”도 유효한 값이라면 예기치 않은 동작이 발생할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var elem = null;
var value = elem &amp;amp;&amp;amp; elem.value;
console.log(value) // null&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var foo = &apos;&apos; || &apos;defalut string&apos;;
console.log(foo) // default string&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[08. 제어문]]></title><description><![CDATA[1. 블록문 블록문(block statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 2. 조건문 조건문(conditional statement…]]></description><link>https://github.com/sangzun-han/자바스크립트/08.제어문/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/08.제어문/</guid><pubDate>Sat, 13 Nov 2021 14:30:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-블록문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B8%94%EB%A1%9D%EB%AC%B8&quot; aria-label=&quot;1 블록문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 블록문&lt;/h1&gt;
&lt;p&gt;블록문(block statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;{
  var foo = 10;
}

var x = 1;
if (x &amp;lt; 10){
  x++;
}

function sum(a,b) {
  return a + b ;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-조건문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%A1%B0%EA%B1%B4%EB%AC%B8&quot; aria-label=&quot;2 조건문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 조건문&lt;/h1&gt;
&lt;p&gt;조건문(conditional statement)는 주어진 조건식의 평가결과에 따라 코드 블록의 실행을 결정한다. 자바스크립트는 if else문과 switch문으로 두 가지 조건문을 제공한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if (조건식) {

} else if(조건식) {

} else {

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if문의 조건식은 boolean값으로 평가되어야 한다. boolean값이 아닐경우 암묵적으로 boolean값으로 강제 변환되어 실행할 코드 블록을 결정한다.&lt;/p&gt;
&lt;p&gt;대부분의 if else문은 삼항 조건 연산자로 바꿔 쓸수 있다. 조건에 따라 값을 결정하여 변수에 할당하는 경우 if else 보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다. 하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if else문을 사용하는 편이 가독성이 좋다.&lt;/p&gt;
&lt;p&gt;switch문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮긴다. case문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤로 실행할 문들을 위치 시킨다.&lt;/p&gt;
&lt;p&gt;switch문의 표현식과 일치하는 case문이 없다면 실행순서는 default로 옮긴다. default는 선택사항이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;switch (표현식) {
  case 표현식1:
    ~~~~
    break;
  case 표현식2:
    ~~~~
    break;
  default:
    ~~~
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;switch문은 boolean값보다는 문자열이나 숫자값인 경우가 많다.&lt;/p&gt;
&lt;h1 id=&quot;3-반복문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EB%B0%98%EB%B3%B5%EB%AC%B8&quot; aria-label=&quot;3 반복문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 반복문&lt;/h1&gt;
&lt;p&gt;반복문(loop statement)는 조건식의 평가 결과가 참인 경우 코드블록을 실행한다. 그후 조건식을 다시 평가하여 여전히 참인경우 코드 블록을 다시 실행한다. 조건식이 거짓이 될 때 까지 반복한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;자바스크립트는 forEach, for ...in,
for ...of문과 같이 반복문을 대체할 수 있는 기능을 제공한다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for문의 변수 선언문, 조건식, 증감식은 모두 옵셥이므로 반드시 사용할 필요는 없다. 단 어떤 식도 선언하지 않으면 무한루프가 된다.&lt;/p&gt;
&lt;p&gt;while문은 주로 반복횟수가 불명확할때 사용한다. 조건식의 결과가 항상 참이면 무한루프가 된다. 무한루프를 탈출하기 위해서는 if문으로 탈출조건을 만들고 break문으로 코드 블록을 탈출한다.&lt;/p&gt;
&lt;p&gt;do…while문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 즉 코드블록은 무조건 한번이상 실행된다.&lt;/p&gt;
&lt;h1 id=&quot;4-break문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-break%EB%AC%B8&quot; aria-label=&quot;4 break문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. break문&lt;/h1&gt;
&lt;p&gt;break문은 코드 블록을 탈출한다. 레이블문, 반복문 또는 switch문의 코드 블록을 탈출한다. 이 외에 break를 사용하면 문법에러가 발생한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;레이블문 (label statement)이란 식별자가 붙은 문을 말한다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;foo: console.log(&apos;foo&apos;);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;레이불믄은 중첩된 for문 외부로 탈출할때 유용하지만 그 외의 경우에는 권장되지 않는다. 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;outer: for (var i=0; i&amp;lt;3; i++) {
  for (var j=0; j&amp;lt;3 j++) {
    if(i+j === 3) break outer;
    console.log(`inner[${i},${j}`]);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;5-continue문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-continue%EB%AC%B8&quot; aria-label=&quot;5 continue문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. continue문&lt;/h1&gt;
&lt;p&gt;continue문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행흐름을 이동시킨다. 반복문을 탈출하지 않는다.&lt;/p&gt;
&lt;p&gt;if문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한단계 더 깊어지므로 continue문을 사용하는 편이 더 가독성이 좋다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;for (var i=0; i&amp;lt;string.length; i++) {
  if (string[i]!==search) continue;

  count++;
  ~~~
  ~~~
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[07. 연산자]]></title><description><![CDATA[연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산등을 수행하여 하나의 값을 만든다. 이때 연산의 대상을 피연산자(operand…]]></description><link>https://github.com/sangzun-han/자바스크립트/07.연산자/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/07.연산자/</guid><pubDate>Fri, 12 Nov 2021 07:00:00 GMT</pubDate><content:encoded>&lt;p&gt;연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산등을 수행하여 하나의 값을 만든다. 이때 연산의 대상을 피연산자(operand)라고 한다.&lt;/p&gt;
&lt;p&gt;피연산자는 ‘값’이라는 역할을 하며 연산자는 ‘피연산자를 연산하여 새로운 값을 만든다.’&lt;/p&gt;
&lt;h1 id=&quot;1-산술-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;1 산술 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 산술 연산자&lt;/h1&gt;
&lt;p&gt;산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술연산이 불가능한 경우 &lt;strong&gt;NaN&lt;/strong&gt;을 반환한다.&lt;/p&gt;
&lt;h3 id=&quot;1-1-이항-산술-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-1-%EC%9D%B4%ED%95%AD-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;1 1 이항 산술 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-1. 이항 산술 연산자&lt;/h3&gt;
&lt;p&gt;모든 이항 산술 연산자는 피연산자의 값을 변경하는 &lt;strong&gt;부수효과(side effect)&lt;/strong&gt;가 없다. 즉 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만들어 낸다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;5 + 2; // 7
5 - 2; // 3
5 * 2; // 10
5 / 2; // 2.5
5 % 2; // 1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;1-2-단항-산술-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-2-%EB%8B%A8%ED%95%AD-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;1 2 단항 산술 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-2. 단항 산술 연산자&lt;/h3&gt;
&lt;p&gt;단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
증가/감소(++/—) 연산자는 피연산자의 값을 변경하는 부수효과가 있다.
즉 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다.&lt;/p&gt;
&lt;p&gt;숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피연산자를 숫자 타입으로 반환하여 반환한다. 이 때 피연산자를 변경하는것은 아니고 숫자 타입으로 변환된 값을 생성해서 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x = &apos;1&apos;;
console.log(+x); // 1
console.log(x); // &quot;1&quot;

var x = true;
console.log(+x) // 1
console.log(x) // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;1-3-문자열-연결-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-3-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EA%B2%B0-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;1 3 문자열 연결 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1-3. 문자열 연결 연산자&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&apos;1&apos; + 2; // &apos;12&apos;
1 + &apos;2&apos;; // &apos;12&apos;

1 + true; // 2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 &lt;strong&gt;암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion)&lt;/strong&gt;이라고 한다&lt;/p&gt;
&lt;h1 id=&quot;2-할당-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%ED%95%A0%EB%8B%B9-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;2 할당 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 할당 연산자&lt;/h1&gt;
&lt;p&gt;할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 따라서 부수효과가 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x;
x = 10;
x += 5;
x -= 5

var str = &apos;name is &apos;;
str += &apos;Han&apos;;
console.log(str) // &apos;name is Han&apos;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;일치비교(===)연산자는 좌항과 우항의 피연산자가 &lt;strong&gt;타입도 같고 값도 같은 경우에 true를 반환한다.&lt;/strong&gt; 암묵적 타입 변환을 하지 않고 값을 비교한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;5 === 5; // true
5 === &apos;5&apos;; // false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자바스크립트에서 숫자 0은 양의 0과 음의 0으로 나누어져 있다. 이들을 비교하면 true를 반환한다. 또한 동일한 값인 NaN가 NaN을 비교하면 다른 값이라고 평가한다.&lt;/p&gt;
&lt;p&gt;따라서 Object.is 메서드를 사용하면 정확한 비교 결과를 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;NaN === NaN // false
Object.is(NaN, NaN) // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NaN은 자신과 일치하지 않는 유일한 값이다 NaN을 조사하려면 &lt;strong&gt;isNaN&lt;/strong&gt;함수를 사용해야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;isNaN(NaN) // true
isNaN(10) // false
isNaN(1 + undefined) // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;2-1-대소-관계-비교-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-1-%EB%8C%80%EC%86%8C-%EA%B4%80%EA%B3%84-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;2 1 대소 관계 비교 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2-1. 대소 관계 비교 연산자&lt;/h3&gt;
&lt;p&gt;대소 관계 비교 연산자는 피연산자의 크기를 비교하여 boolean값을 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;5 &gt; 0; // true
5 &gt; 5; // false
5 &gt;= 5; // true
5 &amp;lt;= 5; // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;3-삼항-조건-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%82%BC%ED%95%AD-%EC%A1%B0%EA%B1%B4-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;3 삼항 조건 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 삼항 조건 연산자&lt;/h1&gt;
&lt;p&gt;삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값&lt;/strong&gt;
만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x = 2;
var result = x % 2 ? &apos;홀수&apos; : &apos;짝수&apos;;
// 2 % 2는 0이므로 false로 암묵적 타입 변환된다.

console.log(result) // 짝수&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x = 10;

var result = if(x % 2) {result = &apos;홀수&apos;} else {result = &apos;짝수&apos;}
//SyntaxError&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;4-논리-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;4 논리 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 논리 연산자&lt;/h1&gt;
&lt;p&gt;논리 연산자(logical operator)는 우항과 좌항의 피연산자를 논리 연산 한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;논리 연산자&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;th&gt;부수효과&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;｜｜&lt;/td&gt;
&lt;td&gt;논리합(OR)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;#x26;&amp;#x26;&lt;/td&gt;
&lt;td&gt;논리곱(AND)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;부정(NOT)&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;논리 부정 연산자는 언제나 boolean값을 반환한다. 단 피연산자가 반드시 boolean값일 필요는 없다. 피연산자가 boolean타입이 아니라면 암묵적 타입 변환된다.&lt;/p&gt;
&lt;h1 id=&quot;5-쉼표-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EC%89%BC%ED%91%9C-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;5 쉼표 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 쉼표 연산자&lt;/h1&gt;
&lt;p&gt;쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x,y,z;
x = 1, y = 2, z = 3;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;6-그룹-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%EA%B7%B8%EB%A3%B9-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;6 그룹 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 그룹 연산자&lt;/h1&gt;
&lt;p&gt;소괄호 ()로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 그룹 연산자는 연산자 우선순위가 가장 높다.&lt;/p&gt;
&lt;h1 id=&quot;7-typeof-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-typeof-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;7 typeof 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. typeof 연산자&lt;/h1&gt;
&lt;p&gt;typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 &lt;strong&gt;‘string’, ‘number’, ‘boolean’, ‘undefined’, ‘symbol’, ‘object’, ‘function’&lt;/strong&gt; 중 하나를 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null을 반환하는 경우는 없다. 자바스크립트 첫번째 버전의 버그이지만 기존 코드에 영향을 줄 수 있기 때문에 수정을 하지 않는다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;null 타입인지 확인할때는 일치 연산자(===)을 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;typeof &apos;&apos; // String
typeof 1 // number
typeof NaN // number
typeof true // boolean
typeof undefiend // undefined
typeof Symbol() // symbol
typeof null // object
typeof [] // object
typeof {} // object
typeof new Date() // object
typeof /test/gi // object
typeof function(){} // function

var foo = null;
foo === null // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;8-지수-연산자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-%EC%A7%80%EC%88%98-%EC%97%B0%EC%82%B0%EC%9E%90&quot; aria-label=&quot;8 지수 연산자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. 지수 연산자&lt;/h1&gt;
&lt;p&gt;ES7에서 도입된 지수연산자는 좌항의 피연산자를 밑(base)로 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 계산한다. 지수 연산자 이전에는 Math.pow 메서드를 사용했다.&lt;/p&gt;
&lt;p&gt;음수를 거듭제곱의 밑으로 사용하려면 괄호로 묶어야 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(-5) ** 2;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;9-연산자의-부수효과&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#9-%EC%97%B0%EC%82%B0%EC%9E%90%EC%9D%98-%EB%B6%80%EC%88%98%ED%9A%A8%EA%B3%BC&quot; aria-label=&quot;9 연산자의 부수효과 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. 연산자의 부수효과&lt;/h1&gt;
&lt;p&gt;대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를들어 2*3은 다른 코드에 어떠한 영향도 주지 않고 새로운 값 6을 생성한다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. ex) 할당연산자(=), 증가/감소 연산자(++/—), delete 연산자&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@hanminss/JS-Group-Study-07.%EC%97%B0%EC%82%B0%EC%9E%90&quot;&gt;study width&lt;/p&gt;</content:encoded></item><item><title><![CDATA[06. 데이터타입]]></title><description><![CDATA[데이터타입은 값의 종류를 말한다. 자바스크립트는 7개의 데이터 타입을 제공한다.
7개의 데이터 타입은 원시타입(primitive type)입과 객체타입(object/reference type)으로 분류할 수 있다.…]]></description><link>https://github.com/sangzun-han/자바스크립트/06.데이터 타입/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/06.데이터 타입/</guid><pubDate>Thu, 11 Nov 2021 09:30:00 GMT</pubDate><content:encoded>&lt;p&gt;데이터타입은 값의 종류를 말한다. 자바스크립트는 7개의 데이터 타입을 제공한다.
7개의 데이터 타입은 원시타입(primitive type)입과 객체타입(object/reference type)으로 분류할 수 있다.&lt;/p&gt;
&lt;h1 id=&quot;1-숫자-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%88%AB%EC%9E%90-%ED%83%80%EC%9E%85&quot; aria-label=&quot;1 숫자 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 숫자 타입&lt;/h1&gt;
&lt;p&gt;숫자 타입의 값은 모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 존재하지 않는다.&lt;/p&gt;
&lt;p&gt;정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(1===1.0) // true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(10 / 0) // Infinity
console.log(10 /- 0) // -Infinity
console.log(1 * &apos;String&apos;) // NaN&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-문자열-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%83%80%EC%9E%85&quot; aria-label=&quot;2 문자열 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 문자열 타입&lt;/h1&gt;
&lt;p&gt;문자열 타입은 텍스트 데이터를 나타내는데 사용한다.
문자열은 ”, &quot;&quot;, &lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;으로 텍스트를 감싼다.
다른타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다.&lt;/p&gt;
&lt;h1 id=&quot;3-템플릿-리터럴&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A6%AC%ED%84%B0%EB%9F%B4&quot; aria-label=&quot;3 템플릿 리터럴 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 템플릿 리터럴&lt;/h1&gt;
&lt;p&gt;ES6부터 템플릿 리터럴(template literal)이라고 하는 새로운 문자열 표기법이 도입되었다. 템플릿 리터럴은 멀티라인 문자열(multi-line string), 표현식 삽입(expresiion interpolation), 태그드 템플릿(tagged template)등 편리한 문자열 처리 기니을 제공한다. &lt;code class=&quot;language-text&quot;&gt;&lt;/code&gt;을 사용해 표현한다.&lt;/p&gt;
&lt;h3 id=&quot;3-1-멀티라인-문자열&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-1-%EB%A9%80%ED%8B%B0%EB%9D%BC%EC%9D%B8-%EB%AC%B8%EC%9E%90%EC%97%B4&quot; aria-label=&quot;3 1 멀티라인 문자열 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-1. 멀티라인 문자열&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var template = `Template literal`&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3-2-표현식-삽입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-2-%ED%91%9C%ED%98%84%EC%8B%9D-%EC%82%BD%EC%9E%85&quot; aria-label=&quot;3 2 표현식 삽입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3-2. 표현식 삽입&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var first = &apos;Ung-mo&apos;;
var last = &apos;Lee&apos;;

console.log(`${first} ${last}`)&apos; // Ung-mo Lee&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다. 템플릿 리터럴이 아닌 일반 문자열에서의 표현식 삽입은 문자열로 취급된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(&apos;1 + 2 = ${1 + 2}&apos;) // 1 + 2 = ${1 + 2}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-불리언-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%B6%88%EB%A6%AC%EC%96%B8-%ED%83%80%EC%9E%85&quot; aria-label=&quot;4 불리언 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 불리언 타입&lt;/h1&gt;
&lt;p&gt;불리언 타입의 값은 논리적 참, 거짓을 나타내는 true, false뿐이다.&lt;/p&gt;
&lt;h1 id=&quot;5-undefined-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-undefined-%ED%83%80%EC%9E%85&quot; aria-label=&quot;5 undefined 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. undefined 타입&lt;/h1&gt;
&lt;p&gt;undefined 타입의 값은 undefined가 유일하다. &lt;strong&gt;변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 초기화 되지 않은 변수란것을 알 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;선언declaration과-정의definition&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%A0%EC%96%B8declaration%EA%B3%BC-%EC%A0%95%EC%9D%98definition&quot; aria-label=&quot;선언declaration과 정의definition permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;선언(declaration)과 정의(definition)&lt;/h3&gt;
&lt;p&gt;undefined를 직역하면 ‘정의되지 않은’이다. 자바스크립트의 undefined은 변수에 값을 할당하여 변수의 실체를 명확히 하는것을 말한다.&lt;/p&gt;
&lt;p&gt;다른 프로그래밍 언어에서는 선언과 정의를 엄격하게 구분해서 사용하는 경우가 있지만 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이루어지기 때문에 선언과 정의의 구분이 모호하다.&lt;/p&gt;
&lt;h1 id=&quot;6-null-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-null-%ED%83%80%EC%9E%85&quot; aria-label=&quot;6 null 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. null 타입&lt;/h1&gt;
&lt;p&gt;null타입의 값은 null이 유일하다. &lt;strong&gt;null은 변수에 값이 없다는 것을 의도적으로 명시할때 사용한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다.&lt;/p&gt;
&lt;p&gt;함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다.&lt;/p&gt;
&lt;h1 id=&quot;7-심벌-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%EC%8B%AC%EB%B2%8C-%ED%83%80%EC%9E%85&quot; aria-label=&quot;7 심벌 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 심벌 타입&lt;/h1&gt;
&lt;p&gt;심벌(symbol)은 ES6에서 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.심벌 값은 다른 값과 중복 되지 않는 유일무이한 값이다.&lt;/p&gt;
&lt;p&gt;심벌은 Symbol 함수를 호출해 생성한다. 이때 생성된 심벌 값은 외부에 노출되지 않는다.&lt;/p&gt;
&lt;h1 id=&quot;8-객체-타입&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-%EA%B0%9D%EC%B2%B4-%ED%83%80%EC%9E%85&quot; aria-label=&quot;8 객체 타입 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. 객체 타입&lt;/h1&gt;
&lt;p&gt;숫자, 문자열, 템플릿 리터럴, 불리언, undefined, null, symbol을 제외한 이외의 값들은 모두 객체 타입이다.&lt;/p&gt;
&lt;h1 id=&quot;9-데이터-타입의-필요성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#9-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1&quot; aria-label=&quot;9 데이터 타입의 필요성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. 데이터 타입의 필요성&lt;/h1&gt;
&lt;p&gt;값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야 한다. 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해&lt;/li&gt;
&lt;li&gt;값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해&lt;/li&gt;
&lt;li&gt;메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;10-동적-타이핑&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#10-%EB%8F%99%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91&quot; aria-label=&quot;10 동적 타이핑 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;10. 동적 타이핑&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;char c; // 1바이트
int num; // 4바이트&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;정적 타입 언어는 변수의 타입을 변경할 수 없으며 변수에 선언한 타입에 맞는 값만 할당 할 수 있다.
자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.&lt;/p&gt;
&lt;p&gt;자바스크립트의 변수는선언이 아닌 할당에 의해 타입이 결정(타입 추론(type inference)) 된다.
그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 &lt;strong&gt;동적 타이핑(dynamic typing)이라고 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;동적-타입-언어&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EC%A0%81-%ED%83%80%EC%9E%85-%EC%96%B8%EC%96%B4&quot; aria-label=&quot;동적 타입 언어 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동적 타입 언어&lt;/h3&gt;
&lt;p&gt;동적 타입 언어는 구조적인 단점이 있다. 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있고
변수의 타입이 고정되어 있지 않고 값의 변경에 의해 타입도 언제든지 변경될 수 있다.
결국 &lt;strong&gt;동적 타입언어는 유연성(flexibility)은 높지만 신뢰성(reliability)은 떨어진다.&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[05. 표현식과 문]]></title><description><![CDATA[1. 값 값(value)은 식(expression)이 평가(evaluate)되어 생성된 결과를 말한다. 2. 리터럴 리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation…]]></description><link>https://github.com/sangzun-han/자바스크립트/05.표현식과 문/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/05.표현식과 문/</guid><pubDate>Wed, 10 Nov 2021 14:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-값&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EA%B0%92&quot; aria-label=&quot;1 값 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 값&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;값(value)은 식(expression)이 평가(evaluate)되어 생성된 결과를 말한다.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;2-리터럴&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EB%A6%AC%ED%84%B0%EB%9F%B4&quot; aria-label=&quot;2 리터럴 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 리터럴&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)을 말한다.&lt;/strong&gt;
자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다. 즉 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;리터럴&lt;/th&gt;
&lt;th&gt;예시&lt;/th&gt;
&lt;th&gt;비고&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;정수 리터럴&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;부동소수점 리터럴&lt;/td&gt;
&lt;td&gt;10.5&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2진수 리터럴&lt;/td&gt;
&lt;td&gt;0b010001&lt;/td&gt;
&lt;td&gt;0b로 시작&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8진수 리터럴&lt;/td&gt;
&lt;td&gt;0o101&lt;/td&gt;
&lt;td&gt;ES6에서 도입 0o로 시작&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16진수 리터럴&lt;/td&gt;
&lt;td&gt;0x41&lt;/td&gt;
&lt;td&gt;ES6에서 도입 0x로 시작&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;문자열 리터럴&lt;/td&gt;
&lt;td&gt;‘Hello’&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;불리언 리터럴&lt;/td&gt;
&lt;td&gt;true false&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null 리터럴&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;undefined 리터럴&lt;/td&gt;
&lt;td&gt;undefined&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;객체 리터럴&lt;/td&gt;
&lt;td&gt;{name: ‘Lee’, address: ‘Seoul’}&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;배열 리터럴&lt;/td&gt;
&lt;td&gt;[1,2,3]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;함수 리터럴&lt;/td&gt;
&lt;td&gt;function() {}&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;정규표현식 리터럴&lt;/td&gt;
&lt;td&gt;/[A-Z]+/g&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;3-표현식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%ED%91%9C%ED%98%84%EC%8B%9D&quot; aria-label=&quot;3 표현식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 표현식&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조한다.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var score = 100;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;100은 리터럴이다. 리터럴 100은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로 리터럴은 그자체로 표현식이다.&lt;/p&gt;
&lt;p&gt;표현식은 값으로 평가된다. 이때 표현식과 표현식이 평가된 값은 동등한 관계이다. 즉 동치(equivalent)다. 예를 들어 1+2 = 3에서 1 + 2는 3과 같다고 할 수 있다.
자바스크립트의 표현식 1 + 2는 평가되어 값 3을 생성하므로 표현식 1 + 2와 값 3은 동치다.&lt;/p&gt;
&lt;h1 id=&quot;4-문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%AC%B8&quot; aria-label=&quot;4 문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 문&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.&lt;/strong&gt; 문의 집합으로 이루어진것이 프로그램이다.&lt;/p&gt;
&lt;p&gt;문은 여러 토큰으로 구성된다. &lt;strong&gt;토큰(token)이란 문법적인 의미를 가지며 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;문은 명령문이라고도 부른다. 선언문, 할당문, 조건문, 반복문등으로 구분할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x; // 변수 선언문

x = 5; // 할당문

function foo() {} // 함수 선언문

if (x &gt; 1) {} // 조건문

for (){} //반복문&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;5-세미콜론&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EC%84%B8%EB%AF%B8%EC%BD%9C%EB%A1%A0&quot; aria-label=&quot;5 세미콜론 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 세미콜론&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;세미콜론(;)은 문의 종료를 나타낸다.&lt;/li&gt;
&lt;li&gt;세미콜론은 생략 가능하다. why? 세미콜론 자동 삽입 기능(ASI = automatic semicolon insertion)이 암묵적으로 수행되기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;하지만 ASI가 제대로 동작하지 않는 경우가 있다.
&lt;img src=&quot;/ASI.png&quot; alt=&quot;ASI&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;6-표현식인-문과-표현식이-아닌-문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%B8-%EB%AC%B8%EA%B3%BC-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%B4-%EC%95%84%EB%8B%8C-%EB%AC%B8&quot; aria-label=&quot;6 표현식인 문과 표현식이 아닌 문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 표현식인 문과 표현식이 아닌 문&lt;/h1&gt;
&lt;p&gt;표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당해 보는 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var x; // 변수 선언문은 표현식이 아닌 문이다
x = 100; // 할당문은 그 자체로 표현식이면서 완전한 문이다.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 표현식이 아닌문은 값처럼 사용할 수 없다.
var foo = var x; // SyntaxError&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var foo = x = 100;
console.log(foo) // 100&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;완료값&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%99%84%EB%A3%8C%EA%B0%92&quot; aria-label=&quot;완료값 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;완료값&lt;/h3&gt;
&lt;p&gt;크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력한다. 이를 &lt;strong&gt;완료값&lt;/strong&gt;이라고 한다. 완료값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/completevalue.png&quot; alt=&quot;완료값&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[04. 변수]]></title><description><![CDATA[1. 변수 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간단히 말하자면 변수는 값의 위치를 가리키는 상징적인 이름이다. 10+20은 연산을 통해 새로운 값 3…]]></description><link>https://github.com/sangzun-han/자바스크립트/04.변수/</link><guid isPermaLink="false">https://github.com/sangzun-han/자바스크립트/04.변수/</guid><pubDate>Tue, 09 Nov 2021 13:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;1-변수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B3%80%EC%88%98&quot; aria-label=&quot;1 변수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 변수&lt;/h1&gt;
&lt;p&gt;변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간단히 말하자면 변수는 값의 위치를 가리키는 상징적인 이름이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var result = 10 + 20;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10+20은 연산을 통해 새로운 값 30을 생성한다. 연산을 통해 생성된 값 30은 메모리 공간에 저장된다. 이때 메모리에 저장된 값 30을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인것이 변수이다.&lt;/p&gt;
&lt;p&gt;변수에 값을 저장하는 것을 &lt;strong&gt;할당(assignment)&lt;/strong&gt;이라 하고 변수에 저장된 값을 읽어 들이는 것을 &lt;strong&gt;참조(reference)&lt;/strong&gt;라고 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var result = 10 + 20;
console.log(result) // 30&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;2-식별자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%8B%9D%EB%B3%84%EC%9E%90&quot; aria-label=&quot;2 식별자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 식별자&lt;/h1&gt;
&lt;p&gt;식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. &lt;strong&gt;식별자는 값이 아니라 메모리 주소를 기억하고 있다.&lt;/strong&gt;
식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/identifier.jpg&quot; alt=&quot;식별자&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;3변수-선언&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8&quot; aria-label=&quot;3변수 선언 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3.변수 선언&lt;/h1&gt;
&lt;p&gt;변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;블록 레벨 스코프(block-level scope)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;모든 코드 블록(함수, if문, for문, while문, try/catch문 등)내에서
선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다.
즉 코드 블록 내부에서 선언한 변수는 지역변수이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;함수 레벨 스코프(function-level scope)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;함수내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다.
즉 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는
모두 전역변수이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;var 키워드&lt;/strong&gt;는 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다.
이로 인해 의도치 않게 전역 변수가 선언되어 오류가 발생 할 수 있다.&lt;/p&gt;
&lt;p&gt;var 키워드는 선언 단계와 초기화 단계가 동시에 진행된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var score; // undefined&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;4-변수-선언-실행-시점과-호이스팅&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C%EC%A0%90%EA%B3%BC-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85&quot; aria-label=&quot;4 변수 선언 실행 시점과 호이스팅 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 변수 선언 실행 시점과 호이스팅&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(score); // undefined
var score; // 변수 선언&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;참조에러(ReferenceError)가 발생할 것 같지만 undefined가 출력된다.
그 이유는 &lt;strong&gt;변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이처럼 &lt;strong&gt;변수 선언문이 코드의 선두로 끌어 올려진것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)&lt;/strong&gt;이라 한다.&lt;/p&gt;
&lt;h1 id=&quot;5-값의-할당&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EA%B0%92%EC%9D%98-%ED%95%A0%EB%8B%B9&quot; aria-label=&quot;5 값의 할당 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 값의 할당&lt;/h1&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var score; // 변수 선언
score = 80; // 값의 할당
var score = 80;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 실행되지만 할당은 런타임에 실행된다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;console.log(score); // undefined
var score = 80;
console.log(score) // 80&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/reallocation.jpg&quot; alt=&quot;할당&quot;&gt;&lt;/p&gt;
&lt;p&gt;변수에 값을 할당할 때에는 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 새로 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당값을 저장한다.&lt;/p&gt;
&lt;h1 id=&quot;6-값의-재할당&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-%EA%B0%92%EC%9D%98-%EC%9E%AC%ED%95%A0%EB%8B%B9&quot; aria-label=&quot;6 값의 재할당 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. 값의 재할당&lt;/h1&gt;
&lt;p&gt;var 키워드로 선언한 변수는 값을 재할당 할 수 있다. 만약 값을 재 할당 할 수 없다면 변수가 아니라 &lt;strong&gt;상수(constant)라&lt;/strong&gt; 한다&lt;/p&gt;
&lt;h3 id=&quot;언매니지드-언어unmanaged-language-vs-매니지드-언어managed-language&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%96%B8%EB%A7%A4%EB%8B%88%EC%A7%80%EB%93%9C-%EC%96%B8%EC%96%B4unmanaged-language-vs-%EB%A7%A4%EB%8B%88%EC%A7%80%EB%93%9C-%EC%96%B8%EC%96%B4managed-language&quot; aria-label=&quot;언매니지드 언어unmanaged language vs 매니지드 언어managed language permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;언매니지드 언어(unmanaged language) vs 매니지드 언어(managed language)&lt;/h3&gt;
&lt;p&gt;프로그래밍 언어는 메모리 관리 방식에 따라 언매니지드 언어와 매니지드 언어로 분류할 수 있다.
C언어 같은 언매니지드 언어는 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free()같은 저수준 메모리 제어 기능을 제공한다.
개발자의 역량에 따라 최적의 성능을 확보 할 수 있지만 그 반대의 경우 치명적 오류를 생산할 수 도 있다.&lt;/p&gt;
&lt;p&gt;자바스크립트 같은 매니지드 언어는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다.
더 이상 사용하지 않는 메모리의 해제는 &lt;strong&gt;가비지 콜렉터&lt;/strong&gt;가 수행하며, 어느정도 일정한 생산성을 확보할 수 있다는 장점이 있지만
성능 면에서는 어느정도 손실을 감수해야 한다.&lt;/p&gt;
&lt;h1 id=&quot;7-식별자-네이밍-규칙&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99&quot; aria-label=&quot;7 식별자 네이밍 규칙 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 식별자 네이밍 규칙&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;예약어는 식별자로 사용 X&lt;/li&gt;
&lt;li&gt;특수문자를 제외한 문자, 숫자 ,_ , $ 포함가능&lt;/li&gt;
&lt;li&gt;숫자로 시작하는것은 허용 X&lt;/li&gt;
&lt;li&gt;자바스크립트은 대소문자를 구별한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var firstName // camelCase
var first_name // snake case
var FirstName // Pascal Case
var strFirstName // Hungarian Case&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item></channel></rss>