{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/자바스크립트/18.함수와 일급 객체/",
    "result": {"data":{"cur":{"id":"2e7572ae-ba24-5a10-97c8-98c0a3c2b9e6","html":"<h1 id=\"1-일급-객체\" style=\"position:relative;\"><a href=\"#1-%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4\" aria-label=\"1 일급 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 일급 객체</h1>\n<p>아래의 조건을 만족하는 객체를 일급 객체라 한다.</p>\n<ul>\n<li>무명의 리터럴로 생성할 수 있다.</li>\n<li>변수나 자료구조에 저장할 수 있다.</li>\n<li>함수의 매개변수에 전달할 수 있다.</li>\n<li>함수의 반환값으로 사용할 수 있다.</li>\n</ul>\n<p>자바스크립트에서 함수는 객체다. 객체이므로 값과 동일하게 취급할 수 있다. 따라서 매개변수에 함수를 전달할 수 있고 함수의 반환값으로도 사용할 수 있다.</p>\n<p>함수와 일반객체와의 차이는 일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있다. 또한 함수는 프로퍼티를 가지고 있다.</p>\n<h1 id=\"2-함수-객체의-프로퍼티\" style=\"position:relative;\"><a href=\"#2-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 함수 객체의 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 함수 객체의 프로퍼티</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function square(number) {\n  return number * number;\n}\n\nconsole.dir(square) // ƒ square(number)\n\nconsole.log(Object.getOwnPropertyDescriptors(square))\n/*\n  {length: {…}, name: {…}, arguments: {…}, caller: {…}, prototype: {…}}\n*/</code></pre></div>\n<p>arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 고유 프로퍼티다.</p>\n<h3 id=\"2-1-arguments-프로퍼티\" style=\"position:relative;\"><a href=\"#2-1-arguments-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 1 arguments 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. arguments 프로퍼티</h3>\n<p>arguments 프로퍼티 값은 arguments 객체다. arguments 객체는 함수 호출시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다.</p>\n<p>선언된 매개변수의 개수보다 인수를 적게 전달했을경우 매개변수는 undefined로 초기화된 상태를 유지하며 매개변수의 개수보다 많은 인수를 전달한 경우 초과된 인수는 무시한다 이 때 모든 인수는 arguments 객체의 프로퍼티로 보관된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function multiply(x,y) {\n  console.log(arguments);\n  return x != y;\n}\n\nconsole.log(multiply(1,2,3))</code></pre></div>\n<h3 id=\"2-2-caller-프로퍼티\" style=\"position:relative;\"><a href=\"#2-2-caller-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 2 caller 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. caller 프로퍼티</h3>\n<p>caller 프로퍼티는 ECMAScript 사양에 포함되지 않는 비표준 프로퍼티다.\n함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 기리킨다.</p>\n<h3 id=\"2-3-lenght-프로퍼티\" style=\"position:relative;\"><a href=\"#2-3-lenght-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 3 lenght 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. lenght 프로퍼티</h3>\n<p>함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.</p>\n<p>arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티 값은 다를 수 있다. arguments 객체의 length 프로퍼티는 인자의 개수를 가리키고 함수 객체의 length 프로퍼티는 매개변수의 개수를 기리킨다.</p>\n<h3 id=\"2-4-name-프로퍼티\" style=\"position:relative;\"><a href=\"#2-4-name-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 4 name 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4 name 프로퍼티</h3>\n<p>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. ES6에서 정식표준</p>\n<h3 id=\"2-5-proto-접근자-프로퍼티\" style=\"position:relative;\"><a href=\"#2-5-proto-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 5 proto 접근자 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-5. <strong><strong>proto</strong></strong> 접근자 프로퍼티</h3>\n<p>모든객체는 [[Prototype]]이라는 내부슬롯을 가진다. ____proto____는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체이 접근하기 위해 사용하는 접근자 프로퍼티다.</p>\n<h3 id=\"2-6-prototype-프로퍼티\" style=\"position:relative;\"><a href=\"#2-6-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"2 6 prototype 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-6 prototype 프로퍼티</h3>\n<p>prototype 프로퍼티는 생성자 함수로 호출할 수 있는 객체, 즉 constructor만이 소유하는 프로퍼티다. 함수 객체의 경우는 constructor (생성자 함수)로 호출할 수 있기때문에, prototype property를 가진다고 한다.</p>","excerpt":"1. 일급 객체 아래의 조건을 만족하는 객체를 일급 객체라 한다. 무명의 리터럴로 생성할 수 있다. 변수나 자료구조에 저장할 수 있다. 함수의 매개변수에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 자바스크립트에서 함수는 객체다. 객체이므로 값과 동일하게 취급할 수 있다. 따라서 매개변수에 함수를 전달할 수 있고 함수의 반환값으로도 사용할 수 있다. 함수와 일반객체와의 차이는 일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있다. 또한 함수는 프로퍼티를 가지고 있다. 2. 함수 객체의 프로퍼티 arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 고유 프로퍼티다. 2-1. arguments 프로퍼티 arguments 프로퍼티 값은 arguments 객체다. arguments 객체는 함수 호출시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다. 선언된 매개변수의 개수…","frontmatter":{"date":"December 02, 2021","title":"18. 함수와 일급 객체","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/18.함수와 일급 객체/"}},"next":{"id":"8399a6d9-5f57-5200-a773-688df62d36a5","html":"<h1 id=\"1-내부슬롯과-내부메소드\" style=\"position:relative;\"><a href=\"#1-%EB%82%B4%EB%B6%80%EC%8A%AC%EB%A1%AF%EA%B3%BC-%EB%82%B4%EB%B6%80%EB%A9%94%EC%86%8C%EB%93%9C\" aria-label=\"1 내부슬롯과 내부메소드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 내부슬롯과 내부메소드</h1>\n<p>프로퍼티 어트리뷰트를 이해하기 위해서는 내부 슬롯(internal slot)과 내부 메서드(internal method)의 개념이 필요하다.</p>\n<p>내부슬롯과 내부메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사메서드이다. 이중 대괄호로 감싼 이름들이 내부슬롯과 내부메서드이다.</p>\n<h1 id=\"2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체\" style=\"position:relative;\"><a href=\"#2-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%84%B0-%EA%B0%9D%EC%B2%B4\" aria-label=\"2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1>\n<p><em><strong>자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</strong></em></p>\n<p>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부상태 값이다. 따라서 직접 접근할 수 없지만 간접적으로 확인할 수 는 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person = {\n  name: 'Lee',\n}\n\nconsole.log(Object.getOwnPropertyDescriptor(person, 'name'))\n\n// {value: 'Lee', writable: true, enumerable: true, configurable: true}</code></pre></div>\n<p>getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 ***프로퍼티 디스크립터(PropertyDescriptor)***객체를 반환한다.</p>\n<h1 id=\"3-데이터-프로퍼티와-접근자-프로퍼티\" style=\"position:relative;\"><a href=\"#3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 데이터 프로퍼티와 접근자 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h1>\n<p>데이터 프로퍼티 : 키와 값으로 구성된 프러퍼티</p>\n<p>접근자 프로퍼티 : 자체적으로 값을 갖지 않고 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티</p>\n<h3 id=\"3-1-데이터-프로퍼티\" style=\"position:relative;\"><a href=\"#3-1-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 1 데이터 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 데이터 프로퍼티</h3>\n<table>\n<thead>\n<tr>\n<th>프로퍼티 어트리뷰트</th>\n<th>프로퍼티 디스크립터 객체의 프로퍼티</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[Value]]</td>\n<td>value</td>\n<td>프로퍼티 값의 변경 가능 여부를 나타내며 boolean 값을 갖는다</td>\n</tr>\n<tr>\n<td>[[Writable]]]</td>\n<td>writable</td>\n<td>프로퍼티 키를 통해 프로퍼티 값에 접근하면 반한되는 값</td>\n</tr>\n<tr>\n<td>[[Enumerable]]</td>\n<td>enumrable</td>\n<td>프로퍼티의 열거 가능 여부를 나타내며 boolean 값을 갖는다</td>\n</tr>\n<tr>\n<td>[[Configurable]]</td>\n<td>configurable</td>\n<td>프로퍼티의 재정의 가능 여부를 나타낸다.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"32-접근자-프로퍼티\" style=\"position:relative;\"><a href=\"#32-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"32 접근자 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3.2 접근자 프로퍼티</h3>\n<table>\n<thead>\n<tr>\n<th>프로퍼티 어트리뷰트</th>\n<th>프로퍼티 디스크립터 객체의 프로퍼티</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[[Get]]</td>\n<td>get</td>\n<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수</td>\n</tr>\n<tr>\n<td>[[Set]]]</td>\n<td>set</td>\n<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수</td>\n</tr>\n<tr>\n<td>[[Enumerable]]</td>\n<td>enumrable</td>\n<td>프로퍼티의 열거 가능 여부를 나타내며 boolean 값을 갖는다</td>\n</tr>\n<tr>\n<td>[[Configurable]]</td>\n<td>configurable</td>\n<td>프로퍼티의 재정의 가능 여부를 나타낸다.</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person = {\n  firstName: 'Han',\n  lastName: 'sangjun',\n\n  get fullName() {\n    return `${this.firstName} ${this.lastName}`;\n  },\n\n  set fullName(name) {\n    [this.firstName, this.lastName] = name.split(' ');\n  }\n};</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(person.firstName + ' ' + person.lastName) //Han sangjun\nperson.fullName = \"Heegun Lee\" // set함수 실행\n\nlet descriptor = Object.getOwnPropertyDescriptor(person, 'firstName')\nconsole.log(descriptor)\n\n//\n  {value: 'Heegun', writable: true, enumerable: true, configurable: true} \n//\n\nlet descriptor = Object.getOwnPropertyDescriptor(person, 'fullName')\nconsole.log(descriptor)\n\n//\n  {enumerable: true, configurable: true, get: ƒ, set: ƒ}\n//</code></pre></div>\n<h1 id=\"4-프로퍼티-정의\" style=\"position:relative;\"><a href=\"#4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A0%95%EC%9D%98\" aria-label=\"4 프로퍼티 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 프로퍼티 정의</h1>\n<p>Object.defineProperty 메서드를 사용하여 프로퍼티 어트리뷰트를 정의할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Object.defineProperty(person, 'firstName' , {\n  value: \"~~~\",\n  writable: true of false,\n  enumerable: true of false,\n  configurable: true of false,\n})</code></pre></div>\n<table>\n<thead>\n<tr>\n<th>프로퍼티 디스크립터 객체의 프로퍼티</th>\n<th>대응하는 프로퍼티 어트리뷰트</th>\n<th>생략했을 때 기본 값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>[[Value]]</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>get</td>\n<td>[[Get]]</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>set</td>\n<td>[[Set]]</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>[[Writable]]</td>\n<td>false</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>[[Enumerable]]</td>\n<td>false</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>[[Configurable]]</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<p>Object.defineProperties 메서드를 사용하면 여러개의 프로퍼티를 한 번에 정의할 수 있다.</p>\n<h1 id=\"5-객체-변경감지\" style=\"position:relative;\"><a href=\"#5-%EA%B0%9D%EC%B2%B4-%EB%B3%80%EA%B2%BD%EA%B0%90%EC%A7%80\" aria-label=\"5 객체 변경감지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 객체 변경감지</h1>\n<p>객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다. 프로퍼티를 추가하거나 삭제할 수 있고 프로퍼티 값을 갱신할 수 있으며 프로퍼티 어트리뷰트를 재정의 할 수 있다.</p>\n<h3 id=\"5-1-객체-확장-금지\" style=\"position:relative;\"><a href=\"#5-1-%EA%B0%9D%EC%B2%B4-%ED%99%95%EC%9E%A5-%EA%B8%88%EC%A7%80\" aria-label=\"5 1 객체 확장 금지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5-1. 객체 확장 금지</h3>\n<p>Object.perventExtensions 메서드는 객체의 확장을 금지한다. <em><strong>객체 확장 금지</strong></em>란 프로퍼티 추가 금지를 의미힌다.</p>\n<h3 id=\"5-2-객체-밀봉\" style=\"position:relative;\"><a href=\"#5-2-%EA%B0%9D%EC%B2%B4-%EB%B0%80%EB%B4%89\" aria-label=\"5 2 객체 밀봉 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5-2. 객체 밀봉</h3>\n<p>Object.seal 메서드는 객체를 밀봉한다. <em><strong>밀봉된 객체는 읽기와 쓰기만 가능하다.</strong></em></p>\n<h3 id=\"5-3-객체-동결\" style=\"position:relative;\"><a href=\"#5-3-%EA%B0%9D%EC%B2%B4-%EB%8F%99%EA%B2%B0\" aria-label=\"5 3 객체 동결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5-3 객체 동결</h3>\n<p>Object.freeze 메서드는 객체를 동결한다. <em><strong>객체 동결</strong></em>이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉 <em><strong>동결된 객체는 읽기만 가능하다.</strong></em></p>\n<h3 id=\"5-4-불변-객체\" style=\"position:relative;\"><a href=\"#5-4-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4\" aria-label=\"5 4 불변 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5-4. 불변 객체</h3>\n<p>중첩 객체는 Object.freeze 메서드로 객체를 동결해도 동결할 수 없다.</p>\n<p>따라서 객체의 중첩객체 까지 동결하기 위해서는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function deepFreeze(target) {\n  if(target &amp;&amp; typeof target === 'object' &amp;&amp; !Object.isFrozen(target)) {\n    Object.freeze(target)\n    Object.keys(target).forEach(key => deepFrreze(target[key]))\n  }\n  return target;\n}</code></pre></div>","frontmatter":{"date":"December 01, 2021","title":"16. 프로퍼티 어트리뷰트","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/16.프로퍼티 어트리뷰트/"}},"prev":{"id":"97ea3f04-1af3-5da9-b517-6132f074a4b7","html":"<p>자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어다.</p>\n<p>ES6에서 클래스가 도입되었지만 그렇다고 프로토타입 기반 객체지향을 폐지하고 새로운 객체지향 모델을 제공하는것은 아니다. 클래스도 함수이며 프로토타입 기반 패턴의 문법적 설탕***(syntactic sugar)***이다.</p>\n<h1 id=\"1-객체지향-프로그래밍\" style=\"position:relative;\"><a href=\"#1-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"1 객체지향 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 객체지향 프로그래밍</h1>\n<p>객체지향 프로그래밍은 여러 개의 독립적 단위, 즉 객체(Object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const circle = {\n\tradius: 5,\n\t\n\tgetDiameter() {\n\t\treturn 2 * this.radius;\n\t}\t\n\t\n\tgetPerimeter() {\n\t\treturn 2 * Math.PI * this.radius;\n\t}\n\t\n\tgetArea() {\n\t\treturn Math.PI * this.radius ** 2;\n\t}\n}</code></pre></div>\n<p>객체지향 프로그래밍은 객체의 상태***(state)<em><strong>를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작</strong></em>(be-havior)***을 하나의 논리적인 단위로 묶어 생각한다.</p>\n<p>이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다.</p>\n<p>#2. 상속과 프로토타입</p>\n<p>상속을 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p>\n<p>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Circle(radius) {\n\tthis.radius = radius;\n\tthis.getArea = function() {\n\t\treturn Math.PI * this.radius ** 2;\n\t};\n}\n\nconst circle1 = new Circle(1);\nconst circle2 = new Circle(2);</code></pre></div>\n<p>Circle 생성자 함수가 생성하는 모든객체는 radius 프로퍼티와 getArea 메서드를 갖는다. radius 프로퍼티의 값은 일반적으로 인스턴스마다 다르다. 하지만 getArea메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용한다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때 마다 getArea 메서드를 중복 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Circle(radius) {\n\tthis.radius = radius;\n}\n\nCircle.prototype.getArea = function() {\n\treturn Math.PI * this.radius ** 2;\n}\n\nconst circle1 = new Circle(1);\nconst circle2 = new Circle(2);</code></pre></div>\n<p>Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 갖는다.</p>\n<h1 id=\"3-프로토타입-객체\" style=\"position:relative;\"><a href=\"#3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4\" aria-label=\"3 프로토타입 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 프로토타입 객체</h1>\n<p>프로토타입 객체는 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체다.</p>\n<p>모든 객체는 하나의 프로토타입을 갖는다. 모든 프로토타입은 생성자 함수와 연결되어 있다.</p>\n<h3 id=\"3-1-proto-접근자-프로퍼티\" style=\"position:relative;\"><a href=\"#3-1-proto-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 1 proto 접근자 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. <strong><strong>proto</strong></strong> 접근자 프로퍼티</h3>\n<p>모든 객체는 <strong><strong>proto</strong></strong> 접근자 프로퍼티를 통해 자신의 프로토타입에 접근할 수 있다.</p>\n<p><strong><strong>proto</strong></strong> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 Object.prototype.<strong><strong>proto</strong></strong> 접근자 프로퍼티를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person = { name: 'Lee'};\n\nconsole.log(person.hasOwnProperty('__proto__'); // false\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));\n/*\n\tconfigurable: true\n\tenumerable: false\n\tget: ƒ __proto__()\n\tset: ƒ __proto__()\n*/</code></pre></div>\n<p>_<strong><strong>proto</strong></strong> 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 —> 상호참조에 의해 프로토타입 체인이 생성되는것을 방지하기 위해</p>\n<p>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 순환 참조하는 프로토타입 체인이 만드어지면 종점이 존재하지 않기 때문에 프로퍼티를 검색할 때 무한루프에 빠진다.</p>\n<p><strong><strong>proto</strong></strong> 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우엔 Object.getPrototypeOf 메서드를 사용하고 프로토타입을 교체하고 싶은 경우엔 Object.setPrototypeOf 메서드 사용을 권장한다.</p>\n<h3 id=\"3-2-함수-객체의-prototype-프로퍼티\" style=\"position:relative;\"><a href=\"#3-2-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 2 함수 객체의 prototype 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. 함수 객체의 prototype 프로퍼티</h3>\n<p>prototype 프로퍼티는 생성자 함수로 호출할수 있는 객체 즉 constructor를 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없다.</p>\n<p>화살표함수와 ES6 메서드 축약 표현으로 정의된 메서드는 non-constructor로 prototype 프로퍼티가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function func() {}\nfunc.hasOwnProperty('prototype') // true\n\nconst obj = {}\nobj.hasOwnProperty('prototype') // false</code></pre></div>\n<h3 id=\"3-3-프로토타입의-constructor-프로퍼티와-생성자-함수\" style=\"position:relative;\"><a href=\"#3-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98\" aria-label=\"3 3 프로토타입의 constructor 프로퍼티와 생성자 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수</h3>\n<p>모든 프로토타입은 constructor 프로퍼티를 갖는다. 생성자 함수에 의해 생성된 객체는 constructor 프로퍼티를 통해 생성자 함수와 연결된다.\n생성자 함수로 생성한 것이 아닌, 리터럴 표기법으로 생성하여도 constructor 프로퍼티가 연결된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Person(name) {\n  this.name = name\n}\nconst me = new Person('kmj') // Person 생성자로 만들어진 me 객체\nme.constructor === Person // true</code></pre></div>\n<h1 id=\"4-리터럴-표기법-의해-생성된-객체의-생성자-함수와-프로토타입\" style=\"position:relative;\"><a href=\"#4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%91%9C%EA%B8%B0%EB%B2%95-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\" aria-label=\"4 리터럴 표기법 의해 생성된 객체의 생성자 함수와 프로토타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 리터럴 표기법 의해 생성된 객체의 생성자 함수와 프로토타입</h1>\n<p>리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다.</p>\n<h1 id=\"5-프로토타입의-생성-시점\" style=\"position:relative;\"><a href=\"#5-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90\" aria-label=\"5 프로토타입의 생성 시점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 프로토타입의 생성 시점</h1>\n<p>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</p>\n<p>생성자 함수로서 호출할 수 있는 함수, 즉 constructor 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(Person.prototype) // {constructor: ƒ}\n\nfunction Person(name) {\n\tthis.name = name;\n}</code></pre></div>\n<p>생성자 함수로서 호출할 수 없는함수, non-constructor는 프로토타입이 생성되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Person = name => {\n\tthis.name = name;\n};\n\nconsole.log(Person.prototype); // undefined</code></pre></div>\n<p>객체가 생성되기 전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다.</p>\n<h1 id=\"6-객체-생성-방식과-프로토타입의-결정\" style=\"position:relative;\"><a href=\"#6-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B2%B0%EC%A0%95\" aria-label=\"6 객체 생성 방식과 프로토타입의 결정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 객체 생성 방식과 프로토타입의 결정</h1>\n<p>객체를 생성하는 방식에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스 등 다양한 방법이 존재한다.</p>\n<p>세부적인 생성 방식에는 차이가 있으나, 모두 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.</p>\n<h1 id=\"7-프로토타입-체인\" style=\"position:relative;\"><a href=\"#7-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"7 프로토타입 체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 프로토타입 체인</h1>\n<p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체의 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 <em><strong>프로토타입 체인</strong></em> 이라고 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.</p>\n<p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다. ***Object.prototype을 프로토타입 체인의 종점(end of prototype chain)***이라 한다</p>\n<h1 id=\"8-오버라이딩과-프로퍼티-섀도잉\" style=\"position:relative;\"><a href=\"#8-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%84%80%EB%8F%84%EC%9E%89\" aria-label=\"8 오버라이딩과 프로퍼티 섀도잉 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. 오버라이딩과 프로퍼티 섀도잉</h1>\n<p>상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉(property shadowing)이라 한다.</p>\n<h1 id=\"9-프로토타입의-교체\" style=\"position:relative;\"><a href=\"#9-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4\" aria-label=\"9 프로토타입의 교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9. 프로토타입의 교체</h1>\n<p>프로토타입은 임의의 다른 객체로 변경할 수 있다. 즉 부모 객체의 프로토타입을 동적으로 변경할 수 있다. 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 번거롭다. 따라서 직접 교체하지 않는것이 좋다.</p>\n<h1 id=\"10-instaceof-연산자\" style=\"position:relative;\"><a href=\"#10-instaceof-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"10 instaceof 연산자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>10. instaceof 연산자</h1>\n<p>instaceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다.</p>\n<p><em><strong>우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토티입 체인 상에 존재하면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다.</strong></em></p>\n<p>instanceof 연산자는 생성자 함수의 prototypedp 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.</p>\n<h1 id=\"11-직접-상속\" style=\"position:relative;\"><a href=\"#11-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D\" aria-label=\"11 직접 상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>11. 직접 상속</h1>\n<p>Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdiranyObjectCreate를 호출한다.</p>\n<ul>\n<li>new 연산자가 없이도 객체를 생성할 수 있다.</li>\n<li>프로토타입을 지정하면서 객체를 생성할 수 있다.</li>\n<li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.</li>\n</ul>\n<p>Object.create 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문에 객체가 직접 호출하는 것을 권장하지 않는다.</p>\n<p>ES6에서는 객체 리터럴 내부에서 <strong><strong>proto</strong></strong> 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const myProto = {x: 10};\n\nconst obj = {\n\ty: 20,\n\t__proto__: myProto\n};</code></pre></div>\n<h1 id=\"12-정적-프로퍼티메서드\" style=\"position:relative;\"><a href=\"#12-%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"12 정적 프로퍼티메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>12. 정적 프로퍼티/메서드</h1>\n<p>정적(static) 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/매서드를 말한다.</p>\n<h1 id=\"13-프로퍼티-존재-확인\" style=\"position:relative;\"><a href=\"#13-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A1%B4%EC%9E%AC-%ED%99%95%EC%9D%B8\" aria-label=\"13 프로퍼티 존재 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>13. 프로퍼티 존재 확인</h1>\n<p>in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person ={\n\tname: 'Lee',\n\taddress: 'Seoul'\n}\n\nconsole.log('name' in person); // true\nconsole.log('age' in person); // false\nconsole.log('toString' in person); // true</code></pre></div>\n<p>person 객체에는 toString이라는 프로퍼티가 없지만 in 연산자는 person 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문에 true이다.</p>\n<p>in 연산자 대신 ES6에서 도입된 Reflect.has 메서드를 사용할 수도 있다. Reflect.has 메서드는 in 연산자와 동일하게 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person ={\n\tname: 'Lee',\n\taddress: 'Seoul'\n}\n\nconsole.log(Reflect.has(person, 'name')); // true\nconsole.log(Reflect.has(person, 'toString'); // true</code></pre></div>\n<h1 id=\"14-프로퍼티-열거\" style=\"position:relative;\"><a href=\"#14-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%97%B4%EA%B1%B0\" aria-label=\"14 프로퍼티 열거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>14. 프로퍼티 열거</h1>\n<p>객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for … in 문을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person ={\n\tname: 'Lee',\n\taddress: 'Seoul'\n};\n\nfor (const key in person) {\n\tconsole.log(key + ' : ' + person[key]);\n}</code></pre></div>\n<p><em><strong>for … in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티를 순회하며 열거(enumeration)한다.</strong></em></p>\n<p>for … in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다. 하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자인 프로퍼티 키에 대해서는 정렬을 한다.</p>\n<p>배열에는 for … in 문보다는 for문이나 for … of 또는 Array.prototypes.forEach메서드 사용을 권장한다.</p>\n<p>Object.keys 메서드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</p>","frontmatter":{"date":"December 06, 2021","title":"19. 프로토타입","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/19.프로토타입/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/자바스크립트/18.함수와 일급 객체/","nextSlug":"/자바스크립트/16.프로퍼티 어트리뷰트/","prevSlug":"/자바스크립트/19.프로토타입/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}