{"componentChunkName":"component---src-templates-blog-template-js","path":"/자바스크립트/20.strict mode/","result":{"data":{"cur":{"id":"b1ffe614-8c7f-5c7a-ad72-6b9b068ed1c2","html":"<h1 id=\"1-strict-mode\" style=\"position:relative;\"><a href=\"#1-strict-mode\" aria-label=\"1 strict mode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. strict mode</h1>\n<p>오타나 문법 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는것이 좋다.</p>\n<p>ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.</p>\n<p>ESLint 같은 린트도구를 사용해더 strict mode와 유사한 효과를 얻을 수 있다.</p>\n<h1 id=\"2-strict-mode-적용\" style=\"position:relative;\"><a href=\"#2-strict-mode-%EC%A0%81%EC%9A%A9\" aria-label=\"2 strict mode 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. strict mode 적용</h1>\n<p>strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두애 ‘use strict’;을 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">'use strict';\n\nfunction foo() {\n  x = 10; // ReferenceError \n}\n\nfoo()</code></pre></div>\n<p>전역에 적용한 strict mode는 스크립트 단위로 적용된다.</p>\n<p>strict mode 스크립트와 non-strict mode 스크립트를 혼용하는것은 오류를 발생시킬 수 있다. 특히 외부 서드파티 라이브러리를 사용하는 경우 라이브러리가 non-strict mode인 경우도 있기 때문에 전역에 strict mode를 쓰는것은 바람직 하지 않다.</p>\n<p>대신 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(function() {\n  'use strict';\n\n  // ~~~~\n}();)</code></pre></div>\n<p>하지만 어떤 함수는 strict mode를 적용하고 어떤 함수는 strict mode를 적용하지 않는 것은 바람직 하지 않으며 모든 함수에 일일이 strict mode를 적용하는것은 번거롭다.</p>\n<p>따라서 strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.</p>\n<h1 id=\"3-strict-mode-에러\" style=\"position:relative;\"><a href=\"#3-strict-mode-%EC%97%90%EB%9F%AC\" aria-label=\"3 strict mode 에러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. strict mode 에러</h1>\n<h3 id=\"3-1-암묵적-전역\" style=\"position:relative;\"><a href=\"#3-1-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%A0%84%EC%97%AD\" aria-label=\"3 1 암묵적 전역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. 암묵적 전역</h3>\n<p>선언하지 않은 변수를 참조하면 ReferenceError가 발생한다.</p>\n<h3 id=\"3-2-삭제\" style=\"position:relative;\"><a href=\"#3-2-%EC%82%AD%EC%A0%9C\" aria-label=\"3 2 삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. 삭제</h3>\n<p>delete 연산자로 변수,함수,매개변수를 삭제하면 SyntaxError가 발생한다</p>\n<h3 id=\"3-3-매개변수-이름-중복\" style=\"position:relative;\"><a href=\"#3-3-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%9D%B4%EB%A6%84-%EC%A4%91%EB%B3%B5\" aria-label=\"3 3 매개변수 이름 중복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3. 매개변수 이름 중복</h3>\n<p>중복된 매개변수 이름을 사용하면 SyntaxError가 발생한다.</p>\n<h3 id=\"3-4-with-문의-사용\" style=\"position:relative;\"><a href=\"#3-4-with-%EB%AC%B8%EC%9D%98-%EC%82%AC%EC%9A%A9\" aria-label=\"3 4 with 문의 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-4. with 문의 사용</h3>\n<p>with문을 사용하면 SyntaxError가 발생한다.</p>\n<h1 id=\"4-strict-mode-적용에-의한-변화\" style=\"position:relative;\"><a href=\"#4-strict-mode-%EC%A0%81%EC%9A%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%B3%80%ED%99%94\" aria-label=\"4 strict mode 적용에 의한 변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. strict mode 적용에 의한 변화</h1>\n<h3 id=\"4-1-일반함수의-this\" style=\"position:relative;\"><a href=\"#4-1-%EC%9D%BC%EB%B0%98%ED%95%A8%EC%88%98%EC%9D%98-this\" aria-label=\"4 1 일반함수의 this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-1. 일반함수의 this</h3>\n<p>strict mode에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에는 this가 필요 없기 때문이다.</p>\n<h3 id=\"4-2-arguments-객체\" style=\"position:relative;\"><a href=\"#4-2-arguments-%EA%B0%9D%EC%B2%B4\" aria-label=\"4 2 arguments 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-2. arguments 객체</h3>\n<p>strict mode에서는 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않는다.</p>","excerpt":"1. strict mode 오타나 문법 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는것이 좋다. ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다. ESLint 같은 린트도구를 사용해더 strict mode와 유사한 효과를 얻을 수 있다. 2. strict mode 적용 strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두애 ‘use strict’;을 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다. 전역에 적용한 strict mode는 스크립트 단위로 적용된다. strict mode 스크립트와 non-stric…","frontmatter":{"date":"December 10, 2021","title":"20. strict mode","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/20.strict mode/"}},"next":{"id":"5398c534-ea72-5c38-b37b-ba4108a339d9","html":"<p>자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어다.</p>\n<p>ES6에서 클래스가 도입되었지만 그렇다고 프로토타입 기반 객체지향을 폐지하고 새로운 객체지향 모델을 제공하는것은 아니다. 클래스도 함수이며 프로토타입 기반 패턴의 문법적 설탕***(syntactic sugar)***이다.</p>\n<h1 id=\"1-객체지향-프로그래밍\" style=\"position:relative;\"><a href=\"#1-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"1 객체지향 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 객체지향 프로그래밍</h1>\n<p>객체지향 프로그래밍은 여러 개의 독립적 단위, 즉 객체(Object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const circle = {\n\tradius: 5,\n\t\n\tgetDiameter() {\n\t\treturn 2 * this.radius;\n\t}\t\n\t\n\tgetPerimeter() {\n\t\treturn 2 * Math.PI * this.radius;\n\t}\n\t\n\tgetArea() {\n\t\treturn Math.PI * this.radius ** 2;\n\t}\n}</code></pre></div>\n<p>객체지향 프로그래밍은 객체의 상태***(state)<em><strong>를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작</strong></em>(be-havior)***을 하나의 논리적인 단위로 묶어 생각한다.</p>\n<p>이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다.</p>\n<p>#2. 상속과 프로토타입</p>\n<p>상속을 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p>\n<p>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Circle(radius) {\n\tthis.radius = radius;\n\tthis.getArea = function() {\n\t\treturn Math.PI * this.radius ** 2;\n\t};\n}\n\nconst circle1 = new Circle(1);\nconst circle2 = new Circle(2);</code></pre></div>\n<p>Circle 생성자 함수가 생성하는 모든객체는 radius 프로퍼티와 getArea 메서드를 갖는다. radius 프로퍼티의 값은 일반적으로 인스턴스마다 다르다. 하지만 getArea메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용한다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때 마다 getArea 메서드를 중복 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Circle(radius) {\n\tthis.radius = radius;\n}\n\nCircle.prototype.getArea = function() {\n\treturn Math.PI * this.radius ** 2;\n}\n\nconst circle1 = new Circle(1);\nconst circle2 = new Circle(2);</code></pre></div>\n<p>Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 갖는다.</p>\n<h1 id=\"3-프로토타입-객체\" style=\"position:relative;\"><a href=\"#3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4\" aria-label=\"3 프로토타입 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 프로토타입 객체</h1>\n<p>프로토타입 객체는 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체다.</p>\n<p>모든 객체는 하나의 프로토타입을 갖는다. 모든 프로토타입은 생성자 함수와 연결되어 있다.</p>\n<h3 id=\"3-1-proto-접근자-프로퍼티\" style=\"position:relative;\"><a href=\"#3-1-proto-%EC%A0%91%EA%B7%BC%EC%9E%90-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 1 proto 접근자 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-1. <strong><strong>proto</strong></strong> 접근자 프로퍼티</h3>\n<p>모든 객체는 <strong><strong>proto</strong></strong> 접근자 프로퍼티를 통해 자신의 프로토타입에 접근할 수 있다.</p>\n<p><strong><strong>proto</strong></strong> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 Object.prototype.<strong><strong>proto</strong></strong> 접근자 프로퍼티를 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person = { name: 'Lee'};\n\nconsole.log(person.hasOwnProperty('__proto__'); // false\nconsole.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));\n/*\n\tconfigurable: true\n\tenumerable: false\n\tget: ƒ __proto__()\n\tset: ƒ __proto__()\n*/</code></pre></div>\n<p>_<strong><strong>proto</strong></strong> 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유 —> 상호참조에 의해 프로토타입 체인이 생성되는것을 방지하기 위해</p>\n<p>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 순환 참조하는 프로토타입 체인이 만드어지면 종점이 존재하지 않기 때문에 프로퍼티를 검색할 때 무한루프에 빠진다.</p>\n<p><strong><strong>proto</strong></strong> 접근자 프로퍼티 대신 프로토타입의 참조를 취득하고 싶은 경우엔 Object.getPrototypeOf 메서드를 사용하고 프로토타입을 교체하고 싶은 경우엔 Object.setPrototypeOf 메서드 사용을 권장한다.</p>\n<h3 id=\"3-2-함수-객체의-prototype-프로퍼티\" style=\"position:relative;\"><a href=\"#3-2-%ED%95%A8%EC%88%98-%EA%B0%9D%EC%B2%B4%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"3 2 함수 객체의 prototype 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-2. 함수 객체의 prototype 프로퍼티</h3>\n<p>prototype 프로퍼티는 생성자 함수로 호출할수 있는 객체 즉 constructor를 소유하는 프로퍼티다. 일반 객체와 생성자 함수로 호출할 수 없는 non-constructor에는 prototype 프로퍼티가 없다.</p>\n<p>화살표함수와 ES6 메서드 축약 표현으로 정의된 메서드는 non-constructor로 prototype 프로퍼티가 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function func() {}\nfunc.hasOwnProperty('prototype') // true\n\nconst obj = {}\nobj.hasOwnProperty('prototype') // false</code></pre></div>\n<h3 id=\"3-3-프로토타입의-constructor-프로퍼티와-생성자-함수\" style=\"position:relative;\"><a href=\"#3-3-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98\" aria-label=\"3 3 프로토타입의 constructor 프로퍼티와 생성자 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수</h3>\n<p>모든 프로토타입은 constructor 프로퍼티를 갖는다. 생성자 함수에 의해 생성된 객체는 constructor 프로퍼티를 통해 생성자 함수와 연결된다.\n생성자 함수로 생성한 것이 아닌, 리터럴 표기법으로 생성하여도 constructor 프로퍼티가 연결된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function Person(name) {\n  this.name = name\n}\nconst me = new Person('kmj') // Person 생성자로 만들어진 me 객체\nme.constructor === Person // true</code></pre></div>\n<h1 id=\"4-리터럴-표기법-의해-생성된-객체의-생성자-함수와-프로토타입\" style=\"position:relative;\"><a href=\"#4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%91%9C%EA%B8%B0%EB%B2%95-%EC%9D%98%ED%95%B4-%EC%83%9D%EC%84%B1%EB%90%9C-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85\" aria-label=\"4 리터럴 표기법 의해 생성된 객체의 생성자 함수와 프로토타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 리터럴 표기법 의해 생성된 객체의 생성자 함수와 프로토타입</h1>\n<p>리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다.</p>\n<h1 id=\"5-프로토타입의-생성-시점\" style=\"position:relative;\"><a href=\"#5-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EC%83%9D%EC%84%B1-%EC%8B%9C%EC%A0%90\" aria-label=\"5 프로토타입의 생성 시점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 프로토타입의 생성 시점</h1>\n<p>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</p>\n<p>생성자 함수로서 호출할 수 있는 함수, 즉 constructor 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(Person.prototype) // {constructor: ƒ}\n\nfunction Person(name) {\n\tthis.name = name;\n}</code></pre></div>\n<p>생성자 함수로서 호출할 수 없는함수, non-constructor는 프로토타입이 생성되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const Person = name => {\n\tthis.name = name;\n};\n\nconsole.log(Person.prototype); // undefined</code></pre></div>\n<p>객체가 생성되기 전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다.</p>\n<h1 id=\"6-객체-생성-방식과-프로토타입의-결정\" style=\"position:relative;\"><a href=\"#6-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B2%B0%EC%A0%95\" aria-label=\"6 객체 생성 방식과 프로토타입의 결정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 객체 생성 방식과 프로토타입의 결정</h1>\n<p>객체를 생성하는 방식에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스 등 다양한 방법이 존재한다.</p>\n<p>세부적인 생성 방식에는 차이가 있으나, 모두 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.</p>\n<h1 id=\"7-프로토타입-체인\" style=\"position:relative;\"><a href=\"#7-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8\" aria-label=\"7 프로토타입 체인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 프로토타입 체인</h1>\n<p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체의 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 <em><strong>프로토타입 체인</strong></em> 이라고 한다. 프로토타입 체인은 자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 매커니즘이다.</p>\n<p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다. ***Object.prototype을 프로토타입 체인의 종점(end of prototype chain)***이라 한다</p>\n<h1 id=\"8-오버라이딩과-프로퍼티-섀도잉\" style=\"position:relative;\"><a href=\"#8-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%84%80%EB%8F%84%EC%9E%89\" aria-label=\"8 오버라이딩과 프로퍼티 섀도잉 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. 오버라이딩과 프로퍼티 섀도잉</h1>\n<p>상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 섀도잉(property shadowing)이라 한다.</p>\n<h1 id=\"9-프로토타입의-교체\" style=\"position:relative;\"><a href=\"#9-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%98-%EA%B5%90%EC%B2%B4\" aria-label=\"9 프로토타입의 교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9. 프로토타입의 교체</h1>\n<p>프로토타입은 임의의 다른 객체로 변경할 수 있다. 즉 부모 객체의 프로토타입을 동적으로 변경할 수 있다. 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 번거롭다. 따라서 직접 교체하지 않는것이 좋다.</p>\n<h1 id=\"10-instaceof-연산자\" style=\"position:relative;\"><a href=\"#10-instaceof-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"10 instaceof 연산자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>10. instaceof 연산자</h1>\n<p>instaceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 우변의 피연산자가 함수가 아닌 경우 TypeError가 발생한다.</p>\n<p><em><strong>우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토티입 체인 상에 존재하면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다.</strong></em></p>\n<p>instanceof 연산자는 생성자 함수의 prototypedp 바인딩된 객체가 프로토타입 체인 상에 존재하는지 확인한다.</p>\n<h1 id=\"11-직접-상속\" style=\"position:relative;\"><a href=\"#11-%EC%A7%81%EC%A0%91-%EC%83%81%EC%86%8D\" aria-label=\"11 직접 상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>11. 직접 상속</h1>\n<p>Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. Object.create 메서드도 다른 객체 생성 방식과 마찬가지로 추상 연산 OrdiranyObjectCreate를 호출한다.</p>\n<ul>\n<li>new 연산자가 없이도 객체를 생성할 수 있다.</li>\n<li>프로토타입을 지정하면서 객체를 생성할 수 있다.</li>\n<li>객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.</li>\n</ul>\n<p>Object.create 메서드를 통해 프로토타입 체인의 종점에 위치하는 객체를 생성할 수 있기 때문에 객체가 직접 호출하는 것을 권장하지 않는다.</p>\n<p>ES6에서는 객체 리터럴 내부에서 <strong><strong>proto</strong></strong> 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const myProto = {x: 10};\n\nconst obj = {\n\ty: 20,\n\t__proto__: myProto\n};</code></pre></div>\n<h1 id=\"12-정적-프로퍼티메서드\" style=\"position:relative;\"><a href=\"#12-%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"12 정적 프로퍼티메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>12. 정적 프로퍼티/메서드</h1>\n<p>정적(static) 프로퍼티/메서드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/매서드를 말한다.</p>\n<h1 id=\"13-프로퍼티-존재-확인\" style=\"position:relative;\"><a href=\"#13-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A1%B4%EC%9E%AC-%ED%99%95%EC%9D%B8\" aria-label=\"13 프로퍼티 존재 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>13. 프로퍼티 존재 확인</h1>\n<p>in 연산자는 객체 내에 특정 프로퍼티가 존재하는지 여부를 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person ={\n\tname: 'Lee',\n\taddress: 'Seoul'\n}\n\nconsole.log('name' in person); // true\nconsole.log('age' in person); // false\nconsole.log('toString' in person); // true</code></pre></div>\n<p>person 객체에는 toString이라는 프로퍼티가 없지만 in 연산자는 person 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문에 true이다.</p>\n<p>in 연산자 대신 ES6에서 도입된 Reflect.has 메서드를 사용할 수도 있다. Reflect.has 메서드는 in 연산자와 동일하게 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person ={\n\tname: 'Lee',\n\taddress: 'Seoul'\n}\n\nconsole.log(Reflect.has(person, 'name')); // true\nconsole.log(Reflect.has(person, 'toString'); // true</code></pre></div>\n<h1 id=\"14-프로퍼티-열거\" style=\"position:relative;\"><a href=\"#14-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%97%B4%EA%B1%B0\" aria-label=\"14 프로퍼티 열거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>14. 프로퍼티 열거</h1>\n<p>객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for … in 문을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const person ={\n\tname: 'Lee',\n\taddress: 'Seoul'\n};\n\nfor (const key in person) {\n\tconsole.log(key + ' : ' + person[key]);\n}</code></pre></div>\n<p><em><strong>for … in 문은 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티를 순회하며 열거(enumeration)한다.</strong></em></p>\n<p>for … in 문은 프로퍼티를 열거할 때 순서를 보장하지 않는다. 하지만 대부분의 모던 브라우저는 순서를 보장하고 숫자인 프로퍼티 키에 대해서는 정렬을 한다.</p>\n<p>배열에는 for … in 문보다는 for문이나 for … of 또는 Array.prototypes.forEach메서드 사용을 권장한다.</p>\n<p>Object.keys 메서드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다.</p>","frontmatter":{"date":"December 06, 2021","title":"19. 프로토타입","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/19.프로토타입/"}},"prev":{"id":"928d6b58-2e9c-59c7-ae55-f8f2d66938ba","html":"<h1 id=\"1-자바스크립트-객체의-분류\" style=\"position:relative;\"><a href=\"#1-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B6%84%EB%A5%98\" aria-label=\"1 자바스크립트 객체의 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 자바스크립트 객체의 분류</h1>\n<p>자바스크립트 객체는 크게 3개의 객체로 분류할 수 있다.</p>\n<ul>\n<li><em><strong>표준 빌트인 객체(standard built-in objects/native objects/global objects)</strong></em></li>\n</ul>\n<p>표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며 자바스크립트 실행 환경과 관계없이 언제나 사용할수 있다. 별도의 선언 없이 전역 변수처럼 언제나 참조 할 수 있다.</p>\n<ul>\n<li>호스트 객체(host objects)</li>\n</ul>\n<p>호스트 객체는 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체이다.</p>\n<ul>\n<li>사용자 정의 객체(user-defined objects)</li>\n</ul>\n<p>사용자 정의 객체는 사용자가 직접 정의한 객체이다.</p>\n<h1 id=\"2-표준-빌트인-객체\" style=\"position:relative;\"><a href=\"#2-%ED%91%9C%EC%A4%80-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4\" aria-label=\"2 표준 빌트인 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 표준 빌트인 객체</h1>\n<p>자바스크립트는 Object, String, Number, Symbol, Date등 40여개의 표준 빌트인 객체를 제공한다.</p>\n<p>Math, Reflect, JSON을제외한 표준 빌트인객체는 모두 인서턴스를 생성할수 있는 생성자 함수 객체다.</p>\n<p><em><strong>생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.</strong></em></p>\n<h1 id=\"3-원시값과-래퍼-객체\" style=\"position:relative;\"><a href=\"#3-%EC%9B%90%EC%8B%9C%EA%B0%92%EA%B3%BC-%EB%9E%98%ED%8D%BC-%EA%B0%9D%EC%B2%B4\" aria-label=\"3 원시값과 래퍼 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 원시값과 래퍼 객체</h1>\n<p>원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없지만 원시값인 문자열은 객처럼 동작한다. 이것은 원시값인 문자열, 숫자, 불리언 값의 경우 원시값에 대해 마침표 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해주기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const str = \"hello\";\n\nconsole.log(str.length) // 5\n\nconsole.log(typeof str); // string</code></pre></div>\n<p>원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.</p>\n<p>이 때 생성되는 객체를 <em><strong>래퍼 객체(wrapper object)라 한다.</strong></em></p>\n<p>아래의 그림은 <strong>문자열 래퍼 객체의 프로토타입 체인</strong>을 나태난 그림이다.</p>\n<p><img src=\"/wrapper.jpg\" alt=\"wrapper\"></p>\n<h1 id=\"4-전역-객체\" style=\"position:relative;\"><a href=\"#4-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4\" aria-label=\"4 전역 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 전역 객체</h1>\n<p>전역 객체는 코드가 실행되기 이전에 가장 먼저 생성되는 객체이며, 어떤 객체에도 속하지 않는 최상위 객체이다.</p>\n<ul>\n<li>전역객체는 개발자가 의도적으로 생성할 수 없다. 즉 생성자 함수가 제공되지 않는다.</li>\n<li>전역객체의 프로퍼티를 참조할때 window(또는 global)를 생략할 수 있다.</li>\n</ul>\n<h3 id=\"4-1-빌트인-전역-프로퍼티\" style=\"position:relative;\"><a href=\"#4-1-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%A0%84%EC%97%AD-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0\" aria-label=\"4 1 빌트인 전역 프로퍼티 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-1. 빌트인 전역 프로퍼티</h3>\n<p>빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다.</p>\n<ul>\n<li>Infinity</li>\n<li>NaN</li>\n<li>undefined</li>\n</ul>\n<h3 id=\"4-2-빌트인-전역-함수\" style=\"position:relative;\"><a href=\"#4-2-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%A0%84%EC%97%AD-%ED%95%A8%EC%88%98\" aria-label=\"4 2 빌트인 전역 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-2. 빌트인 전역 함수</h3>\n<p>빌트인 전역 함수는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로 전역 객체의 메서드다.</p>\n<ul>\n<li>eval : eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 전달 받는다. 문자열 코드가 여러개의 문으로 이루어져 있다면 모든 문을 실행한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">eval('1+2;') //3\n\neval('var x = 5;') // undefined</code></pre></div>\n<p><em><strong>eval 함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드에 비해 처리 속도가 느리다 따라서 eval 함수의 사용은 금지.</strong></em></p>\n<ul>\n<li>inFinite : 전달받은 인수가 유한수라면 true, 무한수라면 false</li>\n<li>isNaN : 전달받은 인수가 NaN이면 ture 아니라면 false</li>\n<li>parseFloat : 전달받은 문자열 인수를 실수로 해석하여 반환</li>\n<li>parseInt : 전달받은 문자열 인수를 정수로 해석하여 반환</li>\n<li>endcodeURI / decodeURI</li>\n</ul>\n<p>URI는 인터넷이 있는 자원을 나타내는 주소이다. URI의 하위개념으로 URL, URN이 있다.</p>\n<p>encodeURI는 URI를 문자열로 전달받아 인코딩한다. decodeURI는 인코딩된 URI를 인수로 전달받아 디코딩한다.</p>\n<p><em><strong>인코딩이란 URI문자들을 ASCII 문자 셋으로 변환하는 것을 뜻한다.</strong></em></p>\n<h3 id=\"4-3-암묵적-전역\" style=\"position:relative;\"><a href=\"#4-3-%EC%95%94%EB%AC%B5%EC%A0%81-%EC%A0%84%EC%97%AD\" aria-label=\"4 3 암묵적 전역 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4-3. 암묵적 전역</h3>\n<p>암묵적 전역이란 전역 객체의 프로퍼티가 되어 마치 전역변수처럼 동작하는것을 말한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(y); // y is not defined\n\nfunction foo() {\n  y = 20;\n}\nfoo();\n\nconsole.log(y) // 20</code></pre></div>\n<p>y는 변수 선언 없이 단지 전역 객체의 프로퍼티 추가되었을 뿐이다. y는 변수가 아니다 그러므로 변수 호이스팅도 발생하지 않는다.</p>\n<p>프로퍼티인 y는 delete 연산자로 삭제할 수 있다. 전역변수는 delete로 삭제할 수 없다.</p>","frontmatter":{"date":"December 11, 2021","title":"21. 빌트인 객체","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/21.빌트인 객체/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/자바스크립트/20.strict mode/","nextSlug":"/자바스크립트/19.프로토타입/","prevSlug":"/자바스크립트/21.빌트인 객체/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}