{"componentChunkName":"component---src-templates-blog-template-js","path":"/자바스크립트/35.스프레드 문법/","result":{"data":{"cur":{"id":"c29e1877-7e91-52ca-849e-7c518cd1b379","html":"<p>ES6에서 도입된 스프레드 문법(spread syntax)는 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for … of 문으로 순회할 수 있는 이터러블에 한정된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(...[1,2,3]); // 1 2 3\nconsole.log(...'Hello'); // H e l l o</code></pre></div>\n<p>스프레드 문법의 결과는 값이 아니다. 따라서 스프레드 문법의 결과는 변수에 할당 할 수 없다. 스프레드 문법의 결과물은 값으로 사용할 수 없고, 쉼표로 구분한 값의 목록을 사용하는 문백에서만 사용할 수 있다.</p>\n<ul>\n<li>함수 호출문의 인수 목록</li>\n<li>배열 리터럴의 요소 목록</li>\n<li>객체 리터럴의 프로퍼티 목록</li>\n</ul>\n<h1 id=\"1-함수-호출문의-인수-목록\" style=\"position:relative;\"><a href=\"#1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EB%AC%B8%EC%9D%98-%EC%9D%B8%EC%88%98-%EB%AA%A9%EB%A1%9D\" aria-label=\"1 함수 호출문의 인수 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 함수 호출문의 인수 목록</h1>\n<p>Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 만약 Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할수 없으므로 NaN을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Math.max([1,2,3]); // NaN</code></pre></div>\n<p>스프레드 문법 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달하고 싶은 경우 Function.prototype.apply를 사용했다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var arr = [1,2,3];\nvar max = Math.max.apply(null, arr); // 3\n\nconst arr = [1,2,3];\nconst max = Math.max(...arr); // 3</code></pre></div>\n<h1 id=\"2-배열-리터럴-내부에서-사용하는-경우\" style=\"position:relative;\"><a href=\"#2-%EB%B0%B0%EC%97%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"2 배열 리터럴 내부에서 사용하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 배열 리터럴 내부에서 사용하는 경우</h1>\n<h3 id=\"2-1-concat\" style=\"position:relative;\"><a href=\"#2-1-concat\" aria-label=\"2 1 concat permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. concat</h3>\n<p>2개의 배열을 1개의 배열로 결합하고 싶은 경우 concat 메서드를 사용했지만 스프레드 문법을 사용하면 별도의 메서드를 사용하지 않고 결합할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var arr = [1,2].concat([3,4]);\nconsole.log(arr); // [1,2,3,4]\n\n//ES6\nconst arr = [...[1,2], ...[3,4]];\nconsole.log(arr); // [1,2,3,4]</code></pre></div>\n<h3 id=\"2-2-splice\" style=\"position:relative;\"><a href=\"#2-2-splice\" aria-label=\"2 2 splice permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. splice</h3>\n<p>배열의 중간에 다른 배열의 요소를 추가하거나 제거하려면 splice 메서드를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5\nvar arr1 = [1,4];\nvar arr2 = [2,3];\n\nArray.prototype.splice.apply(arr1, [1,0].concat(arr2));\nconsole.log(arr1); // [1,2,3,4]\n\n//ES6\n\nconst arr1 = [1,4];\nconst arr2 = [2,3];\n\narr1.splice(1, 0, ... arr2);\nconsole.log(arr1); // [1,2,3,4]</code></pre></div>\n<h3 id=\"2-3-배열-복사\" style=\"position:relative;\"><a href=\"#2-3-%EB%B0%B0%EC%97%B4-%EB%B3%B5%EC%82%AC\" aria-label=\"2 3 배열 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. 배열 복사</h3>\n<p>배열을 복사하려면 slice 메서드를 사용한다. 이 때 원본 배열의 각 요소를 얕은 복사하여 새로운 복사본을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5\nvar origin = [1,2];\nvar copy = origin.slice();\n\n//ES6\nconst origin [1,2];\nconst copy = [...orign];</code></pre></div>\n<h3 id=\"2-4-이터러블을-배열로-변환\" style=\"position:relative;\"><a href=\"#2-4-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98\" aria-label=\"2 4 이터러블을 배열로 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4. 이터러블을 배열로 변환</h3>\n<p>이터러블을 배열로 변환하려면 Function.prototype.apply 또는 Function.prototype.call 메서드를 사용하여 slice 메서드를 호출해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5\nfunction sum() {\n  var args = Array.prototype.slice.call(arguments);\n\n  return args.reduce(function (pre, cur) {\n    return pre+cur;\n  }, 0);\n}\nconsole.log(sum(1,2,3)); // 6\n\n//ES6\nfunction sum() {\n  return [...arguments].reduce((pre,cur) => pre + cur, 0);\n}\n\nconsole.log(sum(1,2,3)); // 6\n\n// Rest 파라미터\nconst sum = (...args) => args.reduce((pre, cur) => pre + cur ,0);</code></pre></div>\n<p><strong>단 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.</strong> 이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 Array.from 메서드를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arrayLike = {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3\n}\nArray.from(arrayLike); // [1,2,3]</code></pre></div>\n<h1 id=\"3-객체-리터럴-내부에서-사용하는-경우\" style=\"position:relative;\"><a href=\"#3-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"3 객체 리터럴 내부에서 사용하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 객체 리터럴 내부에서 사용하는 경우</h1>\n<p>스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const obj = {x: 1, y: 2};\nconst copy = {...obj};\nconsole.log(copy); // {x: 1, y: 2}\n\nconst merged = {x: 1, y:2, ...{a: 3, b: 4}};\nconsole.log(merged); // {x: 1, y: 2, a: 3, b: 4}</code></pre></div>\n<p>스프레드 프로퍼티가 제안되기 전에는 Object.assign 메서드를 사용하여 여러개의 객체를 병합하거나 특정 프로퍼티를 변경, 추가했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.\nconst merged = Object.assign({}, {x: 1, y: 2},{y: 10, z: 3});\nconsole.log(merged) // {x: 1, y: 10, z: 3}</code></pre></div>","excerpt":"ES6에서 도입된 스프레드 문법(spread syntax)는 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for … of 문으로 순회할 수 있는 이터러블에 한정된다. 스프레드 문법의 결과는 값이 아니다. 따라서 스프레드 문법의 결과는 변수에 할당 할 수 없다. 스프레드 문법의 결과물은 값으로 사용할 수 없고, 쉼표로 구분한 값의 목록을 사용하는 문백에서만 사용할 수 있다. 함수 호출문의 인수 목록 배열 리터럴의 요소 목록 객체 리터럴의 프로퍼티 목록 1. 함수 호출문의 인수 목록 Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 만약 Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할수 없으므로 NaN을 반환한다. 스프레드 문법 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인…","frontmatter":{"date":"February 26, 2022","title":"35. 스프레드 문법","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/35.스프레드 문법/"}},"next":{"id":"b1b01c64-b220-5003-8693-236bbac3cf6c","html":"<h1 id=\"1-이터레이션-프로토콜\" style=\"position:relative;\"><a href=\"#1-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\" aria-label=\"1 이터레이션 프로토콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 이터레이션 프로토콜</h1>\n<p>ES6에서 도입된 iteration protocol은 순회 가능한 데이터 컬렉션을 만들기 위해 EMCAScript 사양에 정의하여 미리 약속한 규칙이다.</p>\n<p>ES6 이전의 배열, 문자열, 유사 배열 객체, DOM 컬렉션등은 통일된 규약 없이 각자 나름의 구조를 가지고 for문, for … in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다.</p>\n<p>ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for … of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 했다.</p>\n<ul>\n<li>\n<p>iterable protocol : Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. <strong>이러한 규약을 이터러블 프로토콜이라 한다. 이터러블 프로토콜을 준수한 객체를 <code class=\"language-text\">이터러블</code>이라 한다.</strong>\n<code class=\"language-text\">이터러블</code>은 for … of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.</p>\n</li>\n<li>\n<p>iterator protocol : 이터러블의 Symbol.iteraotor 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 <code class=\"language-text\">next</code> 메서드를 소유하여 <code class=\"language-text\">next</code> 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 iterator result object를 반환한다. <strong>이러한 규약을 이터레이터 프로토이라 한다.</strong></p>\n</li>\n</ul>\n<p><img src=\"/iteration.jpeg\" alt=\"iteration\"></p>\n<h1 id=\"1-1-이터러블\" style=\"position:relative;\"><a href=\"#1-1-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94\" aria-label=\"1 1 이터러블 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-1. 이터러블</h1>\n<p>이터러블 프로토콜을 준수한 객체를 이터러블이라 한다. 이터러블인지 확인하는 함수는 아래 코드와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const isIterable = v => v !== null &amp;&amp; typeof v[Symbol.iterator] === 'function';\n\nisIterable([]); // true\nisIterable(''); // true\nisIterable(new Map()); // true\nisIterable(new Set()); // true\nisIterable({}); // false</code></pre></div>\n<p>Symbol.iterator 메서드를 직접 구현하지 않거나 상속받지 않은 일반 객체는 이터러블 프로토콜을 준수한 이터러블이 아니다. 따라서 일반 객체는 for … of 문으로 순회할 수 없으며 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.</p>\n<p><strong>하지만 일반 객체도 이터러블 프로토콜을 준수하도록 구현하면 이터러블이 된다.</strong></p>\n<h1 id=\"1-2-이터레이터\" style=\"position:relative;\"><a href=\"#1-2-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0\" aria-label=\"1 2 이터레이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1-2. 이터레이터</h1>\n<p>이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터러블의 <code class=\"language-text\">Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const array = [1,2,3];\n\nconst iterator = array[Symbol.iterator]();\n\nconsole.log('next' in iterator); // true</code></pre></div>\n<p>이터레이터의 next 메서드는 이터러블의 각 요소를 순회하기 위한 포인터의 역할을 한다. next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 <code class=\"language-text\">iterator result object</code>를 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const array = [1,2,3];\nconst iterator = array[Symbol.iterator]();\n\nconsole.log(iterator.next()); // {value: 1, done: false}\nconsole.log(iterator.next()); // {value: 2, done: false}\nconsole.log(iterator.next()); // {value: 3, done: false}\nconsole.log(iterator.next()); // {value: undefined, done: false}</code></pre></div>\n<p>이터레이터의 next 메서드가 반환하는 iterator result object의 value 프로퍼티는 현재 순회 중인 이터러블의 값을 나타내며 done 프로퍼티는 이터러블의 순회 완료 여부를 나타낸다.</p>\n<h1 id=\"2-for--of-문\" style=\"position:relative;\"><a href=\"#2-for--of-%EB%AC%B8\" aria-label=\"2 for  of 문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. for … of 문</h1>\n<p>for … of 문은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (변수선언문 of 이터러블) {}</code></pre></div>\n<p>for … of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 iterator result object의 value 프로퍼티 값을 for … of 문의 변수에 할당한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (const item of [1,2,3]) {\n  console.log(item); // 1 2 3\n}</code></pre></div>\n<h1 id=\"3-이터러블과-유사-배열-객체\" style=\"position:relative;\"><a href=\"#3-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EA%B3%BC-%EC%9C%A0%EC%82%AC-%EB%B0%B0%EC%97%B4-%EA%B0%9D%EC%B2%B4\" aria-label=\"3 이터러블과 유사 배열 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 이터러블과 유사 배열 객체</h1>\n<p>유사 배열 객체는 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있꼬 length 프로퍼티 값을 갖는 객체이다. 따라서 유사 배열 객체는 for문으로 순회할 수 있고 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다.</p>\n<p>유사 배열 객체는 이터러블이 아닌 일반 객체다. 따라서 for … of 문으로 순회할 수 없다. 하지만 arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다.</p>\n<p>—> ES6에서 이터러블이 도입되면서 유사 배열 객체인 arguments, NodeList, HTMLCollection 객체에 Symbol.iterator 메서드를 구현하여 이터러블이 되었다. <code class=\"language-text\">모든 유사 배열 겍체가 이터러블인 것은 아니다.</code></p>\n<p>ES6에서 도입된 Array.from 메서드를 사용하여 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arrayLike = {\n  0:1,\n  1:2,\n  2:3,\n  length:3\n};\n\nconst arr = Array.from(arrayLike);\nconsole.log(arr)</code></pre></div>\n<h1 id=\"4-이터레이션-프로토콜의-필요성\" style=\"position:relative;\"><a href=\"#4-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"4 이터레이션 프로토콜의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 이터레이션 프로토콜의 필요성</h1>\n<p>이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 <code class=\"language-text\">데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할을 한다.</code></p>\n<h1 id=\"5-사용자-정의-이터러블\" style=\"position:relative;\"><a href=\"#5-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94\" aria-label=\"5 사용자 정의 이터러블 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 사용자 정의 이터러블</h1>\n<p>이터레이션 프로토콜을 준수하지 않는 일반 객체도 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 된다. 아래의 코드는 피보나치 수열을 구현한 사용자 정의 이터러블이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const fibonacci = {\n  [Symbol.iterator]() {\n    let [pre, cur] = [0, 1];\n    const max = 10;\n\n    return {\n      next() {\n        [pre, cur] = [cur, pre + cur];\n        return { value: cur, done: cur >= max};\n      }\n    };\n  }\n};\n\nfor (const num of fibonacci) {\n  console.log(num); // 1 2 3 5 8\n}</code></pre></div>\n<p>위의 fibonacci 이터러블은 내부에 수열의 최대값 max를 가지고 있다. max값은 고정된 값으로 전달한 값으로 변경할 방법이 없는것이 아쉽다. 수열의 최대값을 외부에서 전달하는 방법은 아래 코드와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const fibonacci = function(max) {\n  let [pre, cur] = [0, 1];\n\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          [pre, cur] = [cur, pre + cur];\n          return { value: cur, done: cur >= max};\n        }\n      };\n    }\n  };\n};\n\nfor (const num of fibonacci(10)) {\n  console.log(num); // 1 2 3 5 8\n}</code></pre></div>\n<p>이이터러블이면서 이레터인 객체를 생성하면 Symbol.iterator 메서드를 호출하지 않아도 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const fibonacciFunc = function(max) {\n  let [pre, cur] = [0, 1];\n\n  return {\n    [Symbol.iterator]() {return this;},\n    next() {\n      [pre, cur] = [cur, pre + cur];\n      return {value: cur, done: cur >= max};\n    }\n  };\n};\n\nlet iter = fibonacciFunc(10); // iter는 이터러블이면서 이터레이터이다.\n\nfor (const num of iter) {\n  console.log(num); // 1 2 3 5 8\n}\n\niter = fibonacciFunc(10);\n\nconsole.log(iter.next()); // {value: 1, done: false }\nconsole.log(iter.next()); // {value: 2, done: false }\nconsole.log(iter.next()); // {value: 3, done: false }\nconsole.log(iter.next()); // {value: 5, done: false }\nconsole.log(iter.next()); // {value: 8, done: false }\nconsole.log(iter.next()); // {value: 13, done: true }</code></pre></div>\n<p>무한 이터러블을 생성하는 함수를 통해 무한 수열을 간단히 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const fibonacciFunc = function(max) {\n  let [pre, cur] = [0, 1];\n\n  return {\n    [Symbol.iterator]() {return this;},\n    next() {\n      [pre, cur] = [cur, pre + cur];\n      return {value: cur}; // 무한을 구현하기 위해 done을 생략한다.\n    }\n  };\n};\n\nfor (const num of fibonacciFunc()) {\n  if (num > 10000) break;\n  console.log(num);\n}\n\n// 배열 디스트럭처링 할당을 통해 무한 이터러블에서 3개의 요소만 가져올 수 있다.\nconst [f1,f2,f3] = fibonacciFunc();\nconsole.log(f1,f2,f3) // 1 2 3</code></pre></div>\n<p><code class=\"language-text\">지연 평가(lazy evaluation)</code>는 데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가 데이터가 필요한 시점이 되면 그때서야 데이터를 생성하는 기법이다.</p>\n<p>fibonacciFunc 함수가 생성한 무한 이터러블은 데이터를 공급하는 메커니즘을 구현한 것으로 데이터 소비자인 for … of 문이나 배열 디스트럭처링 할당등이 실행되기 이전까지 데이터를 생성하지 않는다. for … of 문의 경우 이터러블을 순회할 때 내부에서 이터레이터의 next 메서드를 호출하는데 이때 데이터가 생성된다.</p>\n<p><strong>지연평가를 사용하면 불필요한 데이터를 미리 생성하지 않고 필요한 데이터를 필요한 순간에 생성하므로 빠른 실행속도를 기대할 수 있고 불필요한 메모리를 소비하지 않으며 무한도 표현할 수 있다는 장점이 있다.</strong></p>","frontmatter":{"date":"February 19, 2022","title":"34. 이터러블","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/34.이터러블/"}},"prev":{"id":"a4963989-15b9-5b81-a9d5-0441120de10c","html":"<p>디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.</p>\n<h1 id=\"1-배열-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EC%97%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"1 배열 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배열 디스트럭처링 할당</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arr = [1, 2, 3];\n\nconst [one, two, three] = arr;\nconsole.log(one, two, three); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다.</p>\n<p>배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가\n반드시 일치할 필요는 없다.</p>\n<p>배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, y] = [1,2];\nconst [x, y]; // SyntaxError\nconst [a, b] = {}; // TypeError\n\nconst [c, d] = [1];\nconsole.log(c, d); // 1 undefined;\n\nconst [e, f] = [1,2,3];\nconsole.log(e, f); // 1 2\n\nconst [a, b , c = 3] = [1,2];\nconsole.log(a, b, c); // 1 2 3\n\nconst [e,f = 10, g = 3] = [1, 2];\nconsole.log(e, f, g); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 <code class=\"language-text\">Rest 요소</code> …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, ...y] = [1, 2, 3];\nconsole.log(x, y); // 1 [2, 3]</code></pre></div>\n<h1 id=\"2-객체-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#2-%EA%B0%9D%EC%B2%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"2 객체 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 객체 디스트럭처링 할당</h1>\n<p>객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 순서는 의미가 없으며 선언된 변수이름과 프로퍼티 키가 일치하면 할당된다.</p>\n<p>객체 디스트럭처링 할당을 위해서는 변수를 객체 리터럴 형태로 선언해야 한다. 이때 우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { lastName, firstName } = { firstName:'Ungmo', lastName: 'Lee' };</code></pre></div>\n<p>객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 아래와 같이 변수를 선언한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const user = { firstName: 'Ungmo', lastName: 'Lee' };\n\nconst { lastName: ln, firstName: fn } = user;\nconsole.log(fn,ln); // Ungmo Lee</code></pre></div>\n<p>객체 디스트럭처링은 변수에 기본값을 설정할 수 있다. 또한 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { firstName = 'Ungmo', lastName } = { lastName: 'Lee' };\nconsole.log(firstName, lastName); // Ungmo Lee\n\nfunction printTodo(todo) {\n  console.log(`할일 ${todo.content}은 ${todo.completed ? '완료' : '미완료'} 상태입니다.`);\n}\n\nprintTodo({id: 1, content: '설거지', completed: true}); // 할일 설거지은 완료 상태입니다.</code></pre></div>\n<p>배열의 요소가 객체인 경우에 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todos = [\n  {\n    id: 1, content: 'HTML', completed: true\n  },\n  {\n    id: 2, content: 'CSS', completed: false\n  },\n  {\n    id: 3, content: 'JS', completed: false\n  }\n];\n\n// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만 추출\nconst [, { id }] = todos;\nconsole.log(id); // 2\n\n// 중첩 객체\nconst user = {\n  name: 'Lee',\n  address: {\n    zipCode: '03068',\n    city: 'Seoul'\n  }\n};\n\n// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출\nconst { address: { city } } = user;\nconsole.log(city); // Seoul</code></pre></div>\n<p>객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터나 Rest 요소와 유사하게 <code class=\"language-text\">Rest 프로퍼티 ...</code> 을 사용할 수 있다.\nRest 프로퍼티는 Rest 파라미터나 Rest 요소와 맟나가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { x, ...rest } = { x: 1, y: 2, z: 3};\nconsole.log(x, rest); // 1 {y: 2, z: 3}</code></pre></div>","frontmatter":{"date":"March 12, 2022","title":"36. 디스트럭처링 할당","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/36.디스트럭쳐링 할당/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/자바스크립트/35.스프레드 문법/","nextSlug":"/자바스크립트/34.이터러블/","prevSlug":"/자바스크립트/36.디스트럭쳐링 할당/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}