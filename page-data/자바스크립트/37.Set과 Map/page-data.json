{"componentChunkName":"component---src-templates-blog-template-js","path":"/자바스크립트/37.Set과 Map/","result":{"data":{"cur":{"id":"3b22e04a-dabd-5c3d-9e7c-aeba3e540c9a","html":"<h1 id=\"1-set\" style=\"position:relative;\"><a href=\"#1-set\" aria-label=\"1 set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Set</h1>\n<p>Set 객체는 <code class=\"language-text\">중복되지 않는</code> 유일한 값들의 집합이다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>배열</th>\n<th>Set 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>동일한 값을 중복하여 포함할 수 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>요소 순서에 의미가 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>인덱스로 요소에 접근할 수 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const set = new Set([1, 2, 3, 3]);\nconsole.log(set); // Set(3) {1,2,3}</code></pre></div>\n<h1 id=\"2-set-객체-메서드\" style=\"position:relative;\"><a href=\"#2-set-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"2 set 객체 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Set 객체 메서드</h1>\n<p>Set 객체의 요소 개수를 확인할때는 <code class=\"language-text\">Set.prototype.size</code> 프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const set = new Set[1, 2, 3, 3]);\nconsole.log(set.size); //\n\nset.size = 10; // 무시됨</code></pre></div>\n<p>Set 객체에 요소를 추가할 때는 <code class=\"language-text\">Set.prototype.add</code> 메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다.</p>\n<p>Set 객체에 특정 요소가 존재하는지 확인하려면 <code class=\"language-text\">Set.prototype.has</code> 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.</p>\n<p>Set 객체의 특정 요소를 삭제하려면 <code class=\"language-text\">Set.prototype.delete</code> 메서드를 사용한다 delete 메서드는 불리언 값을 반환한다.</p>\n<p>Set 객체의 모든 요소를 일괄 삭제하려면 <code class=\"language-text\">Set.prototype.clear</code> 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다.</p>\n<p>Set 객체의 요소를 순회하려면 <code class=\"language-text\">Set.prototype.forEach</code> 메서드를 사용한다. Set 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 디스트럭처링의 대상이 될 수도 있다.</p>\n<p>Set 객체는 수학적 집합을 구현하기 위한 자료구조이다. 따라서 Set 객체를 통해 교집합, 합집합, 차집합등을 구현할 수 있다.</p>\n<h1 id=\"3-map\" style=\"position:relative;\"><a href=\"#3-map\" aria-label=\"3 map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Map</h1>\n<p>Map 객체는 <code class=\"language-text\">키와 값의 쌍</code>으로 이루어진 컬렉션이다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>객체</th>\n<th>Map 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>키로 사용할 수 있는 값</td>\n<td>문자열 또는 심벌 값</td>\n<td>객체를 포함한 모든 값</td>\n</tr>\n<tr>\n<td>이터러블</td>\n<td>X</td>\n<td>O</td>\n</tr>\n<tr>\n<td>요수 개수 확인</td>\n<td>Object.keys(obj).length</td>\n<td>map.size</td>\n</tr>\n</tbody>\n</table>\n<p>Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되느 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.</p>\n<p>Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const map = new Map([['key1', 'value1'], ['key2', 'value2']]);\nconsole.log(map); // {'key1' => 'value1', 'key2' => 'value2'}\n\nconst map = new Map([['key1', 'value1'], ['key1', 'value2']]);\nconsole.log(map); //  {'key1' => 'value2'}</code></pre></div>\n<h1 id=\"4-map-객체-메서드\" style=\"position:relative;\"><a href=\"#4-map-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"4 map 객체 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Map 객체 메서드</h1>\n<p>Map 객체의 요소 개수를 확인할 때는 <code class=\"language-text\">Map.prototype.size</code> 프로퍼티를 사용한다.</p>\n<p>Map 객체의 요소를 추가할 때는 <code class=\"language-text\">Map.prototype.set</code> 메서드를 사용한다. set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다. 따라서 set 메서드를 연속적으로 호출할 수 있다.</p>\n<p>Map 객체에서 특정 요소를 취득할 때는 <code class=\"language-text\">Map.prototype.get</code> 메서드를 사용한다. get 메서드는 인수로 전달한 키를 갖는 값을 반환하고 인수로 전달한 키를 갖는 요소가 존재하지 않으면 undefined를 반환한다.</p>\n<p>Map 객체에서 특정 요소가 존재하는지 확인하려면 <code class=\"language-text\">Map.prototype.has</code> 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.</p>\n<p>Map 객체의 요소를 삭제하려면 <code class=\"language-text\">Map.prototype.delete</code> 메서드를 사용한다. delete 메서드는 불리언 값을 반환한다.</p>\n<p>Map 객체의 요소를순회하려면 <code class=\"language-text\">Map.prototype.forEach</code> 메서드를 사용한다.</p>\n<ul>\n<li>첫번째 인수 : 현재 순회중인 요소 값</li>\n<li>두번째 인수 : 현재 순회중인 요소 키</li>\n<li>세번째 인수 : 현재 순회중인 Map 객체</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const lee = { name : 'Lee' };\nconst kim = { name : 'Kim' };\n\nconst map = new Map([[lee, 'developer'], [kim, 'designer']]);\n\nmap.forEach((v,k,map) => console.log(v,k,map))</code></pre></div>\n<p>Map 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.</p>","excerpt":"1. Set Set 객체는  유일한 값들의 집합이다. 구분 배열 Set 객체 동일한 값을 중복하여 포함할 수 있다. O X 요소 순서에 의미가 있다. O X 인덱스로 요소에 접근할 수 있다. O X Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다. 2. Set 객체 메서드 Set 객체의 요소 개수를 확인할때는  프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다. Set 객체에 요소를 추가할 때는  메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다. Set 객체에 특정 요소가 존재하는지 확인하려면  메서드를 사용한다. has 메서드는 불리언 값을 반환한다. Set 객체의 …","frontmatter":{"date":"March 18, 2022","title":"37. Set과 Map","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/37.Set과 Map/"}},"next":{"id":"0e21442b-5822-56e4-895b-b7bf6b81465c","html":"<p>디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.</p>\n<h1 id=\"1-배열-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EC%97%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"1 배열 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배열 디스트럭처링 할당</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arr = [1, 2, 3];\n\nconst [one, two, three] = arr;\nconsole.log(one, two, three); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다.</p>\n<p>배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가\n반드시 일치할 필요는 없다.</p>\n<p>배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, y] = [1,2];\nconst [x, y]; // SyntaxError\nconst [a, b] = {}; // TypeError\n\nconst [c, d] = [1];\nconsole.log(c, d); // 1 undefined;\n\nconst [e, f] = [1,2,3];\nconsole.log(e, f); // 1 2\n\nconst [a, b , c = 3] = [1,2];\nconsole.log(a, b, c); // 1 2 3\n\nconst [e,f = 10, g = 3] = [1, 2];\nconsole.log(e, f, g); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 <code class=\"language-text\">Rest 요소</code> …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, ...y] = [1, 2, 3];\nconsole.log(x, y); // 1 [2, 3]</code></pre></div>\n<h1 id=\"2-객체-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#2-%EA%B0%9D%EC%B2%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"2 객체 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 객체 디스트럭처링 할당</h1>\n<p>객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 순서는 의미가 없으며 선언된 변수이름과 프로퍼티 키가 일치하면 할당된다.</p>\n<p>객체 디스트럭처링 할당을 위해서는 변수를 객체 리터럴 형태로 선언해야 한다. 이때 우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { lastName, firstName } = { firstName:'Ungmo', lastName: 'Lee' };</code></pre></div>\n<p>객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 아래와 같이 변수를 선언한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const user = { firstName: 'Ungmo', lastName: 'Lee' };\n\nconst { lastName: ln, firstName: fn } = user;\nconsole.log(fn,ln); // Ungmo Lee</code></pre></div>\n<p>객체 디스트럭처링은 변수에 기본값을 설정할 수 있다. 또한 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { firstName = 'Ungmo', lastName } = { lastName: 'Lee' };\nconsole.log(firstName, lastName); // Ungmo Lee\n\nfunction printTodo(todo) {\n  console.log(`할일 ${todo.content}은 ${todo.completed ? '완료' : '미완료'} 상태입니다.`);\n}\n\nprintTodo({id: 1, content: '설거지', completed: true}); // 할일 설거지은 완료 상태입니다.</code></pre></div>\n<p>배열의 요소가 객체인 경우에 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todos = [\n  {\n    id: 1, content: 'HTML', completed: true\n  },\n  {\n    id: 2, content: 'CSS', completed: false\n  },\n  {\n    id: 3, content: 'JS', completed: false\n  }\n];\n\n// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만 추출\nconst [, { id }] = todos;\nconsole.log(id); // 2\n\n// 중첩 객체\nconst user = {\n  name: 'Lee',\n  address: {\n    zipCode: '03068',\n    city: 'Seoul'\n  }\n};\n\n// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출\nconst { address: { city } } = user;\nconsole.log(city); // Seoul</code></pre></div>\n<p>객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터나 Rest 요소와 유사하게 <code class=\"language-text\">Rest 프로퍼티 ...</code> 을 사용할 수 있다.\nRest 프로퍼티는 Rest 파라미터나 Rest 요소와 맟나가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { x, ...rest } = { x: 1, y: 2, z: 3};\nconsole.log(x, rest); // 1 {y: 2, z: 3}</code></pre></div>","frontmatter":{"date":"March 12, 2022","title":"36. 디스트럭처링 할당","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/36.디스트럭쳐링 할당/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/자바스크립트/37.Set과 Map/","nextSlug":"/자바스크립트/36.디스트럭쳐링 할당/","prevSlug":""}},"staticQueryHashes":["1073350324","2938748437"]}