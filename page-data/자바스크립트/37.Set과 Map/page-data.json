{"componentChunkName":"component---src-templates-blog-template-js","path":"/자바스크립트/37.Set과 Map/","result":{"data":{"cur":{"id":"3b22e04a-dabd-5c3d-9e7c-aeba3e540c9a","html":"<h1 id=\"1-set\" style=\"position:relative;\"><a href=\"#1-set\" aria-label=\"1 set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Set</h1>\n<p>Set 객체는 <code class=\"language-text\">중복되지 않는</code> 유일한 값들의 집합이다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>배열</th>\n<th>Set 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>동일한 값을 중복하여 포함할 수 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>요소 순서에 의미가 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>인덱스로 요소에 접근할 수 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const set = new Set([1, 2, 3, 3]);\nconsole.log(set); // Set(3) {1,2,3}</code></pre></div>\n<h1 id=\"2-set-객체-메서드\" style=\"position:relative;\"><a href=\"#2-set-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"2 set 객체 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Set 객체 메서드</h1>\n<p>Set 객체의 요소 개수를 확인할때는 <code class=\"language-text\">Set.prototype.size</code> 프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const set = new Set[1, 2, 3, 3]);\nconsole.log(set.size); //\n\nset.size = 10; // 무시됨</code></pre></div>\n<p>Set 객체에 요소를 추가할 때는 <code class=\"language-text\">Set.prototype.add</code> 메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다.</p>\n<p>Set 객체에 특정 요소가 존재하는지 확인하려면 <code class=\"language-text\">Set.prototype.has</code> 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.</p>\n<p>Set 객체의 특정 요소를 삭제하려면 <code class=\"language-text\">Set.prototype.delete</code> 메서드를 사용한다 delete 메서드는 불리언 값을 반환한다.</p>\n<p>Set 객체의 모든 요소를 일괄 삭제하려면 <code class=\"language-text\">Set.prototype.clear</code> 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다.</p>\n<p>Set 객체의 요소를 순회하려면 <code class=\"language-text\">Set.prototype.forEach</code> 메서드를 사용한다. Set 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 디스트럭처링의 대상이 될 수도 있다.</p>\n<p>Set 객체는 수학적 집합을 구현하기 위한 자료구조이다. 따라서 Set 객체를 통해 교집합, 합집합, 차집합등을 구현할 수 있다.</p>\n<h1 id=\"3-map\" style=\"position:relative;\"><a href=\"#3-map\" aria-label=\"3 map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Map</h1>\n<p>Map 객체는 <code class=\"language-text\">키와 값의 쌍</code>으로 이루어진 컬렉션이다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>객체</th>\n<th>Map 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>키로 사용할 수 있는 값</td>\n<td>문자열 또는 심벌 값</td>\n<td>객체를 포함한 모든 값</td>\n</tr>\n<tr>\n<td>이터러블</td>\n<td>X</td>\n<td>O</td>\n</tr>\n<tr>\n<td>요수 개수 확인</td>\n<td>Object.keys(obj).length</td>\n<td>map.size</td>\n</tr>\n</tbody>\n</table>\n<p>Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되느 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.</p>\n<p>Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const map = new Map([['key1', 'value1'], ['key2', 'value2']]);\nconsole.log(map); // {'key1' => 'value1', 'key2' => 'value2'}\n\nconst map = new Map([['key1', 'value1'], ['key1', 'value2']]);\nconsole.log(map); //  {'key1' => 'value2'}</code></pre></div>\n<h1 id=\"4-map-객체-메서드\" style=\"position:relative;\"><a href=\"#4-map-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"4 map 객체 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Map 객체 메서드</h1>\n<p>Map 객체의 요소 개수를 확인할 때는 <code class=\"language-text\">Map.prototype.size</code> 프로퍼티를 사용한다.</p>\n<p>Map 객체의 요소를 추가할 때는 <code class=\"language-text\">Map.prototype.set</code> 메서드를 사용한다. set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다. 따라서 set 메서드를 연속적으로 호출할 수 있다.</p>\n<p>Map 객체에서 특정 요소를 취득할 때는 <code class=\"language-text\">Map.prototype.get</code> 메서드를 사용한다. get 메서드는 인수로 전달한 키를 갖는 값을 반환하고 인수로 전달한 키를 갖는 요소가 존재하지 않으면 undefined를 반환한다.</p>\n<p>Map 객체에서 특정 요소가 존재하는지 확인하려면 <code class=\"language-text\">Map.prototype.has</code> 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.</p>\n<p>Map 객체의 요소를 삭제하려면 <code class=\"language-text\">Map.prototype.delete</code> 메서드를 사용한다. delete 메서드는 불리언 값을 반환한다.</p>\n<p>Map 객체의 요소를순회하려면 <code class=\"language-text\">Map.prototype.forEach</code> 메서드를 사용한다.</p>\n<ul>\n<li>첫번째 인수 : 현재 순회중인 요소 값</li>\n<li>두번째 인수 : 현재 순회중인 요소 키</li>\n<li>세번째 인수 : 현재 순회중인 Map 객체</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const lee = { name : 'Lee' };\nconst kim = { name : 'Kim' };\n\nconst map = new Map([[lee, 'developer'], [kim, 'designer']]);\n\nmap.forEach((v,k,map) => console.log(v,k,map))</code></pre></div>\n<p>Map 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.</p>","excerpt":"1. Set Set 객체는  유일한 값들의 집합이다. 구분 배열 Set 객체 동일한 값을 중복하여 포함할 수 있다. O X 요소 순서에 의미가 있다. O X 인덱스로 요소에 접근할 수 있다. O X Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다. 2. Set 객체 메서드 Set 객체의 요소 개수를 확인할때는  프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다. Set 객체에 요소를 추가할 때는  메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다. Set 객체에 특정 요소가 존재하는지 확인하려면  메서드를 사용한다. has 메서드는 불리언 값을 반환한다. Set 객체의 …","frontmatter":{"date":"March 18, 2022","title":"37. Set과 Map","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/37.Set과 Map/"}},"next":{"id":"0e21442b-5822-56e4-895b-b7bf6b81465c","html":"<p>디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.</p>\n<h1 id=\"1-배열-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EC%97%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"1 배열 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배열 디스트럭처링 할당</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arr = [1, 2, 3];\n\nconst [one, two, three] = arr;\nconsole.log(one, two, three); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다.</p>\n<p>배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가\n반드시 일치할 필요는 없다.</p>\n<p>배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, y] = [1,2];\nconst [x, y]; // SyntaxError\nconst [a, b] = {}; // TypeError\n\nconst [c, d] = [1];\nconsole.log(c, d); // 1 undefined;\n\nconst [e, f] = [1,2,3];\nconsole.log(e, f); // 1 2\n\nconst [a, b , c = 3] = [1,2];\nconsole.log(a, b, c); // 1 2 3\n\nconst [e,f = 10, g = 3] = [1, 2];\nconsole.log(e, f, g); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 <code class=\"language-text\">Rest 요소</code> …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, ...y] = [1, 2, 3];\nconsole.log(x, y); // 1 [2, 3]</code></pre></div>\n<h1 id=\"2-객체-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#2-%EA%B0%9D%EC%B2%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"2 객체 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 객체 디스트럭처링 할당</h1>\n<p>객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 순서는 의미가 없으며 선언된 변수이름과 프로퍼티 키가 일치하면 할당된다.</p>\n<p>객체 디스트럭처링 할당을 위해서는 변수를 객체 리터럴 형태로 선언해야 한다. 이때 우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { lastName, firstName } = { firstName:'Ungmo', lastName: 'Lee' };</code></pre></div>\n<p>객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 아래와 같이 변수를 선언한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const user = { firstName: 'Ungmo', lastName: 'Lee' };\n\nconst { lastName: ln, firstName: fn } = user;\nconsole.log(fn,ln); // Ungmo Lee</code></pre></div>\n<p>객체 디스트럭처링은 변수에 기본값을 설정할 수 있다. 또한 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { firstName = 'Ungmo', lastName } = { lastName: 'Lee' };\nconsole.log(firstName, lastName); // Ungmo Lee\n\nfunction printTodo(todo) {\n  console.log(`할일 ${todo.content}은 ${todo.completed ? '완료' : '미완료'} 상태입니다.`);\n}\n\nprintTodo({id: 1, content: '설거지', completed: true}); // 할일 설거지은 완료 상태입니다.</code></pre></div>\n<p>배열의 요소가 객체인 경우에 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todos = [\n  {\n    id: 1, content: 'HTML', completed: true\n  },\n  {\n    id: 2, content: 'CSS', completed: false\n  },\n  {\n    id: 3, content: 'JS', completed: false\n  }\n];\n\n// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만 추출\nconst [, { id }] = todos;\nconsole.log(id); // 2\n\n// 중첩 객체\nconst user = {\n  name: 'Lee',\n  address: {\n    zipCode: '03068',\n    city: 'Seoul'\n  }\n};\n\n// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출\nconst { address: { city } } = user;\nconsole.log(city); // Seoul</code></pre></div>\n<p>객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터나 Rest 요소와 유사하게 <code class=\"language-text\">Rest 프로퍼티 ...</code> 을 사용할 수 있다.\nRest 프로퍼티는 Rest 파라미터나 Rest 요소와 맟나가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { x, ...rest } = { x: 1, y: 2, z: 3};\nconsole.log(x, rest); // 1 {y: 2, z: 3}</code></pre></div>","frontmatter":{"date":"March 12, 2022","title":"36. 디스트럭처링 할당","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/36.디스트럭쳐링 할당/"}},"prev":{"id":"0d7dc3ee-d82e-5514-a7af-e02bc839e001","html":"<h1 id=\"1-브라우저의-렌더링-과정\" style=\"position:relative;\"><a href=\"#1-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95\" aria-label=\"1 브라우저의 렌더링 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 브라우저의 렌더링 과정</h1>\n<ol>\n<li>브라우저는 html,css,js,이미지,폰트 파일등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.</li>\n<li>브라우저의 렌더링 엔진은 서버로부터 응답된 html과 css를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합한 렌더 트리를 생성한다.</li>\n<li>브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.</li>\n<li>렌더 트리를 기반으로 html 요소의 레이아웃을 계산하고 브라우저 화면에 html 요소를 페인팅한다.</li>\n</ol>\n<h1 id=\"2-dom\" style=\"position:relative;\"><a href=\"#2-dom\" aria-label=\"2 dom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. DOM</h1>\n<p>HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다. 노드 객체들로 구성된 트리 자료구조를 <code class=\"language-text\">DOM(Document Object Model)</code> 이라 한다. 노드 객체의 트리로 구조화되어 있기 때문에 DOM을 DOM트리 라고 부른다.</p>\n<p><img src=\"/domtree.png\" alt=\"domtree\"></p>\n<p>DOM 컬렉션 객체인 HTMLCollection과 NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체다. HTMLCollection은 언제나 live 객체로 동작하고 NodeList는 대부분 non-live 객체로 동작한다.</p>\n<h3 id=\"2-1-dom-조작\" style=\"position:relative;\"><a href=\"#2-1-dom-%EC%A1%B0%EC%9E%91\" aria-label=\"2 1 dom 조작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. DOM 조작</h3>\n<p>DOM 조작은 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는것이다. DOM에 새로운 노드가 추가되거나 삭제되면 리플로우, 리페인트가 발생하므로 성능에 영향을 준다. 따라서 복잡한 DOM 조작은 주의해서 사용해야 한다.</p>\n<h4 id=\"innerhtml\" style=\"position:relative;\"><a href=\"#innerhtml\" aria-label=\"innerhtml permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>innerHTML</h4>\n<table>\n<thead>\n<tr>\n<th>장점</th>\n<th>단점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DOM 조작 방식에 비해 빠르고 간편하다.</td>\n<td>XSS 공격에 취약하다.</td>\n</tr>\n<tr>\n<td>간편하게 문자열로 정의한 여러 요소를 DOM에 추가할 수 있다.</td>\n<td>해당 요소의 내용을 덮어쓴다.(=HTML을 다시 파싱한다.)</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"dom-조작방식\" style=\"position:relative;\"><a href=\"#dom-%EC%A1%B0%EC%9E%91%EB%B0%A9%EC%8B%9D\" aria-label=\"dom 조작방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM 조작방식</h4>\n<table>\n<thead>\n<tr>\n<th>장점</th>\n<th>단점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>특정 노드 한개를 DOM에 추가할때 적합하다.</td>\n<td>innerHTML보다 느리고 더 많은 코드가 필요하다.</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"insertadjacenthtml\" style=\"position:relative;\"><a href=\"#insertadjacenthtml\" aria-label=\"insertadjacenthtml permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>insertAdjacentHTML()</h5>\n<table>\n<thead>\n<tr>\n<th>장점</th>\n<th>단점</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>간편하게 문자열로 정의된 여러 요소를 DOM에 추가할 수 있다.</td>\n<td>XSS 공격에 취약하다.</td>\n</tr>\n</tbody>\n</table>","frontmatter":{"date":"March 22, 2022","title":"38~39. 브라우저의 렌더링 과정, DOM","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/38.브라우저의 렌더링/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/자바스크립트/37.Set과 Map/","nextSlug":"/자바스크립트/36.디스트럭쳐링 할당/","prevSlug":"/자바스크립트/38.브라우저의 렌더링/"}},"staticQueryHashes":["1073350324","2938748437"]}