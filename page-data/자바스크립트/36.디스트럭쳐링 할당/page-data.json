{"componentChunkName":"component---src-templates-blog-template-js","path":"/자바스크립트/36.디스트럭쳐링 할당/","result":{"data":{"cur":{"id":"a4963989-15b9-5b81-a9d5-0441120de10c","html":"<p>디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.</p>\n<h1 id=\"1-배열-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#1-%EB%B0%B0%EC%97%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"1 배열 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 배열 디스트럭처링 할당</h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arr = [1, 2, 3];\n\nconst [one, two, three] = arr;\nconsole.log(one, two, three); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다.</p>\n<p>배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가\n반드시 일치할 필요는 없다.</p>\n<p>배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, y] = [1,2];\nconst [x, y]; // SyntaxError\nconst [a, b] = {}; // TypeError\n\nconst [c, d] = [1];\nconsole.log(c, d); // 1 undefined;\n\nconst [e, f] = [1,2,3];\nconsole.log(e, f); // 1 2\n\nconst [a, b , c = 3] = [1,2];\nconsole.log(a, b, c); // 1 2 3\n\nconst [e,f = 10, g = 3] = [1, 2];\nconsole.log(e, f, g); // 1 2 3</code></pre></div>\n<p>배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 <code class=\"language-text\">Rest 요소</code> …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const [x, ...y] = [1, 2, 3];\nconsole.log(x, y); // 1 [2, 3]</code></pre></div>\n<h1 id=\"2-객체-디스트럭처링-할당\" style=\"position:relative;\"><a href=\"#2-%EA%B0%9D%EC%B2%B4-%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81-%ED%95%A0%EB%8B%B9\" aria-label=\"2 객체 디스트럭처링 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 객체 디스트럭처링 할당</h1>\n<p>객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 순서는 의미가 없으며 선언된 변수이름과 프로퍼티 키가 일치하면 할당된다.</p>\n<p>객체 디스트럭처링 할당을 위해서는 변수를 객체 리터럴 형태로 선언해야 한다. 이때 우변에 객체 또는 객체로 평가될 수 있는 표현식을 할당하지 않으면 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { lastName, firstName } = { firstName:'Ungmo', lastName: 'Lee' };</code></pre></div>\n<p>객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 아래와 같이 변수를 선언한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const user = { firstName: 'Ungmo', lastName: 'Lee' };\n\nconst { lastName: ln, firstName: fn } = user;\nconsole.log(fn,ln); // Ungmo Lee</code></pre></div>\n<p>객체 디스트럭처링은 변수에 기본값을 설정할 수 있다. 또한 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { firstName = 'Ungmo', lastName } = { lastName: 'Lee' };\nconsole.log(firstName, lastName); // Ungmo Lee\n\nfunction printTodo(todo) {\n  console.log(`할일 ${todo.content}은 ${todo.completed ? '완료' : '미완료'} 상태입니다.`);\n}\n\nprintTodo({id: 1, content: '설거지', completed: true}); // 할일 설거지은 완료 상태입니다.</code></pre></div>\n<p>배열의 요소가 객체인 경우에 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const todos = [\n  {\n    id: 1, content: 'HTML', completed: true\n  },\n  {\n    id: 2, content: 'CSS', completed: false\n  },\n  {\n    id: 3, content: 'JS', completed: false\n  }\n];\n\n// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만 추출\nconst [, { id }] = todos;\nconsole.log(id); // 2\n\n// 중첩 객체\nconst user = {\n  name: 'Lee',\n  address: {\n    zipCode: '03068',\n    city: 'Seoul'\n  }\n};\n\n// address 프로퍼티 키로 객체를 추출하고 이 객체의 city 프로퍼티 키로 값을 추출\nconst { address: { city } } = user;\nconsole.log(city); // Seoul</code></pre></div>\n<p>객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터나 Rest 요소와 유사하게 <code class=\"language-text\">Rest 프로퍼티 ...</code> 을 사용할 수 있다.\nRest 프로퍼티는 Rest 파라미터나 Rest 요소와 맟나가지로 반드시 마지막에 위치해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const { x, ...rest } = { x: 1, y: 2, z: 3};\nconsole.log(x, rest); // 1 {y: 2, z: 3}</code></pre></div>","excerpt":"디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 1. 배열 디스트럭처링 할당 배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다. 배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가\n반드시 일치할 필요는 없다. 배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다. 배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게  …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. 2. 객체 디스트럭처링 할당 객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 …","frontmatter":{"date":"March 12, 2022","title":"36. 디스트럭처링 할당","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/36.디스트럭쳐링 할당/"}},"next":{"id":"c29e1877-7e91-52ca-849e-7c518cd1b379","html":"<p>ES6에서 도입된 스프레드 문법(spread syntax)는 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for … of 문으로 순회할 수 있는 이터러블에 한정된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(...[1,2,3]); // 1 2 3\nconsole.log(...'Hello'); // H e l l o</code></pre></div>\n<p>스프레드 문법의 결과는 값이 아니다. 따라서 스프레드 문법의 결과는 변수에 할당 할 수 없다. 스프레드 문법의 결과물은 값으로 사용할 수 없고, 쉼표로 구분한 값의 목록을 사용하는 문백에서만 사용할 수 있다.</p>\n<ul>\n<li>함수 호출문의 인수 목록</li>\n<li>배열 리터럴의 요소 목록</li>\n<li>객체 리터럴의 프로퍼티 목록</li>\n</ul>\n<h1 id=\"1-함수-호출문의-인수-목록\" style=\"position:relative;\"><a href=\"#1-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EB%AC%B8%EC%9D%98-%EC%9D%B8%EC%88%98-%EB%AA%A9%EB%A1%9D\" aria-label=\"1 함수 호출문의 인수 목록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 함수 호출문의 인수 목록</h1>\n<p>Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 만약 Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할수 없으므로 NaN을 반환한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Math.max([1,2,3]); // NaN</code></pre></div>\n<p>스프레드 문법 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달하고 싶은 경우 Function.prototype.apply를 사용했다</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var arr = [1,2,3];\nvar max = Math.max.apply(null, arr); // 3\n\nconst arr = [1,2,3];\nconst max = Math.max(...arr); // 3</code></pre></div>\n<h1 id=\"2-배열-리터럴-내부에서-사용하는-경우\" style=\"position:relative;\"><a href=\"#2-%EB%B0%B0%EC%97%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"2 배열 리터럴 내부에서 사용하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 배열 리터럴 내부에서 사용하는 경우</h1>\n<h3 id=\"2-1-concat\" style=\"position:relative;\"><a href=\"#2-1-concat\" aria-label=\"2 1 concat permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. concat</h3>\n<p>2개의 배열을 1개의 배열로 결합하고 싶은 경우 concat 메서드를 사용했지만 스프레드 문법을 사용하면 별도의 메서드를 사용하지 않고 결합할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var arr = [1,2].concat([3,4]);\nconsole.log(arr); // [1,2,3,4]\n\n//ES6\nconst arr = [...[1,2], ...[3,4]];\nconsole.log(arr); // [1,2,3,4]</code></pre></div>\n<h3 id=\"2-2-splice\" style=\"position:relative;\"><a href=\"#2-2-splice\" aria-label=\"2 2 splice permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. splice</h3>\n<p>배열의 중간에 다른 배열의 요소를 추가하거나 제거하려면 splice 메서드를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5\nvar arr1 = [1,4];\nvar arr2 = [2,3];\n\nArray.prototype.splice.apply(arr1, [1,0].concat(arr2));\nconsole.log(arr1); // [1,2,3,4]\n\n//ES6\n\nconst arr1 = [1,4];\nconst arr2 = [2,3];\n\narr1.splice(1, 0, ... arr2);\nconsole.log(arr1); // [1,2,3,4]</code></pre></div>\n<h3 id=\"2-3-배열-복사\" style=\"position:relative;\"><a href=\"#2-3-%EB%B0%B0%EC%97%B4-%EB%B3%B5%EC%82%AC\" aria-label=\"2 3 배열 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-3. 배열 복사</h3>\n<p>배열을 복사하려면 slice 메서드를 사용한다. 이 때 원본 배열의 각 요소를 얕은 복사하여 새로운 복사본을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5\nvar origin = [1,2];\nvar copy = origin.slice();\n\n//ES6\nconst origin [1,2];\nconst copy = [...orign];</code></pre></div>\n<h3 id=\"2-4-이터러블을-배열로-변환\" style=\"position:relative;\"><a href=\"#2-4-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98\" aria-label=\"2 4 이터러블을 배열로 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-4. 이터러블을 배열로 변환</h3>\n<p>이터러블을 배열로 변환하려면 Function.prototype.apply 또는 Function.prototype.call 메서드를 사용하여 slice 메서드를 호출해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//ES5\nfunction sum() {\n  var args = Array.prototype.slice.call(arguments);\n\n  return args.reduce(function (pre, cur) {\n    return pre+cur;\n  }, 0);\n}\nconsole.log(sum(1,2,3)); // 6\n\n//ES6\nfunction sum() {\n  return [...arguments].reduce((pre,cur) => pre + cur, 0);\n}\n\nconsole.log(sum(1,2,3)); // 6\n\n// Rest 파라미터\nconst sum = (...args) => args.reduce((pre, cur) => pre + cur ,0);</code></pre></div>\n<p><strong>단 이터러블이 아닌 유사 배열 객체는 스프레드 문법의 대상이 될 수 없다.</strong> 이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 Array.from 메서드를 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const arrayLike = {\n  0: 1,\n  1: 2,\n  2: 3,\n  length: 3\n}\nArray.from(arrayLike); // [1,2,3]</code></pre></div>\n<h1 id=\"3-객체-리터럴-내부에서-사용하는-경우\" style=\"position:relative;\"><a href=\"#3-%EA%B0%9D%EC%B2%B4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"3 객체 리터럴 내부에서 사용하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 객체 리터럴 내부에서 사용하는 경우</h1>\n<p>스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const obj = {x: 1, y: 2};\nconst copy = {...obj};\nconsole.log(copy); // {x: 1, y: 2}\n\nconst merged = {x: 1, y:2, ...{a: 3, b: 4}};\nconsole.log(merged); // {x: 1, y: 2, a: 3, b: 4}</code></pre></div>\n<p>스프레드 프로퍼티가 제안되기 전에는 Object.assign 메서드를 사용하여 여러개의 객체를 병합하거나 특정 프로퍼티를 변경, 추가했다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 프로퍼티가 중복되는 경우 뒤에 위치한 프로퍼티가 우선권을 갖는다.\nconst merged = Object.assign({}, {x: 1, y: 2},{y: 10, z: 3});\nconsole.log(merged) // {x: 1, y: 10, z: 3}</code></pre></div>","frontmatter":{"date":"February 26, 2022","title":"35. 스프레드 문법","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/35.스프레드 문법/"}},"prev":{"id":"d2471fce-cd59-5b76-9c12-ad1c66138df0","html":"<h1 id=\"1-set\" style=\"position:relative;\"><a href=\"#1-set\" aria-label=\"1 set permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Set</h1>\n<p>Set 객체는 <code class=\"language-text\">중복되지 않는</code> 유일한 값들의 집합이다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>배열</th>\n<th>Set 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>동일한 값을 중복하여 포함할 수 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>요소 순서에 의미가 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>인덱스로 요소에 접근할 수 있다.</td>\n<td>O</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<p>Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const set = new Set([1, 2, 3, 3]);\nconsole.log(set); // Set(3) {1,2,3}</code></pre></div>\n<h1 id=\"2-set-객체-메서드\" style=\"position:relative;\"><a href=\"#2-set-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"2 set 객체 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Set 객체 메서드</h1>\n<p>Set 객체의 요소 개수를 확인할때는 <code class=\"language-text\">Set.prototype.size</code> 프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const set = new Set[1, 2, 3, 3]);\nconsole.log(set.size); //\n\nset.size = 10; // 무시됨</code></pre></div>\n<p>Set 객체에 요소를 추가할 때는 <code class=\"language-text\">Set.prototype.add</code> 메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다.</p>\n<p>Set 객체에 특정 요소가 존재하는지 확인하려면 <code class=\"language-text\">Set.prototype.has</code> 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.</p>\n<p>Set 객체의 특정 요소를 삭제하려면 <code class=\"language-text\">Set.prototype.delete</code> 메서드를 사용한다 delete 메서드는 불리언 값을 반환한다.</p>\n<p>Set 객체의 모든 요소를 일괄 삭제하려면 <code class=\"language-text\">Set.prototype.clear</code> 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다.</p>\n<p>Set 객체의 요소를 순회하려면 <code class=\"language-text\">Set.prototype.forEach</code> 메서드를 사용한다. Set 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 디스트럭처링의 대상이 될 수도 있다.</p>\n<p>Set 객체는 수학적 집합을 구현하기 위한 자료구조이다. 따라서 Set 객체를 통해 교집합, 합집합, 차집합등을 구현할 수 있다.</p>\n<h1 id=\"3-map\" style=\"position:relative;\"><a href=\"#3-map\" aria-label=\"3 map permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Map</h1>\n<p>Map 객체는 <code class=\"language-text\">키와 값의 쌍</code>으로 이루어진 컬렉션이다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>객체</th>\n<th>Map 객체</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>키로 사용할 수 있는 값</td>\n<td>문자열 또는 심벌 값</td>\n<td>객체를 포함한 모든 값</td>\n</tr>\n<tr>\n<td>이터러블</td>\n<td>X</td>\n<td>O</td>\n</tr>\n<tr>\n<td>요수 개수 확인</td>\n<td>Object.keys(obj).length</td>\n<td>map.size</td>\n</tr>\n</tbody>\n</table>\n<p>Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되느 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.</p>\n<p>Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const map = new Map([['key1', 'value1'], ['key2', 'value2']]);\nconsole.log(map); // {'key1' => 'value1', 'key2' => 'value2'}\n\nconst map = new Map([['key1', 'value1'], ['key1', 'value2']]);\nconsole.log(map); //  {'key1' => 'value2'}</code></pre></div>\n<h1 id=\"4-map-객체-메서드\" style=\"position:relative;\"><a href=\"#4-map-%EA%B0%9D%EC%B2%B4-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"4 map 객체 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Map 객체 메서드</h1>\n<p>Map 객체의 요소 개수를 확인할 때는 <code class=\"language-text\">Map.prototype.size</code> 프로퍼티를 사용한다.</p>\n<p>Map 객체의 요소를 추가할 때는 <code class=\"language-text\">Map.prototype.set</code> 메서드를 사용한다. set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다. 따라서 set 메서드를 연속적으로 호출할 수 있다.</p>\n<p>Map 객체에서 특정 요소를 취득할 때는 <code class=\"language-text\">Map.prototype.get</code> 메서드를 사용한다. get 메서드는 인수로 전달한 키를 갖는 값을 반환하고 인수로 전달한 키를 갖는 요소가 존재하지 않으면 undefined를 반환한다.</p>\n<p>Map 객체에서 특정 요소가 존재하는지 확인하려면 <code class=\"language-text\">Map.prototype.has</code> 메서드를 사용한다. has 메서드는 불리언 값을 반환한다.</p>\n<p>Map 객체의 요소를 삭제하려면 <code class=\"language-text\">Map.prototype.delete</code> 메서드를 사용한다. delete 메서드는 불리언 값을 반환한다.</p>\n<p>Map 객체의 요소를순회하려면 <code class=\"language-text\">Map.prototype.forEach</code> 메서드를 사용한다.</p>\n<ul>\n<li>첫번째 인수 : 현재 순회중인 요소 값</li>\n<li>두번째 인수 : 현재 순회중인 요소 키</li>\n<li>세번째 인수 : 현재 순회중인 Map 객체</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const lee = { name : 'Lee' };\nconst kim = { name : 'Kim' };\n\nconst map = new Map([[lee, 'developer'], [kim, 'designer']]);\n\nmap.forEach((v,k,map) => console.log(v,k,map))</code></pre></div>\n<p>Map 객체는 이터러블이다. 따라서 for … of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.</p>","frontmatter":{"date":"March 18, 2022","title":"37. Set과 Map","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/37.Set과 Map/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/자바스크립트/36.디스트럭쳐링 할당/","nextSlug":"/자바스크립트/35.스프레드 문법/","prevSlug":"/자바스크립트/37.Set과 Map/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}