{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/타입스크립트/0.타입스크립트/",
    "result": {"data":{"cur":{"id":"13dfcfe0-39f0-5ec3-890c-263d9e73092e","html":"<h1 id=\"1-타입스크립트\" style=\"position:relative;\"><a href=\"#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8\" aria-label=\"1 타입스크립트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 타입스크립트</h1>\n<h3 id=\"what--why-\" style=\"position:relative;\"><a href=\"#what--why-\" aria-label=\"what  why  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What &#x26; Why ?</h3>\n<ol>\n<li>\n<p>Typed superset of Javascript</p>\n</li>\n<li>\n<p>Complies down to plain JavaScript</p>\n</li>\n<li>\n<p>Relation to JavaScript</p>\n</li>\n<li>\n<p>Optional static typing and type interface</p>\n</li>\n<li>\n<p>IDE support</p>\n</li>\n<li>\n<p>Rapid growth and use</p>\n</li>\n</ol>\n<h3 id=\"variable-types\" style=\"position:relative;\"><a href=\"#variable-types\" aria-label=\"variable types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Variable Types</h3>\n<p>타입스크립트가 지원하는 데이터타입은 <code class=\"language-text\">number</code> <code class=\"language-text\">string</code> <code class=\"language-text\">boolean</code> <code class=\"language-text\">array</code> <code class=\"language-text\">tuple</code> <code class=\"language-text\">enum</code> <code class=\"language-text\">any</code> <code class=\"language-text\">void</code> <code class=\"language-text\">null</code> <code class=\"language-text\">undefined</code> <code class=\"language-text\">never</code> <code class=\"language-text\">object</code> 와 같은것들이 있다.</p>\n<ul>\n<li>number, string, boolean원시데이터 타입 <code class=\"language-text\">number</code> <code class=\"language-text\">string</code> <code class=\"language-text\">boolean</code> 을 명시적으로 설정한 변수 선언은 아래와 같이 작성한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let isBeginner: boolean = true;\nlet total: number = 0;\nlet name: string = 'Vishwas';\nlet sentence: string = `My name is ${name} I am a beginner`;</code></pre></div>\n<ul>\n<li>any : 변수 선언시 어떤 타입을 할당해야 할지 알지 못할경우 어떤 타입도 할당 가능하도록 <code class=\"language-text\">any</code> 를 설정할 수 있다. 변수 선언과 초기화 과정에서 값을 할당하지 않으면 암묵적으로 <code class=\"language-text\">any</code> 타입이 지정된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let value: any = 100;\nvalue = true;\n\nlet value;\nvalue = false;\nvalue = 'nono';</code></pre></div>\n<ul>\n<li>array : 타입스크립트에서 <code class=\"language-text\">array</code> 을 선언하는 방법은 아래와 같이 작성한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let list1: number[] = [1, 2, 3]; // 숫자만 허용\nlet list2: Array&lt;number> = [1, 2, 3]; // 숫자만 허용\nlet selects: (number | string)[] = [102, 'o']; // 특정 데이터 타입만 허용</code></pre></div>\n<ul>\n<li>tuple : <code class=\"language-text\">tuple</code> 은 배열타입을 보다 특수한 형태로 사용할 수 있는 타입이다. <code class=\"language-text\">tuple</code>에 명시적으로 지정된 형식에 따라 순서를 설정해야한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let person: [string, number] = ['kim', 12];</code></pre></div>\n<ul>\n<li>enum : <code class=\"language-text\">enum</code> 은 열거형 데이터 타입이다. 멤버라 불리는 값의 집합을 이루는 자료형이다. 기억하기 어려운 숫자나 문자대신 이름으로 접근할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">enum Color {\n  Red,\n  Blue,\n  Green,\n}\n\nlet green: number = Color.Green; // 2\n\nenum Color {\n  Red,\n  Blue = 7,\n  Green,\n}\n\nlet green: number = Color.Green; // 8</code></pre></div>\n<ul>\n<li>null,undefined : <code class=\"language-text\">null</code> <code class=\"language-text\">undefined</code> 은 각각 하나의 타입으로 처리되며 아래와 같이 사용할 수 있다. <code class=\"language-text\">null</code> 로 타입이 설정된 변수에 <code class=\"language-text\">null</code> 값이 아닌 값이 할당되면 오류를 출력한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let myNull: null = null;\nlet myUndefined: undefined = undefined;</code></pre></div>\n<p><code class=\"language-text\">tsconfig.json</code> 에서 strickNullChecks가 true로 설정되어 있으면 모든 데이터 타입은 null, undefined을 할당받을 수 없다. 이를 해결 하기 위해서는 <code class=\"language-text\">any</code> 또는 <code class=\"language-text\">|</code> 을 이용해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let myName: string | null = null;\nif (!myName) myName = 'kim';</code></pre></div>\n<ul>\n<li>never : <code class=\"language-text\">never</code> 는 일반적으로 함수의 리턴 타입으로 사용된다. 함수의 리턴타입을 <code class=\"language-text\">never</code> 가 사용될 경우 항상 오류를 출력하거나 리턴값을 절대로 내보내지 않음을 뜻한다. 즉 무한루프와 같다.</li>\n</ul>\n<p><code class=\"language-text\">never</code> 타입을 지정한 변수에 다른타입은 할당할 수 없다.</p>\n<h3 id=\"functions\" style=\"position:relative;\"><a href=\"#functions\" aria-label=\"functions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functions</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function add(num1: number,num2: number) {\n\treturn num1 + num2;\n}\n\nadd(5,10);\nadd(5,'10'); // error</code></pre></div>\n<p>타입스크립트는 모든 파라미터가 함수에 전달되어야 한다고 가정한다. 따라서 함수를 실행할 때 매개변수의 숫자와 함수의 파라미터의 수가 일치해야 한다. 이때 파라미터 변수 뒤에 <code class=\"language-text\">?</code> 를붙이면 Optional을 사용할 수 있다.</p>\n<p><code class=\"language-text\">?</code> 는 매개변수의 값이 있을수도 있고 없을수도 있는 상황에서 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function add(num1: number, num2?: number) {\n\tif(num2) return num1+num2;\n\telse return num1;\n}</code></pre></div>\n<h3 id=\"interface\" style=\"position:relative;\"><a href=\"#interface\" aria-label=\"interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interface</h3>\n<p><code class=\"language-text\">interface</code> 는 변수의 타입으로 사용할 수 있다. 이 때 인터페이스를 타입으로 선언한 변수는 interface를 준수해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Todo {\n\tid: number;\n\tcontent: string;\n\tcompleted: boolean;\n}\n\nlet todo:Todo;\n\ntodo = {id:1, content: 'ts', completed: false};\n\nlet todos: Todo[] = [];\nfunction addTodo(todo: Todo) {\n\ttodos = [...todos, todo];\n}\n\nconst newTodo: Todo = {id:1, content: 'ts', completed: false};\naddTodo(newTodo)</code></pre></div>\n<h3 id=\"class\" style=\"position:relative;\"><a href=\"#class\" aria-label=\"class permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class</h3>\n<p>타입스크립트의 클래스는 접근제어자를 설정할 수 있다.</p>\n<p><code class=\"language-text\">public</code> : 클래스 외부에서 접근 가능 (기본값)</p>\n<p><code class=\"language-text\">private</code> : 클래스 내부에서만 접근 가능</p>\n<p><code class=\"language-text\">protected</code> : 자신 클래스를 포함한 서브클래스에서만 접근 가능</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Employee {\n\temployeeName: string;\n\n\tconstructor(name: string) {\n\t\tthis.employeeName = name;\n\t}\n\n\tgreet() {\n\t\tconsole.log(`Good Morning ${this.employeeName}`);\n\t}\n}\n\nlet emp1 = new Employee('Kim'); // Kim\nemp1.greet() // Good Moring Kim</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Manager extends Employee {\n    constructor(managerName: string) {\n        super(managerName);\n    }\n\n    delegateWork() {\n        console.log(`Manager delegation tasks`)\n    }\n}\n\nlet m1 = new Manager('Lee');\nm1.delegateWork(); // Manager delegation tasks\nm1.greet(); // Good Morning Lee\nconsole.log(m1.employeeName) // Lee</code></pre></div>","excerpt":"1. 타입스크립트 What & Why ? Typed superset of Javascript Complies down to plain JavaScript Relation to JavaScript Optional static typing and type interface IDE support Rapid growth and use Variable Types 타입스크립트가 지원하는 데이터타입은             와 같은것들이 있다. number, string, boolean원시데이터 타입    을 명시적으로 설정한 변수 선언은 아래와 같이 작성한다. any : 변수 선언시 어떤 타입을 할당해야 할지 알지 못할경우 어떤 타입도 할당 가능하도록  를 설정할 수 있다. 변수 선언과 초기화 과정에서 값을 할당하지 않으면 암묵적으로  타입이 지정된다. array : 타입스크립트에서  을 선언하는 방법은 아래와 같이 작성한다. tuple :  은 배열타입을 보다 특수한 형태로 사용할 수 있는 …","frontmatter":{"date":"April 13, 2022","title":"00. 타입스크립트","categories":"typescript","author":"sangzun","emoji":null},"fields":{"slug":"/타입스크립트/0.타입스크립트/"}},"next":{"id":"7cf5fbb4-591c-5621-8bee-1233f46bc1e9","html":"<h1 id=\"1-이벤트\" style=\"position:relative;\"><a href=\"#1-%EC%9D%B4%EB%B2%A4%ED%8A%B8\" aria-label=\"1 이벤트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 이벤트</h1>\n<p>브라우저는 특정 일이 발생하면 이를 감지하여 이벤트를 발생시킨다. 이벤트가 발생했을 때 호출될 함수를 <code class=\"language-text\">이벤트 핸들러(event handler)</code> 라 하고 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 <code class=\"language-text\">이벤트 핸들러 등록</code> 이라 한다.</p>\n<h1 id=\"2-이벤트-핸들러-등록\" style=\"position:relative;\"><a href=\"#2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EB%93%B1%EB%A1%9D\" aria-label=\"2 이벤트 핸들러 등록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 이벤트 핸들러 등록</h1>\n<p>이벤트 핸들러를 등록하는 방법은 3가지다.</p>\n<h3 id=\"2-1-이벤트-핸들러-어트리뷰트\" style=\"position:relative;\"><a href=\"#2-1-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8\" aria-label=\"2 1 이벤트 핸들러 어트리뷰트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-1. 이벤트 핸들러 어트리뷰트</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!DOCTYPE html>\n&lt;html>\n  &lt;body>\n    &lt;button onclick=\"sayHi('LEE')\">Click&lt;/button>\n  &lt;/body>\n  &lt;script>\n    function sayHi(name) {\n      console.log(`Hi ${name}`);\n    }\n  &lt;/script>\n&lt;/html></code></pre></div>\n<p>HTML과 자바스크립트는 관심사가 다르므로 분리하는것이 좋다. 따라서 이벤트 핸들러 어트리뷰트 방식은 사용하지 않는것이 좋다.</p>\n<h3 id=\"2-2-이벤트-핸들러-프로퍼티-방식\" style=\"position:relative;\"><a href=\"#2-2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EB%B0%A9%EC%8B%9D\" aria-label=\"2 2 이벤트 핸들러 프로퍼티 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2-2. 이벤트 핸들러 프로퍼티 방식</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!DOCTYPE html>\n&lt;html>\n  &lt;body>\n    &lt;button>Click&lt;/button>\n  &lt;/body>\n  &lt;script>\n    const $button = document.querySelector('button');\n    $button.onclick = function () {\n      console.log('click');\n    };\n  &lt;/script>\n&lt;/html></code></pre></div>\n<p>이벤트 핸들러 어트리뷰트 방식도 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 이벤트 핸들러 프로퍼티 방식과 동일하다고 할 수 있다. <code class=\"language-text\">이벤트 핸들러 프러퍼티 방식</code>은 이벤트 핸들러 어트리뷰트 방식의 HTML과 자바스크립트가 혼재되는 문제를 해결할 수 있지만 이벤트 핸들러 프러퍼티에 하나의 이벤트 핸들러만 바인딩 할 수 있다는 단점이 존재한다.</p>\n<h3 id=\"addeventlistener-메서드-방식\" style=\"position:relative;\"><a href=\"#addeventlistener-%EB%A9%94%EC%84%9C%EB%93%9C-%EB%B0%A9%EC%8B%9D\" aria-label=\"addeventlistener 메서드 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>addEventListener 메서드 방식</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!DOCTYPE html>\n&lt;html>\n  &lt;body>\n    &lt;button>Click&lt;/button>\n  &lt;/body>\n  &lt;script>\n    const $button = document.querySelector('button');\n    $button.addEventListener('click', function () {\n      console.log('Click');\n    });\n  &lt;/script>\n&lt;/html></code></pre></div>\n<p>동일한 HTML 요소에서 동일한 이벤트에 대해 <code class=\"language-text\">addEventListener</code>메서드는 하나 이상의 이벤트 핸들러를 등록할 수 있다.</p>\n<h1 id=\"3-이벤트-핸들러-제거\" style=\"position:relative;\"><a href=\"#3-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%9F%AC-%EC%A0%9C%EA%B1%B0\" aria-label=\"3 이벤트 핸들러 제거 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 이벤트 핸들러 제거</h1>\n<p><code class=\"language-text\">addEventListener</code> 메서드르 등록한 이벤트 핸들러를 제거하려면 <code class=\"language-text\">removeEventListener</code>메서드를 사용한다. 단 addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에 전달한 인수가 일치해야 한다. 따라서 무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.</p>\n<p>또한 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 removeEventListener로 제거할 수 없다 제거하려면 이벤트 핸들러 프로퍼티에 null을 할당해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!DOCTYPE html>\n&lt;html>\n  &lt;body>\n    &lt;button>Click&lt;/button>\n  &lt;/body>\n  &lt;script>\n    const $button = document.querySelector('button');\n    const handleClick = () => {\n      console.log('Click');\n    };\n    $button.onclick = null;\n  &lt;/script>\n&lt;/html></code></pre></div>\n<h1 id=\"4-이벤트-객체\" style=\"position:relative;\"><a href=\"#4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B0%9D%EC%B2%B4\" aria-label=\"4 이벤트 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 이벤트 객체</h1>\n<p>이벤트가 발생하면 이벤트에 관련된 정보를 담고 있는 이벤트 객체가 동적으로 생성되며 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.</p>\n<p>이벤트 핸들러 어트리뷰트 방식의 경우 이벤트 객체를 전달받으려면 이벤트 핸들러의 첫번째 매개변수는 반드시 event여야 한다.</p>\n<p><img src=\"/onclick.png\" alt=\"onclick\"></p>\n<h1 id=\"5이벤트-전파\" style=\"position:relative;\"><a href=\"#5%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%A0%84%ED%8C%8C\" aria-label=\"5이벤트 전파 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5.이벤트 전파</h1>\n<p>DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 <code class=\"language-text\">이벤트 전파(event propagation</code>라고 한다.</p>\n<ul>\n<li>캡쳐링 단계(capturing phase) : 이벤트가 상위 요소에서 하위 요소 방향으로 전파</li>\n<li>타깃 단계(target phase) : 이벤트가 이벤트 타깃에 도달</li>\n<li>버블링 단계(bubbling phase) : 이벤트가 하위 요소에서 상위 요소 방향으로 전파</li>\n</ul>\n<p>이벤트 핸들러 어트리뷰트/프러퍼티 방식으로 등록한 이벤트는 타깃단계와 버블링 단계의 이벤트만 캐치 할수 있다. 하지만 addEventListener 메서드 방식으로 등록한 이벤트 핸들러는 3번째 인수로 true를 전달하면 캡쳐링 단계의 이벤트도 캐치할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;!DOCTYPE html>\n&lt;html>\n  &lt;body>\n    &lt;ul id=\"fruits\">\n      &lt;li id=\"apple\">Apple&lt;/li>\n      &lt;li id=\"banana\">Banana&lt;/li>\n      &lt;li id=\"orange\">Orange&lt;/li>\n    &lt;/ul>\n    &lt;script>\n      const $fruits = document.getElementById('fruits');\n      const $banana = document.getElementById('banana');\n\n      // 캡처링 단계의 이벤트를 캐치한다.\n      $fruits.addEventListener(\n        'click',\n        (e) => {\n          console.log(`이벤트 단계: ${e.eventPhase}`); // 1: 캡처링 단계\n          console.log(`이벤트 타깃: ${e.target}`);\n          console.log(`커런트 타깃: ${e.currentTarget}`);\n        },\n        true,\n      );\n\n      // 타깃 단계의 이벤트를 캐치한다.\n      $banana.addEventListener('click', (e) => {\n        console.log(`이벤트 단계: ${e.eventPhase}`); // 2: 타깃 단계\n        console.log(`이벤트 타깃: ${e.target}`);\n        console.log(`커런트 타깃: ${e.currentTarget}`);\n      });\n\n      // 버블링 단계의 이벤트를 캐치한다.\n      $fruits.addEventListener('click', (e) => {\n        console.log(`이벤트 단계: ${e.eventPhase}`); // 3: 버블링 단계\n        console.log(`이벤트 타깃: ${e.target}`);\n        console.log(`커런트 타깃: ${e.currentTarget}`);\n      });\n    &lt;/script>\n  &lt;/body>\n&lt;/html></code></pre></div>\n<p><code class=\"language-text\">이벤트는 이벤트를 발생시킨 이벤트 타킷은 물론 상위 DOM 요소에서도 캐치 할 수 있다.</code> 대부분의 이벤트는 캡처링과 버블링을 통해 전파된다. 하지만 몇개의 이벤트는 버블링을 통해 전파되지 않는다.</p>\n<ul>\n<li>foucs/blur</li>\n<li>load/unload/abort/error</li>\n<li>mouseenter/mouseleave</li>\n</ul>\n<p>위 이벤트는 버블링 되지 않으므로 이벤트 타깃의 상위 요소에서 위 이벤트를 캐치하려면 캡쳐링 단계의 이벤트를 캐치해야 한다. 만약 상위 요소에서 캐치 해야한다면 focusin/focusout, mouseover/mouseout으로 대체할 수 있다.</p>\n<h1 id=\"6이벤트-위임\" style=\"position:relative;\"><a href=\"#6%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84\" aria-label=\"6이벤트 위임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6.이벤트 위임</h1>\n<p>이벤트 위임은 여러개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소애 이벤트 핸들러를 등록하는 방법을 말한다.</p>\n<p>이벤트 위임을 통해 하위 DOM 요소에서 발생한 이벤트를 처리할 때는 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트를 실제로 발생시킨 DOM 요소가 기대한 DOM 요소가 아닐 수도 있다. 따라서 이벤트에 반응이 필요한 DOM 요소에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function activate({ target }) {\n  // 이벤트를 발생시킨 요소(target)이 ul#fruits의 자식 요소가 아니라면 무시한다.\n  if (!target.matches('#fruits > li')) return;</code></pre></div>\n<h1 id=\"7-dom-요소의-기본동작-조작\" style=\"position:relative;\"><a href=\"#7-dom-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B8%B0%EB%B3%B8%EB%8F%99%EC%9E%91-%EC%A1%B0%EC%9E%91\" aria-label=\"7 dom 요소의 기본동작 조작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. DOM 요소의 기본동작 조작</h1>\n<p>DOM 요소는 저마다 기본동작이 있다. a 요소는 href 어트리뷰트에 지정된 링크로 이동하고 checkbox, radio요소는 클릭하면 체크 또는 해제 된다. <code class=\"language-text\">preventDefault</code>메서드는 이러한 DOM 요소의 기본 동작을 중단시킨다.</p>\n<p>어느 한 요소를 이용하여 이벤트를 처리한 후 이벤트가 부모 요소로 이벤트가 전파되는 것을 중단시키기 위해서는 <code class=\"language-text\">stopPropagation</code>메서드를 이용한다.</p>","frontmatter":{"date":"March 25, 2022","title":"40. 이벤트","categories":"javascript","author":"sangzun","emoji":null},"fields":{"slug":"/자바스크립트/40.이벤트/"}},"prev":{"id":"9b824f58-3eb0-58e8-848a-b8719a71044c","html":"<h1 id=\"타입스크립트-vs-자바스크립트\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-vs-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8\" aria-label=\"타입스크립트 vs 자바스크립트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입스크립트 vs 자바스크립트</h1>\n<p>모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 반대는 성립하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function greet(who: string) {\n  console.log(\"Hello\", who);\n}</code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">string</code>은 타입스크립트에서 쓰이는 타입 구문이다. 따라서 자바스크립트에서는 오류를 출력한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let city = \"new york city\";\nconsole.log(city.toUppercase());</code></pre></div>\n<p>위 코드에서 타입 구문이 없지만 타입 체커는 문제점을 찾아낸다. city 변수가 문자열이라는 것을 알려주지 않아도 타입스크립트는 초기값으로부터 타입을 추론한다.</p>\n<p>또한 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다. 하지만 모든 오류를 찾지는 못한다. 타입 체커를 통과해도 오류를 발생시키는 코드는 충분히 존재할 수 있다.</p>\n<h1 id=\"1-타입스크립트-설정\" style=\"position:relative;\"><a href=\"#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95\" aria-label=\"1 타입스크립트 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 타입스크립트 설정</h1>\n<p>타입스크립트 컴파일러는 많은 설정을 가지고 있다. <code class=\"language-text\">tsconfing.json</code>파일을 통해서 설정하거나 커맨드라인에서 사용할 수 있다.</p>\n<p>설정을 사용하기 위해서는 <code class=\"language-text\">noImplicitAny</code>와 <code class=\"language-text\">strictNullChecks</code>를 이해해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function add(x,y) {\n  return a+b;\n}\n\nfunction add(x:nubmer, y:number) {\n  return x+y;\n}</code></pre></div>\n<p><code class=\"language-text\">noImplicitAny</code>는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 판단한다. noImplicitAny가 해제되어 있을때 위의 첫번째 코드는 유효하다.</p>\n<p>타입스크립트는 타입 정보를 가질때 효과적인인 언어기 때문에 noImplicitAny를 설정하는것이 좋다.</p>\n<p><code class=\"language-text\">strictNullChecks</code>는 null과 undefined을 모든 타입에서 허용되는지 여부를 설정한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x: number = null;</code></pre></div>\n<p>strictNullChecks가 해제되었다면 위의 코드는 유효한 값이지만 strictNullChecks를 설정하면 오류가된다.</p>\n<h1 id=\"2-코드-생성과-타입\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85\" aria-label=\"2 코드 생성과 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드 생성과 타입</h1>\n<ul>\n<li>코드 생성은 타입 시스템과 무관하다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.</li>\n<li>타입오류가 존재하더라도 컴파일은 가능하다.</li>\n<li>타입스크립트 타입은 런타임에 사용할 수 없다. 런타임에 타입을 지정하려면 타입 정보 유지를 위한 별도의 방법이 필요하며 일반적으로는 태그된 유니온과 속성 체크 방법을 사용한다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 속성 체크 방법\ninterface Square {\n    width: number;\n}\n\ninterface Retangle extends Square {\n    height: number;\n}\n\ntype Shape = Square | Retangle;\n\nfunction calculateArea(shape:Shape) {\n    if ('height' in shape) {\n        shape;\n        return shape.width * shape.height;\n    } else {\n        shape;\n        return shape.width * shape.width;\n    }\n}\n\n// 태그된 유니온\ninterface Square {\n    kind: 'square';\n    width: number;\n\n}\n\ninterface Retangle {\n    kind: 'retangle';\n    height: number;\n    width: number;\n\n}\n\ntype Shape = Square | Retangle;\n\nfunction calculateArea(shape: Shape) {\n    if (shape.kind === 'retangle') {\n        shape;\n        return shape.width * shape.height;\n    } else {\n        shape;\n        return shape.width * shape.width;\n    }\n}</code></pre></div>\n<h1 id=\"3-구조적-타이핑\" style=\"position:relative;\"><a href=\"#3-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91\" aria-label=\"3 구조적 타이핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 구조적 타이핑</h1>\n<p><code class=\"language-text\">duck typing</code> : 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는것으로 간주하는 방식</p>\n<p>자바스크립트는 덕타이핑 기반이다. 어떤 함수의 매개변수 값이 모두 제대로 주어진다면 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Vector2D {\n  x: number;\n  y: number;\n}\n\ninterface NamedVector {\n  name: string;\n  x: number;\n  y: number;\n}\n\nfunction calculateLength(v: Vector2D) {\n  return Math.sqrt(v.x * v.x + v.y * v.y);\n}\n\nconst v: NamedVector = {x: 3, y: 4, name: 'Zee' };\ncalculateLength(v); //5</code></pre></div>\n<p>위 코드에서 NamedVector의 구조가 Vector2D와 호환되기 때문에 calculateLength 호출이 가능하다. 즉 타입스크립트 타입시스템은 <code class=\"language-text\">구조적으로</code>타입이 맞기만 한다면 이를 허용한다 이것이 구조적 타이핑이다.</p>\n<ul>\n<li>자바스크립트는 덕타이핑 기반이고 타입스크립트는 구조적 타이핑을 사용한다.</li>\n<li>타입은 <code class=\"language-text\">봉인</code> 되어 있지 않다.</li>\n<li>클래스 또한 구조적 타이핑을 따르고 있으므로 클래스의 인스턴스가 예상과 다를 수 있다.</li>\n<li>구조적 타이핑은 유닛테스트시에 유용하다.</li>\n</ul>\n<h1 id=\"4-any-타입-지양\" style=\"position:relative;\"><a href=\"#4-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91\" aria-label=\"4 any 타입 지양 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. any 타입 지양</h1>\n<p>타입스크립트의 타입 시스템은 <code class=\"language-text\">gradual</code>이고 <code class=\"language-text\">optional</code>이다. 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다. 이것들의 핵심은 <code class=\"language-text\">any</code>다.</p>\n<ul>\n<li><code class=\"language-text\">any</code>타입을 사용하면 타입체커와 타입스크립트의 여러가지 서비스를 무력화시킨다. any타입은 문제점을 감추고 타입 시스템의 신뢰도를 떨어뜨린다. 사용을 자제하는것이 좋다.</li>\n</ul>","frontmatter":{"date":"April 15, 2022","title":"01. 타입스크립트 알아보기","categories":"typescript","author":"sangzun","emoji":null},"fields":{"slug":"/타입스크립트/1.타입스크립트 알아보기/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/타입스크립트/0.타입스크립트/","nextSlug":"/자바스크립트/40.이벤트/","prevSlug":"/타입스크립트/1.타입스크립트 알아보기/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}