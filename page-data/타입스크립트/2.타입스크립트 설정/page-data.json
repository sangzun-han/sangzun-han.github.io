{"componentChunkName":"component---src-templates-blog-template-js","path":"/타입스크립트/2.타입스크립트 설정/","result":{"data":{"cur":{"id":"d1e24eca-7eaf-5bd1-b5de-f75d2b231593","html":"<h1 id=\"1-타입은-값들의-집합\" style=\"position:relative;\"><a href=\"#1-%ED%83%80%EC%9E%85%EC%9D%80-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9\" aria-label=\"1 타입은 값들의 집합 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 타입은 값들의 집합</h1>\n<p>타입스크립트의 타입은 <code class=\"language-text\">할당 가능한 값들의 집합</code>이다.</p>\n<p><code class=\"language-text\">never</code>타입은 값들이 없는 집합 즉 공집합이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x: never = 12; // error</code></pre></div>\n<p><code class=\"language-text\">unknown</code>은 어떠한 값이든 할당할 수 있는 집합 즉 전체집합이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x: unknown = \"aa\"</code></pre></div>\n<p>그 다음으로 작은 집합은 한가지 값만 포함하는 리터럴타입이다. 두개 혹은 세 개로 묶으려면 <code class=\"language-text\">유니온(union)</code> 타입을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type A = \"A\";\ntype B = \"B\";\ntype Twelve = 12;\ntype AB = \"A\" | \"B\";</code></pre></div>\n<p><code class=\"language-text\">&amp;</code>연산자는 두 타입의 교집합이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {\n  name: string;\n}\n\ninterface Lifespan {\n  birth: Date;\n  death?: Date;\n}\n\ntype PersonSpan = Person &amp; Lifespan;</code></pre></div>\n<p>위 코드를 보면 공통을 가지는 속성이 없기 때문에 <code class=\"language-text\">never</code>타입이 될것같지만 타입 연산자는 인테페이스의 속성이 아닌 타입의 범위에 적용된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다 따라서 Person과 Lifespan을 둘다 가지는 값은 PersonSpan 타입에 속하게 된다.</p>\n<p>따라서 아래의 코드는 정상적으로 작동한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ps: PersonSpan = {\n  name: \"Kim\",\n  birth: new Date('1919/01/01'),\n  death: new Date('1920/02/01'),\n};</code></pre></div>\n<p>조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 사용하는것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {\n  name: string;\n}\n\ninterface PersonSpan extends Person {\n  birth: Date;\n  death?: Date;\n}</code></pre></div>\n<p>즉 A는 B를 상속 = A는 B에 할당 가능 = A는 B의 서브타입 = A는 B의 부분집합 모두 같은 의미이다.</p>\n<h1 id=\"2-타입공간-값공간\" style=\"position:relative;\"><a href=\"#2-%ED%83%80%EC%9E%85%EA%B3%B5%EA%B0%84-%EA%B0%92%EA%B3%B5%EA%B0%84\" aria-label=\"2 타입공간 값공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 타입공간 값공간</h1>\n<p>타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한곳에 존재한다. 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Cylinder {\n  radius: number;\n  height: number;\n}\n\nconst Cylinder = (radius:number, height:number) => ({radius,height});</code></pre></div>\n<p>위 코드에서 inteface Cylinder에서 Cylinder는 타입으로 쓰인다. const Cylinder에서 Cylinder와 이름은 같지만 아무련 관련도 없다. 이런 부분이 가끔 오류를 야기한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function calculateVolumn(shap: unknown) {\n  if (shape instanceof Cylinder) {\n    shape.radius\n  }\n}</code></pre></div>\n<p>위 코드는 instanceof를 이용해서 shape가 Cylinder타입인지 체크하려고 한다. 그러나 instanceof는 자바스크립트의 런타임 연산자이고, 값에 대해서 연산을 한다. 따라서 instanceof Cylinder는 타입이 아니라 함수를 참조한다.</p>\n<ul>\n<li>모든 값은 타입을 가지지만 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.</li>\n<li>class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.</li>\n</ul>\n<h1 id=\"3-타입-단언--타입-선언\" style=\"position:relative;\"><a href=\"#3-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8--%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8\" aria-label=\"3 타입 단언  타입 선언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 타입 단언 &#x3C; 타입 선언</h1>\n<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {name: string};\n\nconst alice: Person = {name: 'Alice'}; // type: Person\nconst bob = {name: 'Bob'} as Person; // type: Person</code></pre></div>\n<p>두 가지 방법은 결과가 같아 보이지만 그렇지 않다. 첫번째 alice는 변수에 <code class=\"language-text\">타입 선언(: Type)</code>을 붙여서 그 값이 선언된 타입을 명시하는것이고 두번째 as Person은 <code class=\"language-text\">타입 단언(as Type)</code>을 수행한다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.</p>\n<p>타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다. 타입 단언은 강제로 타입을 지정했기 때문에 타입체커는 오류를 무시한다.</p>\n<p>화살표 함수에서 타입선언은 단언문을 쓰지 않고 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {name: string};\n\nconst people: Person[] = ['alice', 'bob', 'jan'].map(\n  (name): Person => ({name})\n)</code></pre></div>\n<h1 id=\"4-객체-래퍼-타입-피하기\" style=\"position:relative;\"><a href=\"#4-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-label=\"4 객체 래퍼 타입 피하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 객체 래퍼 타입 피하기</h1>\n<ul>\n<li>기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 쓰인다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.</li>\n<li>타입스크립트 객체 래퍼 타입은 지양하고, 기본형 타입을 사용해야 한다.</li>\n</ul>\n<h1 id=\"5-잉여-속성-체크의-한계\" style=\"position:relative;\"><a href=\"#5-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"5 잉여 속성 체크의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 잉여 속성 체크의 한계</h1>\n<p>타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 타입의 속성이 있는지, 그 외의 속성은 없는지 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {\n  name: string;\n  age: number;\n}\n\nconst kim: Person = {\n  name: 'kim',\n  age: 30,\n  gender: \"male\"\n}</code></pre></div>\n<p>변수에 타입을 선언함과 동시에 오브젝트 리터럴로 만들게 되면 <code class=\"language-text\">잉여 속성 체크</code>된다. 하지만 아래의 코드는 잉여 속성 체크가 되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const kim = {\n  name: 'kim',\n  age: 35,\n  gender: 'male'\n}\n\nconst jun: Person = kim;</code></pre></div>\n<p>정상적으로 jun 변수에 kim이 할당되었고 이 과정에서 잉여 속성 체크는 진행되지 않았다. 잉여 속석 체크는 타입 단언문을 사용할 때도 적용되지 않는다. 따라서 단언문보다 선언문을 사용해야 하는 이유 중 하나이다.</p>\n<p>잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 사용하는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Options {\n  darkMode?: boolean;\n  [otherOptions:string]: unknown;\n}\n\nconst o: Options = {darkMode: true};</code></pre></div>\n<h1 id=\"6-함수-표현식에-타입-적용\" style=\"position:relative;\"><a href=\"#6-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%81%EC%9A%A9\" aria-label=\"6 함수 표현식에 타입 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 함수 표현식에 타입 적용</h1>\n<p>자바스크립트에서는 함수 문장과 함수 표현식을 다르게 인식한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function rollDice1(sides:number): number {} // 문장\nconst rollDice2 = function(sides: number): number {} // 표현식\nconst rollDice3 = (sides: number): number => {} // 표현식</code></pre></div>\n<p>타입스크립트에서는 함수 표현식을 사용하는것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type DiceRollFn = (sides: number) => number;\nconst rollDice: DiceRollFn = sides => {}</code></pre></div>\n<p>만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아본다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type BinaryFn = (x:number, y:numbe) => number;\n\nconst add: BinaryFn = (a,b) => a+b;\nconst sub: BinaryFn = (a,b) => a-b;\nconst mul: BinaryFn = (a,b) => a*b;\nconst div: BinaryFn = (a,b) => a/b;</code></pre></div>","excerpt":"1. 타입은 값들의 집합 타입스크립트의 타입은 이다. 타입은 값들이 없는 집합 즉 공집합이다. 은 어떠한 값이든 할당할 수 있는 집합 즉 전체집합이다. 그 다음으로 작은 집합은 한가지 값만 포함하는 리터럴타입이다. 두개 혹은 세 개로 묶으려면  타입을 사용한다. 연산자는 두 타입의 교집합이다. 위 코드를 보면 공통을 가지는 속성이 없기 때문에 타입이 될것같지만 타입 연산자는 인테페이스의 속성이 아닌 타입의 범위에 적용된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다 따라서 Person과 Lifespan을 둘다 가지는 값은 PersonSpan 타입에 속하게 된다. 따라서 아래의 코드는 정상적으로 작동한다. 조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 사용하는것이다. 즉 A는 B를 상속 = A는 B에 할당 가능 = A는 B의 서브타입 = A는 B의 부분집합 모두 같은 의미이다. 2. 타입공간 값공간 타입스크립트의 심벌은 타입 …","frontmatter":{"date":"April 22, 2022","title":"02. 타입스크립트 타입 시스템","categories":"typescript","author":"sangzun","emoji":null},"fields":{"slug":"/타입스크립트/2.타입스크립트 설정/"}},"next":{"id":"9b824f58-3eb0-58e8-848a-b8719a71044c","html":"<h1 id=\"타입스크립트-vs-자바스크립트\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-vs-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8\" aria-label=\"타입스크립트 vs 자바스크립트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입스크립트 vs 자바스크립트</h1>\n<p>모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 반대는 성립하지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function greet(who: string) {\n  console.log(\"Hello\", who);\n}</code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">string</code>은 타입스크립트에서 쓰이는 타입 구문이다. 따라서 자바스크립트에서는 오류를 출력한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let city = \"new york city\";\nconsole.log(city.toUppercase());</code></pre></div>\n<p>위 코드에서 타입 구문이 없지만 타입 체커는 문제점을 찾아낸다. city 변수가 문자열이라는 것을 알려주지 않아도 타입스크립트는 초기값으로부터 타입을 추론한다.</p>\n<p>또한 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다. 하지만 모든 오류를 찾지는 못한다. 타입 체커를 통과해도 오류를 발생시키는 코드는 충분히 존재할 수 있다.</p>\n<h1 id=\"1-타입스크립트-설정\" style=\"position:relative;\"><a href=\"#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95\" aria-label=\"1 타입스크립트 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 타입스크립트 설정</h1>\n<p>타입스크립트 컴파일러는 많은 설정을 가지고 있다. <code class=\"language-text\">tsconfing.json</code>파일을 통해서 설정하거나 커맨드라인에서 사용할 수 있다.</p>\n<p>설정을 사용하기 위해서는 <code class=\"language-text\">noImplicitAny</code>와 <code class=\"language-text\">strictNullChecks</code>를 이해해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function add(x,y) {\n  return a+b;\n}\n\nfunction add(x:nubmer, y:number) {\n  return x+y;\n}</code></pre></div>\n<p><code class=\"language-text\">noImplicitAny</code>는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 판단한다. noImplicitAny가 해제되어 있을때 위의 첫번째 코드는 유효하다.</p>\n<p>타입스크립트는 타입 정보를 가질때 효과적인인 언어기 때문에 noImplicitAny를 설정하는것이 좋다.</p>\n<p><code class=\"language-text\">strictNullChecks</code>는 null과 undefined을 모든 타입에서 허용되는지 여부를 설정한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x: number = null;</code></pre></div>\n<p>strictNullChecks가 해제되었다면 위의 코드는 유효한 값이지만 strictNullChecks를 설정하면 오류가된다.</p>\n<h1 id=\"2-코드-생성과-타입\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85\" aria-label=\"2 코드 생성과 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드 생성과 타입</h1>\n<ul>\n<li>코드 생성은 타입 시스템과 무관하다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.</li>\n<li>타입오류가 존재하더라도 컴파일은 가능하다.</li>\n<li>타입스크립트 타입은 런타임에 사용할 수 없다. 런타임에 타입을 지정하려면 타입 정보 유지를 위한 별도의 방법이 필요하며 일반적으로는 태그된 유니온과 속성 체크 방법을 사용한다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 속성 체크 방법\ninterface Square {\n    width: number;\n}\n\ninterface Retangle extends Square {\n    height: number;\n}\n\ntype Shape = Square | Retangle;\n\nfunction calculateArea(shape:Shape) {\n    if ('height' in shape) {\n        shape;\n        return shape.width * shape.height;\n    } else {\n        shape;\n        return shape.width * shape.width;\n    }\n}\n\n// 태그된 유니온\ninterface Square {\n    kind: 'square';\n    width: number;\n\n}\n\ninterface Retangle {\n    kind: 'retangle';\n    height: number;\n    width: number;\n\n}\n\ntype Shape = Square | Retangle;\n\nfunction calculateArea(shape: Shape) {\n    if (shape.kind === 'retangle') {\n        shape;\n        return shape.width * shape.height;\n    } else {\n        shape;\n        return shape.width * shape.width;\n    }\n}</code></pre></div>\n<h1 id=\"3-구조적-타이핑\" style=\"position:relative;\"><a href=\"#3-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91\" aria-label=\"3 구조적 타이핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 구조적 타이핑</h1>\n<p><code class=\"language-text\">duck typing</code> : 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는것으로 간주하는 방식</p>\n<p>자바스크립트는 덕타이핑 기반이다. 어떤 함수의 매개변수 값이 모두 제대로 주어진다면 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Vector2D {\n  x: number;\n  y: number;\n}\n\ninterface NamedVector {\n  name: string;\n  x: number;\n  y: number;\n}\n\nfunction calculateLength(v: Vector2D) {\n  return Math.sqrt(v.x * v.x + v.y * v.y);\n}\n\nconst v: NamedVector = {x: 3, y: 4, name: 'Zee' };\ncalculateLength(v); //5</code></pre></div>\n<p>위 코드에서 NamedVector의 구조가 Vector2D와 호환되기 때문에 calculateLength 호출이 가능하다. 즉 타입스크립트 타입시스템은 <code class=\"language-text\">구조적으로</code>타입이 맞기만 한다면 이를 허용한다 이것이 구조적 타이핑이다.</p>\n<ul>\n<li>자바스크립트는 덕타이핑 기반이고 타입스크립트는 구조적 타이핑을 사용한다.</li>\n<li>타입은 <code class=\"language-text\">봉인</code> 되어 있지 않다.</li>\n<li>클래스 또한 구조적 타이핑을 따르고 있으므로 클래스의 인스턴스가 예상과 다를 수 있다.</li>\n<li>구조적 타이핑은 유닛테스트시에 유용하다.</li>\n</ul>\n<h1 id=\"4-any-타입-지양\" style=\"position:relative;\"><a href=\"#4-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91\" aria-label=\"4 any 타입 지양 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. any 타입 지양</h1>\n<p>타입스크립트의 타입 시스템은 <code class=\"language-text\">gradual</code>이고 <code class=\"language-text\">optional</code>이다. 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다. 이것들의 핵심은 <code class=\"language-text\">any</code>다.</p>\n<ul>\n<li><code class=\"language-text\">any</code>타입을 사용하면 타입체커와 타입스크립트의 여러가지 서비스를 무력화시킨다. any타입은 문제점을 감추고 타입 시스템의 신뢰도를 떨어뜨린다. 사용을 자제하는것이 좋다.</li>\n</ul>","frontmatter":{"date":"April 15, 2022","title":"01. 타입스크립트 알아보기","categories":"typescript","author":"sangzun","emoji":null},"fields":{"slug":"/타입스크립트/1.타입스크립트 알아보기/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/타입스크립트/2.타입스크립트 설정/","nextSlug":"/타입스크립트/1.타입스크립트 알아보기/","prevSlug":""}},"staticQueryHashes":["1073350324","2938748437"]}