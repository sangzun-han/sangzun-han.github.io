{
    "componentChunkName": "component---src-pages-index-js",
    "path": "/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"2d3959fd-1bb2-5980-8e70-a18748f29e6d","excerpt":"백준 1697. 숨바꼭질 동생을 찾는 가장 빠른 시간을 구하는 문제 걷기 : X + 1 또는 X -1로 이동 (1초) 순간이동 : 2 * X로 이동 (1초) 정점은 최대 M개 간선은 3M개  순간이동이 존재하지 않는다고 치면 1에서 시작해서 10만까지 가는데 걸리는 시간은 100,000초 순간이동이 존재한다면 60,000에서 10만까지 가는 최단시간은 순간이동 -> 20,000번 뒤로오기 알 수 있는건 100,000 이상의 수에서 순간이동을 하면 최단시간은 될 수 없다.","frontmatter":{"categories":"알고리즘","title":"BFS","date":"August 22, 2022"},"fields":{"slug":"/알고리즘/BFS/"}}},{"node":{"id":"c76a4ef3-dd94-5118-a98b-8ad6d68b5e74","excerpt":"시뮬레이션과 구현문제들 풀이에 어려움을 겪어서 푼 문제들을 어떻게 접근해서 풀었는지 모두 기록합니다. 백준 14499. 주사위 굴리기 처음 주사위의 모든 면은 0 주사위를 굴렸을 때 이동한 칸에 쓰여있는게 0 이라면 주사위 바닥면에 적혀있는 숫자를 복사한다. 주사위를 굴렸을 때 이동한 칸에 쓰여있는게 0이 아니라면 주사위 바닥면에 이동한 칸에 있는 숫자를 복사한다. 범위를 벗어나면 무시하며 출력도 하지 않는다. 위의 내용들이 주사위 굴리기 문제의 조건들입니다. 이 문제에서 주사위를 굴리는 방법은 동쪽, 서쪽, 남쪽, 북쪽 4가지 경우 밖에 존재하지 않습니다. 아래 그림을 보면서 한번 이해를 해보면 될것같습니다.\n주사위돌리기 주사위를 동쪽, 서쪽으로 굴리면 2,5는 고정이 된채로 다른 숫자들이 움직이는걸 알 수 있습니다. 또한 주사위를 남쪽,북쪽으로 굴리면 4,3은 고정이 된채로 다른 숫자들이 움직입니다. 예를들어 주사위를 동쪽으로 굴린다고 가정해보겠습니다. 1은 3위치로 움직입니다…","frontmatter":{"categories":"알고리즘","title":"시뮬레이션과 구현","date":"August 20, 2022"},"fields":{"slug":"/알고리즘/시뮬레이션과 구현/"}}},{"node":{"id":"f318eb7e-4c6f-5544-9516-81168136789d","excerpt":"강의실 배정 어떤 방법으로 강의를 선택해야 회의실이 최소가 될까? 시작시간이 가장 빠른것을 선택 (X) 끝나는 시간이 가장 빠른것을 선택 -> 종료되는 강의시간이 빠르면 더 많은 강의를 배정할 확률이 높아진다. 수업시간이 짧은 강의부터 선택 (X)-> 0-1 1-4 4-5 3-5 시작시간을 기준으로 정렬 탐색 첫번째 강의의 끝나는시간을 큐에 추가 다음 강의의 시작시간이랑 큐의 가장 위에있는값 비교 다음 강의 시작시간 >= 큐의 가장 위에있는 값 —> 같은 강의실 써도된다. (큐에서 제거) 조건을 만족하지 못하면 큐에 추가","frontmatter":{"categories":"알고리즘","title":"백준 11000 강의실 배정","date":"August 02, 2022"},"fields":{"slug":"/알고리즘/백준11000/"}}},{"node":{"id":"fe793ae8-d08b-5d55-8f9b-d08e45f2b1fb","excerpt":"1. 알고리즘 기초 문제 해결 과정 문제를 읽고 이해한다. 문제를 익숙한 용어로 재정의한다. 어떻게 해결할지 계획을 세운다. 계획을 검증한다. 프로그램으로 구현한다. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다. 체계적인 접근을 위한 질문 비슷한 문제를 풀어본적 있는가 단순한 방법에서 시작할 수 있을까 문제를 단순화 할 수 있을까 그림으로 그려 볼 수 있을까 수식으로 표현할 수 있을까 문제를 분해 할 수 있을까 뒤에서부터 생각해서 문제를 풀 수 있을까 특정 형태의 답만을 고려할 수 있을까 정렬하고 풀 수 있을까 Ex) 1부터 100까지 합을 구하는 문제 1+2+3…+100 = 5050 (반복문) 100*(1+100) / 2 = 5050 시간복잡도 최선의 경우 (Best Case) 빅 오메가 표기법 사용  최선의 시나리오로 최소 x 시간이 걸림 최악의 경우 (Worst Case) 빅 오 표기법 사용  최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림 평균의경우 …","frontmatter":{"categories":"알고리즘","title":"알고리즘 기초","date":"August 01, 2022"},"fields":{"slug":"/알고리즘/알고리즘 기초/"}}},{"node":{"id":"0728da14-b3f9-5ce6-beeb-d3fd1d827c79","excerpt":"반복과 재귀 반복과 재귀는 유사한 작업을 수행할 수 있다. 반복은 수행하는 작업이 완료될 때 까지 계속 반복 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다. 재귀 함수 (recursive function) 함수에 대한 정의를 명확히  평평하게 로직을 바라보기  각 재귀의 실행을 결정하는 결정요인(값)은 로 선언한다. 종료조건 존재? 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수  일반적으로 재귀적 정의를 이용해서 재귀함수를 구현 재귀적 프로그램을 작성하는 것은 반복구조에 비해 간결하고 이해하기 쉬움 함수 호출은 프로그램 메모리 구조에서 을 사용 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하 발생  재귀 반복 종료 재귀 함수 호출이 종료되는 base case 반복문의 종료 조건 수행시간 (상대적) 느림 빠름 메모리 공간 …","frontmatter":{"categories":"알고리즘","title":"알고리즘 기초 - 재귀함수","date":"August 01, 2022"},"fields":{"slug":"/알고리즘/재귀함수/"}}},{"node":{"id":"0f799a0a-ae0c-5ebb-abd6-1bbda409e5f9","excerpt":"Generic 다양한 타입의 객체를 다루는 메서드, 컬렉션 클래스에서 컴파일시에 타입 체크 미리 사용할 타입을 명시해서 형 변환을 하지 않아도 되게함 객체의 타입에 대한 안전성 향상 및 형 변환의 번거로움 감소 Generic 표현 클래스 또는 인터페이스 선언시 <>에 타입 파라미터 표시 ex) public class className {} 타입 파라미터 특별한 의미의 알파벳 보다는 단순히 임의의 참조형 타입을 말함 T : reference Type, E: Element, K: Key, V: Value 객체 생성 변수 쪽과 생성 쪽의 타입은 반드시 같아야 함 type parameter의 제한 계산기 프로그램 구현시 Number이하의 타입으로만 제한 type parameter 선언 뒤 extends와 함께 상위 타입 명시 Generic Type 객체를 할당받을 때 Generic type<?> → 타입에 대한 제한 없음(Object) Generic type<? extends T> → T…","frontmatter":{"categories":"JAVA","title":"자바 기초 3","date":"July 31, 2022"},"fields":{"slug":"/JAVA/자바기초3/"}}},{"node":{"id":"4b618093-5b38-5065-8d9e-ec162fd38aa9","excerpt":"객체와 클래스 현실의 객체가 갖는 속성과 기능은  되어 클래스에 정의된다. 클래스는 구체화되어 프로그램의  가 된다. 내가 필요한 것들(특징,기능)로만 구성된 객체를 만들어낼 수 있는 클래스를 정의 ⇒  클래스 - 붕어빵틀 객체 - 붕어빵 객체 메모리 구조 static 영역에 static 변수, static 메서드를 올림 stack 영역에 참조 변수 선언 heap 영역에 객체 생성 객체의 멤버변수만 생성 메서드는 일반 영역에 한번만 생성되며 객체와 링크시켜 놓음 객체의 주소를 stack 영역의 참조변수에 할당 메소드 오버로딩 메소드이름은 같고, 매개변수 타입이나 개수가 다른 달라 다른 메소드로서 동작 같은 기능이지만 상황에 따라 유연하게 사용해야하는 경우 Ex) printf, 생성자 생성자 객체를 생성하고 멤버 변수 초기화, 또는 초기설정 default 생성자는 어떠한 생성자도 없는 경우에만 컴파일러에 의해 제공 OOP Object 클래스 모든 클래스의 조상 클래스 별도의  선언이…","frontmatter":{"categories":"JAVA","title":"자바 기초 2","date":"July 31, 2022"},"fields":{"slug":"/JAVA/자바기초2/"}}},{"node":{"id":"dea599dc-bfe1-546d-9254-79dd52141669","excerpt":"연산자와 형변환 형변환 형변환: 변수의 타입을 다른 타입으로 변환 primitive는 primitive끼리 reference는 reference끼리 형 변환가능 boolean은 다른 기본 타입과 호환 X 기본 타입과 참조형의 형 변환을 위해서 wrapper 클래스 사용 형변환 방법 묵시적 형변환 작은 데이터 타입 → 큰 데이터 타입 명시적 형변환 큰 데이터 타입 → 작은 데이터 타입 (값 손실이 발생할 수 있다.) 값의 크기, 타입의 크기가 아닌 가 커지는 방향으로 할당할 경우에 묵시적 형변환이 발생한다. byte → (short,char) → int → long → float → double 연산자 어떤 기능을 수행하는 기호(+,-,*,/) 연산자 종류와 우선순위 및 결합 방향 연산자의 우선순위를 외우는것은 어렵기 떄문에 ()를 활용하는것이 편함 조건문 배열  : 배열은 최초 메모리 할당 이후 변경 불가능 동일한 타입의 데이터 0개 이상을 하나의 연속된 메모리 공간에서 관리  키…","frontmatter":{"categories":"JAVA","title":"자바 기초 1","date":"July 30, 2022"},"fields":{"slug":"/JAVA/자바기초1/"}}},{"node":{"id":"c10a6595-9947-509a-9779-92ff07cbc121","excerpt":"리액트를 이용하여 간단히 몇가지 기능이 있는 마켓을 만들었습니다. 구현사항 쇼핑 아이템 목록 페이지 구현 아이템의 상세페이지 구현 상세페이지 내에서 옵션,갯수 선택 가능 옵션과 아이템 선택 갯수에 따라 상품의 총액 계산 노출 장바구니 담기 구현 아이템 상세에서 장바구니에 담기를 클릭하면 상단에 구현된 장바구니 아이콘 옆에 담긴 상품 갯수 노출 장바구니 목록 페이지 구현 장바구니 목록에는 아이템명과 아이템의 옵션, 수량, 개별금액, 총 금액 노출 총 3개의 페이지 구현 → 목록 / 상세 / 장바구니 금액은 노출될때 천원단위 콤마 표시 상품목록 정렬기능 프로젝트를 진행하면서 남겨두었던 기록입니다. Youtube\nGithub","frontmatter":{"categories":"프로젝트","title":"오픈마켓","date":"June 05, 2022"},"fields":{"slug":"/프로젝트/market/"}}},{"node":{"id":"e588837e-6039-521d-bad6-bbd52635ec5d","excerpt":"리액트를 이용하여 간단히 당근마켓 클론코딩을 진행했습니다. 구현사항 구현사항 Github 정리 components 폴더 안에 모든 컴포넌트가 존재하다보니 컴포넌트들을 찾는 일이 번거로워졌다. 이후에 componets, pages 폴더로 나누긴 했지만 조금 더 세세하게 컴포넌트들을 분리할 필요성을 느꼈다. 변경 후 state관리에서 번번한 오류가 계속해서 발생하고 현재의 값 확인이 복잡해졌다. 중간에 redux를 배워서 넣을까 라는 생각을 했지만 거의 완성단계에 와서 넣으면 리팩토링하는데 더 시간을 쏟을거 같아서 그대로 진행했다. redux가 됐든 mobx가 됐든 전역상태관리 라이브러리를 배워두도록 해야겠다. Follow,Following 목록에서 팔로우,팔로잉을 취소할 경우 팔로우 리스트, 팔로잉 리스트의 값이 변해야 하지만 변하지 않는다. useEffect를 이용해서 해결할 수 있을 줄 알았지만 아직 해결하지 못했다. follow 게시글을 작성할 때 그 글의 길이가 얼마나 될지 …","frontmatter":{"categories":"프로젝트","title":"당근마켓 클론","date":"April 01, 2022"},"fields":{"slug":"/프로젝트/citrus/"}}},{"node":{"id":"7cf5fbb4-591c-5621-8bee-1233f46bc1e9","excerpt":"1. 이벤트 브라우저는 특정 일이 발생하면 이를 감지하여 이벤트를 발생시킨다. 이벤트가 발생했을 때 호출될 함수를  라 하고 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을  이라 한다. 2. 이벤트 핸들러 등록 이벤트 핸들러를 등록하는 방법은 3가지다. 2-1. 이벤트 핸들러 어트리뷰트 HTML과 자바스크립트는 관심사가 다르므로 분리하는것이 좋다. 따라서 이벤트 핸들러 어트리뷰트 방식은 사용하지 않는것이 좋다. 2-2. 이벤트 핸들러 프로퍼티 방식 이벤트 핸들러 어트리뷰트 방식도 DOM 노드 객체의 이벤트 핸들러 프로퍼티로 변환되므로 결과적으로 이벤트 핸들러 프로퍼티 방식과 동일하다고 할 수 있다. 은 이벤트 핸들러 어트리뷰트 방식의 HTML과 자바스크립트가 혼재되는 문제를 해결할 수 있지만 이벤트 핸들러 프러퍼티에 하나의 이벤트 핸들러만 바인딩 할 수 있다는 단점이 존재한다. addEventListener 메서드 방식 동일한 HTML 요소에서 동일한 이벤…","frontmatter":{"categories":"javascript","title":"40. 이벤트","date":"March 25, 2022"},"fields":{"slug":"/자바스크립트/40.이벤트/"}}},{"node":{"id":"0d7dc3ee-d82e-5514-a7af-e02bc839e001","excerpt":"1. 브라우저의 렌더링 과정 브라우저는 html,css,js,이미지,폰트 파일등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다. 브라우저의 렌더링 엔진은 서버로부터 응답된 html과 css를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합한 렌더 트리를 생성한다. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. 렌더 트리를 기반으로 html 요소의 레이아웃을 계산하고 브라우저 화면에 html 요소를 페인팅한다. 2. DOM HTML 요소는 렌더링 엔진에 의해 파싱되어 DOM을 구성하는 요소 노드 객체로 변환된다. 노드 객체들로 구성된 트리 자료구조를  이라 한다. 노드 객체의 트리로 구조화되어 있기 때문에 DOM을 DOM트리 라고 부른다. domtree D…","frontmatter":{"categories":"javascript","title":"38~39. 브라우저의 렌더링 과정, DOM","date":"March 22, 2022"},"fields":{"slug":"/자바스크립트/38.브라우저의 렌더링/"}}},{"node":{"id":"3b22e04a-dabd-5c3d-9e7c-aeba3e540c9a","excerpt":"1. Set Set 객체는  유일한 값들의 집합이다. 구분 배열 Set 객체 동일한 값을 중복하여 포함할 수 있다. O X 요소 순서에 의미가 있다. O X 인덱스로 요소에 접근할 수 있다. O X Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이 때 중복된 값은 Set 객체에 요소로 저장 되지 않는다. 2. Set 객체 메서드 Set 객체의 요소 개수를 확인할때는  프로퍼티를 사용한다. size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다. Set 객체에 요소를 추가할 때는  메서드를 사용한다. add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출할 수 있다. Set 객체에 특정 요소가 존재하는지 확인하려면  메서드를 사용한다. has 메서드는 불리언 값을 반환한다. Set 객체의 …","frontmatter":{"categories":"javascript","title":"37. Set과 Map","date":"March 18, 2022"},"fields":{"slug":"/자바스크립트/37.Set과 Map/"}}},{"node":{"id":"0e21442b-5822-56e4-895b-b7bf6b81465c","excerpt":"디스트럭처링 할당(destructuring assignment)은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화) 하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다. 1. 배열 디스트럭처링 할당 배열 디스트럭처링 할당을 위해서는 변수를 배열 리터럴 형태로 선언해야 한다. 이때 우변에 이터러블을 할당하지 않으면 에러가 발상한다. 배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉 순서대로 할당된다, 하지만 변수의 개수와 이터러블의 요소 개수가\n반드시 일치할 필요는 없다. 배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 기본값보다 할당된 값이 우선된다. 배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게  …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. 2. 객체 디스트럭처링 할당 객체 디스트럭처링 할당의 대상은 객체여야 하며, 할당 기준은 프로퍼티 키다. 즉 …","frontmatter":{"categories":"javascript","title":"36. 디스트럭처링 할당","date":"March 12, 2022"},"fields":{"slug":"/자바스크립트/36.디스트럭쳐링 할당/"}}},{"node":{"id":"925166d9-5422-5a2f-95db-5943d32dd1a0","excerpt":"ES6에서 도입된 스프레드 문법(spread syntax)는 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for … of 문으로 순회할 수 있는 이터러블에 한정된다. 스프레드 문법의 결과는 값이 아니다. 따라서 스프레드 문법의 결과는 변수에 할당 할 수 없다. 스프레드 문법의 결과물은 값으로 사용할 수 없고, 쉼표로 구분한 값의 목록을 사용하는 문백에서만 사용할 수 있다. 함수 호출문의 인수 목록 배열 리터럴의 요소 목록 객체 리터럴의 프로퍼티 목록 1. 함수 호출문의 인수 목록 Math.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 만약 Math.max 메서드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할수 없으므로 NaN을 반환한다. 스프레드 문법 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인…","frontmatter":{"categories":"javascript","title":"35. 스프레드 문법","date":"February 26, 2022"},"fields":{"slug":"/자바스크립트/35.스프레드 문법/"}}},{"node":{"id":"5db8180b-04d7-5886-a72c-79815ab7581c","excerpt":"1. 이터레이션 프로토콜 ES6에서 도입된 iteration protocol은 순회 가능한 데이터 컬렉션을 만들기 위해 EMCAScript 사양에 정의하여 미리 약속한 규칙이다. ES6 이전의 배열, 문자열, 유사 배열 객체, DOM 컬렉션등은 통일된 규약 없이 각자 나름의 구조를 가지고 for문, for … in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for … of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화 했다. iterable protocol : Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이러한 규약을 이터러블 프로토콜이라 한다. 이터러블 프로토콜을 준수한 객체…","frontmatter":{"categories":"javascript","title":"34. 이터러블","date":"February 19, 2022"},"fields":{"slug":"/자바스크립트/34.이터러블/"}}},{"node":{"id":"87988a7c-e238-5697-a27c-a46298a30aae","excerpt":"1. 심벌이란?  은 ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. 심벌값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다. 2. 심벌값 생성 심벌 값은 Symbol 함수를 호출하여 생성한다. 이 때 생성된 심벌 값은 외부로 노출되지 않아 확인할 수 없다. Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설며으로 디버깅 용도로만 사용되며 심벌 값 생성에는 영향을 끼치지 않는다. 심벌값도 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다. 심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.\n단 boolean 타입으로는 암묵적으로 타입 변환된다. 이를 통해 if문에서 존재 확인이 가능하다.  메서드는 인수로 전달받은 문자열을 사용하여 키와 심벌 값의 쌍들이 저장되어있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌…","frontmatter":{"categories":"javascript","title":"33. Symbol","date":"January 18, 2022"},"fields":{"slug":"/자바스크립트/33.Sybmol/"}}},{"node":{"id":"3b057221-4459-5aa5-91a2-25064d7fdec8","excerpt":"1. String 생성자 함수 표준 빌트인 객체인 String 객체는 생성자 함수 객체다. new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다. String 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체를 생성한다. 인수를 전달하면 [[StringData]] 내부 슬롯에 인수로 전달받은 문자열을 할당한 String 래퍼 객체를 생성한다. String 래퍼 객체는 유사 배열 객체이면서 이터러벌이다. 따라서 인덱스를 사용하여 각 문자에 접근할 수 있다. 2. length 프로퍼티  프로퍼티는 문자열의 문자 개수를 반환한다. 3. String 메서드 배열에는 (원본배열 직접변경)와 (새로운 배열 생성)가 있다. String 객체에는 원본 String 래퍼 객체를 직접 변경하는 메서드는 존재하지 않는다. 문자열은 변경 한 값이기 때문에 String 래퍼 객체도 읽기 전용…","frontmatter":{"categories":"javascript","title":"32. String","date":"January 06, 2022"},"fields":{"slug":"/자바스크립트/32.String/"}}},{"node":{"id":"4fbe43ed-bbbf-5bb2-95b8-30bbd683b885","excerpt":"1. 정규표현식 정규 표현식은 문자열을 대상으로 **패턴 매칭 기능**을 제공한다.  : 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능 2. 정규표현식 생성 정규 표현식 객체(RegExp 객체)를 생성하기 위해서는 **정규 표현식 리터럴**과 RegExp 생성자 함수를 사용할 수 있다. regexp 3. 정규표현식 메서드  : 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다. 문자열 내의 모든 패턴을 검색하는 g플래그를 지정해도 첫번째 매칭 결과만 반환한다.  : 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 boolean 값으로 반환한다.  : 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다. g플래그가 지정되면 모든 매칭 결과를 배열로 반환한다. 4. 플래그 패턴과 함께 정규 표현식을 구성하는 플래그는 정규 표현식…","frontmatter":{"categories":"javascript","title":"31. RegExp","date":"January 04, 2022"},"fields":{"slug":"/자바스크립트/31.RegExp/"}}},{"node":{"id":"334cf9f8-add0-5f01-92eb-b0b1def057e1","excerpt":"표준 빌트인 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수이다. 1. Date 생성자 함수 Date 생성자 함수로 생성한 Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다.\n1970년 1월 1일 00:00:00(UTC)을 기점으로 Date 객체가 나타내는 날짜와 시간까지의 밀리초를 나타낸다. Date 생성자 함수로 생성한 Date 객체는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다. 1-1. new Date() new 연산자와 함께 호출하면 Date 객체를 그렇지 않으면 문자열을 반환한다. 1-2. new Date(milliseconds) Date 생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 UTC를 기준으로 인수로 전달된만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다. 1-3 new Date(dateString) 문자열을 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date객체를 반환한다. 인…","frontmatter":{"categories":"javascript","title":"30. Date","date":"January 03, 2022"},"fields":{"slug":"/자바스크립트/30.Date/"}}},{"node":{"id":"6b8669ff-9847-5a44-b0c3-5ecfb236076b","excerpt":"1. Math 프로퍼티 2. Math 메서드  : 인수로 전달된 숫자의 절대값을 반환 (절대값은 반드시 0또는 양수) : 인수로 전달된 숫자의 소수점 이하를 반올림한 정수를 반환  : 인수로 전달된 숫자의 소수점 이하를 내림한 정수를 반환  : 인수로 전달된 숫자의 소수점 이하를 올림한 정수를 반환  : 인수로 전달된 숫자의 제곱근을 반환  : 임의의 난수(0이상 ~ 1미만)를 반환  : 첫번째 인수를 밑으로 두번째 인수를 지수로 거듭제곱한 결과를 반환  : 전달받은 인수 중 가장 큰 수 반환  : 전달받은 인수 중 가장 작은 수 반환","frontmatter":{"categories":"javascript","title":"29. Math","date":"January 02, 2022"},"fields":{"slug":"/자바스크립트/29.Math/"}}},{"node":{"id":"2fb0f604-eaae-597b-85b3-0dbe66dd4422","excerpt":"1. Number 생성자 함수 표준 빌트인 객체인 Number 객체는 생성자 함수 객체다. 따라서 new 연산자와 함께 Number 인스턴스를 생성할 수 있다. Number 생성자 함수에 인수를 전달하지 않고 new 연산자와 함께 호출하면 [[NumberData]] 내부슬롯에 0을 할당한 Number 래퍼 객체를 생성한다. Number 생성자 함수에 숫자가 아닌 값을 전달하면 강제로 숫자로 변환하고 숫자로 변환할 수 없다면 NaN을 내부슬롯에 할당한 Number 래퍼 객체를 생성한다. 2. Number 프로퍼티 : EPSILON은 1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.\nEPSILON은 부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용한다.  : 자바스크립트에서 표현할 수 있는 가장 큰 양수값  : 자바스크립트에서 표현할 수 있는 가장 작은 양수값  : 자바스크립트에서 안전하게 표현할 수 있는 가장 큰 정수값  : 자바스크립트에서 안전하게 표현할 수 있는…","frontmatter":{"categories":"javascript","title":"28. Number","date":"December 24, 2021"},"fields":{"slug":"/자바스크립트/28.Number/"}}},{"node":{"id":"69e16ecb-4d30-5654-9142-7e2779a1e79f","excerpt":"1. 배열 배열은 여러 개의 값을 순차적으로 나열한 자료구조이다. 배열은 인덱스와 length 프로퍼티를 갖기 때문에 for문을 통해 순차적으로 접근할 수 있다. 배열은 객체 타입이다. 배열 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다. 2. 자바스크립트의 배열 자바스크립트의 배열은 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 즉 희소 행렬(sparse array)이다. 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능적인 면에서 느린 구조적인 단점이 있다. 하지만 특정 요소를 검색하거나 삽입,삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다. 3. length프로퍼티, 희소행렬 length 프로퍼티 값은 배열의 길이를 바탕으로 결정되지만 임의의 숫자 값을 명시적으로 할당할 수 도 있다. 현…","frontmatter":{"categories":"javascript","title":"27. 배열","date":"December 21, 2021"},"fields":{"slug":"/자바스크립트/27.배열/"}}},{"node":{"id":"7663b168-d1a9-5781-8d45-b289f0b1f1f1","excerpt":"ES6 이전의 함수는 사용 목적에 따라 명확히 구분되지 않는다. 즉 ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. ES6이전의 모든 함수는 callable이면서 constructor이다. 객체에 바인딩된 함수를 생성자 함수로 호출하는 경우가 흔치는 않지만 문법상 가능하다. 그리고 이는 성능면에서 문제가 있다. 객체에 바인딩된 함수가 constructor라는것은 prototype 프로퍼티를 가지며 프로토타입 객체를 생성한다는 것을 의미한다. 따라서 불필요한 프로타티입 객체를 생성한다. ES6 함수의 구분 constructor prototype super arguments 일반함수 O O X O 메서드 X X O O 화살표함수 X X X X 1. 메서드 ES6 이전에는 메서드에 대한 명확한 정의가 없었다. 일반적으로 메서드는 객체에 바인딩 된 함수를 가리켰다.\nES6에서는 메서드에 대한 정의를 메서드 축약 표현으로 정의된 함수만을…","frontmatter":{"categories":"javascript","title":"26. ES6 함수의 추가 기능","date":"December 20, 2021"},"fields":{"slug":"/자바스크립트/26.ES6 함수의 추가 기능/"}}},{"node":{"id":"ed79635c-23ae-5ec9-ba92-04748464be11","excerpt":"1. 클래스 자바스크립트에서 클래스는 생성자 함수와 유사하게 동작하지만 몇 가지 차이가 있다. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 클래스 내의 모든 코드는 암묵적으로 strict mode가 살행된다. 클래스는 열거되지 않는다. 2. 프로퍼티 인스턴스 프로퍼티 : constructor 내부에서 정의해야 한다. 접근자 프로퍼티: 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티 클래스 필드 : 클래스 기반의 객체 지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티 private : private 필드의 앞에는 #을 붙여주고 참조할 때도 붙여준다. 3. 상속에 의한 클래스 확장 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 ***확장(extends)***하여 정의하는것…","frontmatter":{"categories":"javascript","title":"25. 클래스","date":"December 15, 2021"},"fields":{"slug":"/자바스크립트/25.클래스/"}}},{"node":{"id":"588da58c-3e3c-504f-bc9d-93ce025652a0","excerpt":"실행컨택스트(execution context) 자바스크립트의 원리를 담고 있는 핵심 개념이다. 1. 소스코드의타입 실행컨텍스트는 다음과 같은 것들을 이용하면 execution context stack에 쌓이게된다. executionstack 전역코드 함수코드 eval 코드 모듈 코드 2. 렉시컬 환경 렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값, 상위스코프에 대한 참조를 기록하는 자료구조이다. Lexical environmet는 EnvirenmetRecore와 OuterLexicalEnvironmentReference로 구성된다 환경레코드(Environment Recode) : 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소 외부 렉시컬 환경에 대한 참조(OuterLexicalEnvironmentReference): 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다. executioncontext 2-1. …","frontmatter":{"categories":"javascript","title":"23.실행 컨텍스트","date":"December 14, 2021"},"fields":{"slug":"/자바스크립트/23.실행컨텍스트/"}}},{"node":{"id":"0d2b235b-9843-58c1-acba-fc68245a3b11","excerpt":"1. this 키워드 메서드는 프로퍼티를 참조하고 변경할 수 있어야 한다. 이 때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다. this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. this 바인딩 : 바인딩이랑 식별자와 값을 연결하는 과정을 의미한다. this 바인딩은 this가 가리킬 객체를 바인딩 한다. 객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 즉 circle을 가리킨다. 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this는 상황에 따라 가리키는 대상이 다르다. 자바스크립트의 this는 함수가 호출되는 방식에 따라 this 바인딩이 동적으로 결정된다. 또한 strict mod…","frontmatter":{"categories":"javascript","title":"22.this","date":"December 13, 2021"},"fields":{"slug":"/자바스크립트/22. this 키워드/"}}},{"node":{"id":"bbb4911d-cda4-5b69-95c6-1f2d0daa206a","excerpt":"1. 자바스크립트 객체의 분류 자바스크립트 객체는 크게 3개의 객체로 분류할 수 있다. 표준 빌트인 객체(standard built-in objects/native objects/global objects) 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며 자바스크립트 실행 환경과 관계없이 언제나 사용할수 있다. 별도의 선언 없이 전역 변수처럼 언제나 참조 할 수 있다. 호스트 객체(host objects) 호스트 객체는 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체이다. 사용자 정의 객체(user-defined objects) 사용자 정의 객체는 사용자가 직접 정의한 객체이다. 2. 표준 빌트인 객체 자바스크립트는 Object, String, Number, Symbol, Date등 40여개의 표준 빌트인 객체를 제공한다. Math, Reflect, JSON을제외한 표준 빌트인객체는 모두 인서턴스를 생성할수 있는 …","frontmatter":{"categories":"javascript","title":"21. 빌트인 객체","date":"December 11, 2021"},"fields":{"slug":"/자바스크립트/21.빌트인 객체/"}}},{"node":{"id":"8acf9ce6-9b30-5daa-aba1-a766b786c9fb","excerpt":"1. strict mode 오타나 문법 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는것이 좋다. ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다. ESLint 같은 린트도구를 사용해더 strict mode와 유사한 효과를 얻을 수 있다. 2. strict mode 적용 strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두애 ‘use strict’;을 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다. 전역에 적용한 strict mode는 스크립트 단위로 적용된다. strict mode 스크립트와 non-stric…","frontmatter":{"categories":"javascript","title":"20. strict mode","date":"December 10, 2021"},"fields":{"slug":"/자바스크립트/20.strict mode/"}}},{"node":{"id":"97ea3f04-1af3-5da9-b517-6132f074a4b7","excerpt":"자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어다. ES6에서 클래스가 도입되었지만 그렇다고 프로토타입 기반 객체지향을 폐지하고 새로운 객체지향 모델을 제공하는것은 아니다. 클래스도 함수이며 프로토타입 기반 패턴의 문법적 설탕***(syntactic sugar)***이다. 1. 객체지향 프로그래밍 객체지향 프로그래밍은 여러 개의 독립적 단위, 즉 객체(Object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다. 객체지향 프로그래밍은 객체의 상태***(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(be-havior)***을 하나의 논리적인 단위로 묶어 생각한다. 이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다. #2. 상속과 프로토타입 상속을 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할…","frontmatter":{"categories":"javascript","title":"19. 프로토타입","date":"December 06, 2021"},"fields":{"slug":"/자바스크립트/19.프로토타입/"}}},{"node":{"id":"2e7572ae-ba24-5a10-97c8-98c0a3c2b9e6","excerpt":"1. 일급 객체 아래의 조건을 만족하는 객체를 일급 객체라 한다. 무명의 리터럴로 생성할 수 있다. 변수나 자료구조에 저장할 수 있다. 함수의 매개변수에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 자바스크립트에서 함수는 객체다. 객체이므로 값과 동일하게 취급할 수 있다. 따라서 매개변수에 함수를 전달할 수 있고 함수의 반환값으로도 사용할 수 있다. 함수와 일반객체와의 차이는 일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있다. 또한 함수는 프로퍼티를 가지고 있다. 2. 함수 객체의 프로퍼티 arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 고유 프로퍼티다. 2-1. arguments 프로퍼티 arguments 프로퍼티 값은 arguments 객체다. arguments 객체는 함수 호출시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다. 선언된 매개변수의 개수…","frontmatter":{"categories":"javascript","title":"18. 함수와 일급 객체","date":"December 02, 2021"},"fields":{"slug":"/자바스크립트/18.함수와 일급 객체/"}}},{"node":{"id":"8399a6d9-5f57-5200-a773-688df62d36a5","excerpt":"1. 내부슬롯과 내부메소드 프로퍼티 어트리뷰트를 이해하기 위해서는 내부 슬롯(internal slot)과 내부 메서드(internal method)의 개념이 필요하다. 내부슬롯과 내부메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사메서드이다. 이중 대괄호로 감싼 이름들이 내부슬롯과 내부메서드이다. 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부상태 값이다. 따라서 직접 접근할 수 없지만 간접적으로 확인할 수 는 있다. getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 ***프로퍼티 디스크립터(PropertyDescriptor)***객체를 반환한다. 3. 데이터 프로퍼티와 접근자 프로퍼티 데이터 프로퍼티 …","frontmatter":{"categories":"javascript","title":"16. 프로퍼티 어트리뷰트","date":"December 01, 2021"},"fields":{"slug":"/자바스크립트/16.프로퍼티 어트리뷰트/"}}},{"node":{"id":"002c9c8b-d454-556e-adb3-f1605719e8ad","excerpt":"1. var 키워드의 문제점 변수 중복 선언 허용 함수 레벨 스코프 : var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. 변수 호이스팅 : 변수 선언문 이전에 변수를 참조하는것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다. 2. let 키워드 변수 중복 선언 금지 블록 레벨 스코프 변수 호이스팅 : let키워드로 선언한 변수는 선언단계와 초기화단계가 분리되어 진행된다. 만약 초기화 되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. 스코프의 시작지점부터 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal Dead Zone) TDZ 라고 부른다. 3. 전역객체와 let let 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니다. 4. …","frontmatter":{"categories":"javascript","title":"15. let, const 키워드와 블록 레벨 스코프","date":"November 30, 2021"},"fields":{"slug":"/자바스크립트/15.let,const키워드와 블록레벨 스코프/"}}},{"node":{"id":"48c8383a-3894-535a-80f0-bbc0b561c199","excerpt":"1. 변수의 생명주기 1-1. 지역변수의 생명주기 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 즉 변수는 생명주기(Life Cycle)가 있다. 변수에 생명주기가 없다면 한번 선언된 변수는 영원히 메모리 공간을 점유하게 된다.\n지역변수의 생명주기는 함수의 생명주기와 일치한다. 변수의 생명주기는 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리풀(memory pool)에 반환되는 시점까지다. 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 할당된 메모리 공간은 더 이상 그 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다. 즉 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아 있게 된다. 마찬가지로 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다. 1-2. 전역변수의 생명주기 전역코드는 명시적인 호출없이 …","frontmatter":{"categories":"javascript","title":"14. 전역변수의 문제점","date":"November 30, 2021"},"fields":{"slug":"/자바스크립트/14.전역변수의 문제점/"}}},{"node":{"id":"5177cf7f-7d96-5945-ad58-0aba5adf4dc2","excerpt":"원시타입의 값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값이다. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달(pass by value)**라고 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 **참조에 의한 전달(pass by reference)**라고 한다. 1. 원시 값 원시 타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값이다. (read only) 데이터의 신뢰성 보장 변경 불가능하다는 것은 변수가 아니라 값에 의한 진술이다.\nprimitive 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 만약 원…","frontmatter":{"categories":"javascript","title":"11. 원시 값과 객체의 비교","date":"November 21, 2021"},"fields":{"slug":"/자바스크립트/11.원시 값과 객체의 비교/"}}},{"node":{"id":"40a7d498-0406-5b28-b8dc-8a9dadfa4177","excerpt":"1. 객체 자바스크립트는 객체(Object) 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 ‘모든 것’이 객체다 원시값을 제외한 나머지값은 모두 객체다. 객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 key와 value로 구성된다. 프로퍼티의 값이 함수일 경우. 일반 함수와 구분하기 위해 메서드(method)라고 부른다. 2. 객체 리터럴에 의한 객체 생성 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다. 객체 리터럴 Object 생성 함수 생성자 함수 Object.create 메서드 클래스 (ES6) 객체 리터럴은 중괄호({…})내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진은 리터럴을 해석해 객체를 생성한다 만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다. 객체 리터럴의 중괄호는 코드블록을 의미하지 않는다. 코드 블록의 중괄호 뒤에는 세미콜론…","frontmatter":{"categories":"javascript","title":"10. 객체 리터럴","date":"November 19, 2021"},"fields":{"slug":"/자바스크립트/10.객체 리터럴/"}}},{"node":{"id":"a54b080e-70fe-5409-93bb-ffd80cdb6331","excerpt":"1. 타입변환이란 자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입변환(explict coercion) 또는 타입 캐스팅(type casting)**이라 한다. 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시값을 직접 변경하는 것은 아니다. 원시 값은 변경 불가능한 값이므로 변경할 수 없다. 자바스크립트 엔진은 x + ’ ‘을 평가하기 위해 x 변수의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’+ ’ ‘을 평가한다. 이때\n‘10’은 x변수에 재할당되지 않는다. 즉 암묵적 타입변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다. 2. 암묵적 타입 변환 표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다…","frontmatter":{"categories":"javascript","title":"09. 타입변환과 단축 평가","date":"November 18, 2021"},"fields":{"slug":"/자바스크립트/09.타입변환과 단축 평가/"}}},{"node":{"id":"b968d018-c827-5934-be14-2318a7d6e156","excerpt":"1. 블록문 블록문(block statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 2. 조건문 조건문(conditional statement)는 주어진 조건식의 평가결과에 따라 코드 블록의 실행을 결정한다. 자바스크립트는 if else문과 switch문으로 두 가지 조건문을 제공한다. if문의 조건식은 boolean값으로 평가되어야 한다. boolean값이 아닐경우 암묵적으로 boolean값으로 강제 변환되어 실행할 코드 블록을 결정한다. 대부분의 if else문은 삼항 조건 연산자로 바꿔 쓸수 있다. 조건에 따라 값을 결정하여 변수에 할당하는 경우 if else 보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다. 하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if else문을 사용하는 편이 가독성이 좋다. switch문은 주어진 표현식을 평가…","frontmatter":{"categories":"javascript","title":"08. 제어문","date":"November 13, 2021"},"fields":{"slug":"/자바스크립트/08.제어문/"}}},{"node":{"id":"ab22d008-9346-5dec-811d-48b735bb52b3","excerpt":"연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산등을 수행하여 하나의 값을 만든다. 이때 연산의 대상을 피연산자(operand)라고 한다. 피연산자는 ‘값’이라는 역할을 하며 연산자는 ‘피연산자를 연산하여 새로운 값을 만든다.’ 1. 산술 연산자 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술연산이 불가능한 경우 NaN을 반환한다. 1-1. 이항 산술 연산자 모든 이항 산술 연산자는 피연산자의 값을 변경하는 **부수효과(side effect)**가 없다. 즉 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만들어 낸다. 1-2. 단항 산술 연산자 단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.\n증가/감소(++/—) 연산자는 피연산자의 값을 변경하는 부수효과가 있다.\n즉 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다. 숫자 타입이 아닌 …","frontmatter":{"categories":"javascript","title":"07. 연산자","date":"November 12, 2021"},"fields":{"slug":"/자바스크립트/07.연산자/"}}},{"node":{"id":"200ff23f-d05c-5eb8-a9cd-9f4d1b8f66cd","excerpt":"데이터타입은 값의 종류를 말한다. 자바스크립트는 7개의 데이터 타입을 제공한다.\n7개의 데이터 타입은 원시타입(primitive type)입과 객체타입(object/reference type)으로 분류할 수 있다. 1. 숫자 타입 숫자 타입의 값은 모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 존재하지 않는다. 정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다. 2. 문자열 타입 문자열 타입은 텍스트 데이터를 나타내는데 사용한다.\n문자열은 ”, \"\", “으로 텍스트를 감싼다.\n다른타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로…","frontmatter":{"categories":"javascript","title":"06. 데이터타입","date":"November 11, 2021"},"fields":{"slug":"/자바스크립트/06.데이터 타입/"}}},{"node":{"id":"eacaa198-81ca-5dfb-82d1-ce7b1aff9a9d","excerpt":"1. 값 값(value)은 식(expression)이 평가(evaluate)되어 생성된 결과를 말한다. 2. 리터럴 리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)을 말한다.\n자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다. 즉 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다. 리터럴 예시 비고 정수 리터럴 100  부동소수점 리터럴 10.5  2진수 리터럴 0b010001 0b로 시작 8진수 리터럴 0o101 ES6에서 도입 0o로 시작 16진수 리터럴 0x41 ES6에서 도입 0x로 시작 문자열 리터럴 ‘Hello’  불리언 리터럴 true false  null 리터럴 null  undefined 리터럴 undefined  객체 리터럴 {name: ‘Lee’, address: ‘Seoul’}  배열 리터럴 [1,2,3]  함수 리터럴 function() {…","frontmatter":{"categories":"javascript","title":"05. 표현식과 문","date":"November 10, 2021"},"fields":{"slug":"/자바스크립트/05.표현식과 문/"}}},{"node":{"id":"49893b83-97f7-54ef-abe0-b80a37193f91","excerpt":"1. 변수 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간단히 말하자면 변수는 값의 위치를 가리키는 상징적인 이름이다. 10+20은 연산을 통해 새로운 값 30을 생성한다. 연산을 통해 생성된 값 30은 메모리 공간에 저장된다. 이때 메모리에 저장된 값 30을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인것이 변수이다. 변수에 값을 저장하는 것을 **할당(assignment)**이라 하고 변수에 저장된 값을 읽어 들이는 것을 **참조(reference)**라고 한다. 2. 식별자 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다.\n식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다. 식별자 3.변수 선언 변수를 사용하려면 …","frontmatter":{"categories":"javascript","title":"04. 변수","date":"November 09, 2021"},"fields":{"slug":"/자바스크립트/04.변수/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"겠다","bio":{"role":"모르","description":["뭐하는지"],"thumbnail":"profile.png"},"social":{"github":"https://github.com/sangzun-han","linkedIn":"","email":""}}}}},"pageContext":{}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437","3350743975"]}