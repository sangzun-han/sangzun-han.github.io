{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"70d6fb80-bd6f-59d1-860e-a761f03c53ab","excerpt":"실행컨택스트(execution context) 자바스크립트의 원리를 담고 있는 핵심 개념이다. 1. 소스코드의타입 실행컨텍스트는 다음과 같은 것들을 이용하면 execution context stack에 쌓이게된다. executionstack 전역코드 함수코드 eval 코드 모듈 코드 2. 렉시컬 환경 렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값, 상위스코프에 대한 참조를 기록하는 자료구조이다. Lexical environmet는 EnvirenmetRecore와 OuterLexicalEnvironmentReference로 구성된다 환경레코드(Environment Recode) : 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소 외부 렉시컬 환경에 대한 참조(OuterLexicalEnvironmentReference): 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다. executioncontext 2-1. …","frontmatter":{"categories":"javascript","title":"23.실행 컨텍스트","date":"December 14, 2021"},"fields":{"slug":"/자바스크립트/23.실행컨텍스트/"}}},{"node":{"id":"e31ef671-3590-5adb-b910-684a6e5cfe27","excerpt":"1. this 키워드 메서드는 프로퍼티를 참조하고 변경할 수 있어야 한다. 이 때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다. this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다. this 바인딩 : 바인딩이랑 식별자와 값을 연결하는 과정을 의미한다. this 바인딩은 this가 가리킬 객체를 바인딩 한다.  객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체, 즉 circle을 가리킨다.  생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this는 상황에 따라 가리키는 대상이 다르다. 자바스크립트의 this는 함수가 호출되는 방식에 따라 this 바인딩이 동적으로 결정된다. 또한 strict m…","frontmatter":{"categories":"javascript","title":"22.this","date":"December 13, 2021"},"fields":{"slug":"/자바스크립트/22. this 키워드/"}}},{"node":{"id":"823c29da-8c8a-50af-a110-1cc596e90006","excerpt":"1. 자바스크립트 객체의 분류 자바스크립트 객체는 크게 3개의 객체로 분류할 수 있다. 표준 빌트인 객체(standard built-in objects/native objects/global objects) 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며 자바스크립트 실행 환경과 관계없이 언제나 사용할수 있다. 별도의 선언 없이 전역 변수처럼 언제나 참조 할 수 있다. 호스트 객체(host objects) 호스트 객체는 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체이다. 사용자 정의 객체(user-defined objects) 사용자 정의 객체는 사용자가 직접 정의한 객체이다. 2. 표준 빌트인 객체 자바스크립트는 Object, String, Number, Symbol, Date등 40여개의 표준 빌트인 객체를 제공한다. Math, Reflect, JSON을제외한 표준 빌트인객체는 모두 인서턴스를 생성할수 있는 …","frontmatter":{"categories":"javascript","title":"21. 빌트인 객체","date":"December 11, 2021"},"fields":{"slug":"/자바스크립트/21.빌트인 객체/"}}},{"node":{"id":"0f6ffb0e-2a33-532c-912b-a045e23081e4","excerpt":"1. strict mode 오타나 문법 지식의 미비로 인한 실수는 언제나 발생한다. 따라서 오류를 줄여 안정적인 코드를 생산하기 위해서는 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들고 그 환경에서 개발하는것이 좋다. ES5부터 strict mode가 추가되었다. strict mode는 자바스크립트 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다. ESLint 같은 린트도구를 사용해더 strict mode와 유사한 효과를 얻을 수 있다. 2. strict mode 적용 strict mode를 적용하려면 전역의 선두 또는 함수 몸체의 선두애 ‘use strict’;을 추가한다. 전역의 선두에 추가하면 스크립트 전체에 strict mode가 적용된다. 전역에 적용한 strict mode는 스크립트 단위로 적용된다. strict mode 스크립트와 non-stric…","frontmatter":{"categories":"javascript","title":"20. strict mode","date":"December 10, 2021"},"fields":{"slug":"/자바스크립트/20.strict mode/"}}},{"node":{"id":"7b693e19-b46e-55b7-bbb0-f871bf58c6c5","excerpt":"자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어다. ES6에서 클래스가 도입되었지만 그렇다고 프로토타입 기반 객체지향을 폐지하고 새로운 객체지향 모델을 제공하는것은 아니다. 클래스도 함수이며 프로토타입 기반 패턴의 문법적 설탕(syntactic sugar)이다. 1. 객체지향 프로그래밍 객체지향 프로그래밍은 여러 개의 독립적 단위, 즉 객체(Object)의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다. 객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(be-havior)을 하나의 논리적인 단위로 묶어 생각한다. 이때 객체의 상태 데이터를 프로퍼티(property), 동작을 메서드(method)라 부른다. 2. 상속과 프로토타입 상속을 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.…","frontmatter":{"categories":"javascript","title":"19. 프로토타입","date":"December 06, 2021"},"fields":{"slug":"/자바스크립트/19.프로토타입/"}}},{"node":{"id":"78b9609b-7d58-5668-b2a9-bc7297e943ad","excerpt":"1. 일급 객체 아래의 조건을 만족하는 객체를 일급 객체라 한다. 무명의 리터럴로 생성할 수 있다. 변수나 자료구조에 저장할 수 있다. 함수의 매개변수에 전달할 수 있다. 함수의 반환값으로 사용할 수 있다. 자바스크립트에서 함수는 객체다. 객체이므로 값과 동일하게 취급할 수 있다. 따라서 매개변수에 함수를 전달할 수 있고 함수의 반환값으로도 사용할 수 있다. 함수와 일반객체와의 차이는 일반 객체는 호출 할 수 없지만 함수는 호출 할 수 있다. 또한 함수는 프로퍼티를 가지고 있다. 2. 함수 객체의 프로퍼티 arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 고유 프로퍼티다. 2-1. arguments 프로퍼티 arguments 프로퍼티 값은 arguments 객체다. arguments 객체는 함수 호출시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며 함수 내부에서 지역변수처럼 사용된다. 선언된 매개변수의 개수…","frontmatter":{"categories":"javascript","title":"18. 함수와 일급 객체","date":"December 02, 2021"},"fields":{"slug":"/자바스크립트/18.함수와 일급 객체/"}}},{"node":{"id":"1ae3264b-25e7-5172-9418-f56d1eb69e0e","excerpt":"1. 내부슬롯과 내부메소드 프로퍼티 어트리뷰트를 이해하기 위해서는 내부 슬롯(internal slot)과 내부 메서드(internal method)의 개념이 필요하다. 내부슬롯과 내부메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사메서드이다. 이중 대괄호로 감싼 이름들이 내부슬롯과 내부메서드이다. 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부상태 값이다. 따라서 직접 접근할 수 없지만 간접적으로 확인할 수 는 있다. getOwnPropertyDescriptor 메서드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor)객체를 반환한다. 3. 데이터 프로퍼티와 접근자 프로퍼티 데이터 프로퍼티 : 키와 값…","frontmatter":{"categories":"javascript","title":"16. 프로퍼티 어트리뷰트","date":"December 01, 2021"},"fields":{"slug":"/자바스크립트/16.프로퍼티 어트리뷰트/"}}},{"node":{"id":"90a2b090-eaa8-5597-a0dd-5fc70e8611cb","excerpt":"1. var 키워드의 문제점 변수 중복 선언 허용 함수 레벨 스코프 : var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. 변수 호이스팅 : 변수 선언문 이전에 변수를 참조하는것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다. 2. let 키워드 변수 중복 선언 금지 블록 레벨 스코프 변수 호이스팅 : let키워드로 선언한 변수는 선언단계와 초기화단계가 분리되어 진행된다. 만약 초기화 되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. 스코프의 시작지점부터 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal Dead Zone) TDZ 라고 부른다. 3. 전역객체와 let let 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 아니다. 4. …","frontmatter":{"categories":"javascript","title":"15. let, const 키워드와 블록 레벨 스코프","date":"November 30, 2021"},"fields":{"slug":"/자바스크립트/15.let,const키워드와 블록레벨 스코프/"}}},{"node":{"id":"eacaa79a-7be0-5761-bbb0-05e2061e38cf","excerpt":"1. 변수의 생명주기 1-1. 지역변수의 생명주기 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 즉 변수는 생명주기(Life Cycle)가 있다. 변수에 생명주기가 없다면 한번 선언된 변수는 영원히 메모리 공간을 점유하게 된다.\n지역변수의 생명주기는 함수의 생명주기와 일치한다. 변수의 생명주기는 메모리 공간이 확보(allocate)된 시점부터 메모리 공간이 해제(release)되어 가용 메모리풀(memory pool)에 반환되는 시점까지다. 함수 내부에서 선언된 지역 변수는 함수가 생성한 스코프에 등록된다. 할당된 메모리 공간은 더 이상 그 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다. 즉 누군가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 상태로 남아 있게 된다. 마찬가지로 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다. 1-2. 전역변수의 생명주기 전역코드는 명시적인 호출없이 …","frontmatter":{"categories":"javascript","title":"14. 전역변수의 문제점","date":"November 30, 2021"},"fields":{"slug":"/자바스크립트/14.전역변수의 문제점/"}}},{"node":{"id":"83f6605a-d5de-5f5a-9d9d-c6986a2e1db1","excerpt":"원시타입의 값은 변경 불가능한 값(immutable value)이다. 객체는 변경 가능한 값이다. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(pass by value)라고 한다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by reference)라고 한다. 1. 원시 값 원시 타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값이다. (read only) 데이터의 신뢰성 보장  변경 불가능하다는 것은 변수가 아니라 값에 의한 진술이다. \nprimitive 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 만약 원시값이 변경…","frontmatter":{"categories":"javascript","title":"11. 원시 값과 객체의 비교","date":"November 21, 2021"},"fields":{"slug":"/자바스크립트/11.원시 값과 객체의 비교/"}}},{"node":{"id":"bc81444a-6202-503e-85e2-56080b0e60dd","excerpt":"1. 객체 자바스크립트는 객체(Object) 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 ‘모든 것’이 객체다 원시값을 제외한 나머지값은 모두 객체다. 객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 key와 value로 구성된다. 프로퍼티의 값이 함수일 경우. 일반 함수와 구분하기 위해 메서드(method)라고 부른다. 2. 객체 리터럴에 의한 객체 생성 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다. 객체 리터럴 Object 생성 함수 생성자 함수 Object.create 메서드 클래스 (ES6) 객체 리터럴은 중괄호({…})내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당되는 시점에 자바스크립트 엔진은 리터럴을 해석해 객체를 생성한다 만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다. 객체 리터럴의 중괄호는 코드블록을 의미하지 않는다. 코드 블록의 중괄호 뒤에는 세미콜론…","frontmatter":{"categories":"javascript","title":"10. 객체 리터럴","date":"November 19, 2021"},"fields":{"slug":"/자바스크립트/10.객체 리터럴/"}}},{"node":{"id":"21f6aad8-9d7b-5f96-ad41-00e298008d9c","excerpt":"1. 타입변환이란 자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 따라 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입변환(explict coercion) 또는 타입 캐스팅(type casting)이라 한다. 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시값을 직접 변경하는 것은 아니다. 원시 값은 변경 불가능한 값이므로 변경할 수 없다. 자바스크립트 엔진은 x + ’ ‘을 평가하기 위해 x 변수의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’+ ’ ‘을 평가한다. 이때 \n‘10’은 x변수에 재할당되지 않는다. 즉 암묵적 타입변환은 기존 변수 값을 재할당하여 변경하는 것이 아니다. 2. 암묵적 타입 변환 표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. 자…","frontmatter":{"categories":"javascript","title":"09. 타입변환과 단축 평가","date":"November 18, 2021"},"fields":{"slug":"/자바스크립트/09.타입변환과 단축 평가/"}}},{"node":{"id":"c3072eda-9e6d-5d5a-be24-834de8586e49","excerpt":"9. What is the difference between == and === operators JavaScript provides both strict(===, !==) and type-converting(==, !=) equality comparison.  The strict operators take type of variable in consideration, while non-strict operators make type correction/conversion based upon values of variables. The strict operators follow the below conditions for different types, Two strings are strictly equal when they have the same sequence of characters, same length, and same characters in corresponding p…","frontmatter":{"categories":"intervirew","title":"interview","date":"November 17, 2021"},"fields":{"slug":"/INTERVIEW/interview/"}}},{"node":{"id":"578f3370-5c06-5e2e-ba6e-625a711313d4","excerpt":"1. 블록문 블록문(block statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 2. 조건문 조건문(conditional statement)는 주어진 조건식의 평가결과에 따라 코드 블록의 실행을 결정한다. 자바스크립트는 if else문과 switch문으로 두 가지 조건문을 제공한다. if문의 조건식은 boolean값으로 평가되어야 한다. boolean값이 아닐경우 암묵적으로 boolean값으로 강제 변환되어 실행할 코드 블록을 결정한다. 대부분의 if else문은 삼항 조건 연산자로 바꿔 쓸수 있다. 조건에 따라 값을 결정하여 변수에 할당하는 경우 if else 보다 삼항 조건 연산자를 사용하는 편이 가독성이 좋다. 하지만 조건에 따라 실행해야 할 내용이 복잡하여 여러 줄의 문이 필요하다면 if else문을 사용하는 편이 가독성이 좋다. switch문은 주어진 표현식을 평가…","frontmatter":{"categories":"javascript","title":"08. 제어문","date":"November 13, 2021"},"fields":{"slug":"/자바스크립트/08.제어문/"}}},{"node":{"id":"a60b7614-b3fd-5820-a945-6e2996711bdb","excerpt":"연산자(operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수연산등을 수행하여 하나의 값을 만든다. 이때 연산의 대상을 피연산자(operand)라고 한다. 피연산자는 ‘값’이라는 역할을 하며 연산자는 ‘피연산자를 연산하여 새로운 값을 만든다.’ 1. 산술 연산자 산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술연산이 불가능한 경우 NaN을 반환한다. 1-1. 이항 산술 연산자 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수효과(side effect)가 없다. 즉 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만들어 낸다. 1-2. 단항 산술 연산자 단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 값을 만든다.\n증가/감소(++/—) 연산자는 피연산자의 값을 변경하는 부수효과가 있다.\n즉 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다. 숫자 타입이 아닌 피연산자…","frontmatter":{"categories":"javascript","title":"07. 연산자","date":"November 12, 2021"},"fields":{"slug":"/자바스크립트/07.연산자/"}}},{"node":{"id":"9dd21e96-2ce1-55b2-9df8-76554309656c","excerpt":"데이터타입은 값의 종류를 말한다. 자바스크립트는 7개의 데이터 타입을 제공한다.\n7개의 데이터 타입은 원시타입(primitive type)입과 객체타입(object/reference type)으로 분류할 수 있다. 1. 숫자 타입 숫자 타입의 값은 모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 존재하지 않는다. 정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다. 2. 문자열 타입 문자열 타입은 텍스트 데이터를 나타내는데 사용한다.\n문자열은  ”, \"\", 으로 텍스트를 감싼다.\n다른타입의 값과 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로…","frontmatter":{"categories":"javascript","title":"06. 데이터타입","date":"November 11, 2021"},"fields":{"slug":"/자바스크립트/06.데이터 타입/"}}},{"node":{"id":"7327ae1f-2626-53da-b042-638a90c2aef3","excerpt":"1. 값 값(value)은 식(expression)이 평가(evaluate)되어 생성된 결과를 말한다. 2. 리터럴 리터럴(literal)은  사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation)을 말한다.\n자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다. 즉 리터럴은 값을 생성하기 위해 미리 약속한 표기법이라고 할 수 있다. 리터럴 예시 비고 정수 리터럴 100  부동소수점 리터럴 10.5  2진수 리터럴 0b010001 0b로 시작 8진수 리터럴 0o101 ES6에서 도입 0o로 시작 16진수 리터럴 0x41 ES6에서 도입 0x로 시작 문자열 리터럴 ‘Hello’  불리언 리터럴 true false  null 리터럴 null  undefined 리터럴 undefined  객체 리터럴 {name: ‘Lee’, address: ‘Seoul’}  배열 리터럴 1,2,3  함수 리터럴 function() {}…","frontmatter":{"categories":"javascript","title":"05. 표현식과 문","date":"November 10, 2021"},"fields":{"slug":"/자바스크립트/05.표현식과 문/"}}},{"node":{"id":"42b705d1-3dff-5534-ba07-94bdd835188d","excerpt":"1. 변수 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간단히 말하자면 변수는 값의 위치를 가리키는 상징적인 이름이다. 10+20은 연산을 통해 새로운 값 30을 생성한다. 연산을 통해 생성된 값 30은 메모리 공간에 저장된다. 이때 메모리에 저장된 값 30을 다시 읽어 들여 재사용할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인것이 변수이다. 변수에 값을 저장하는 것을 할당(assignment)이라 하고 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다. 2. 식별자 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다.\n식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 의미이다. 식별자 3.변수 선언 변수를 사용하려면 반드시 선언이 …","frontmatter":{"categories":"javascript","title":"04. 변수","date":"November 09, 2021"},"fields":{"slug":"/자바스크립트/04.변수/"}}},{"node":{"id":"ca8e4070-0bb6-54c6-80ac-44428080e797","excerpt":"","frontmatter":{"categories":"알고리즘","title":"알고리즘","date":"October 25, 2021"},"fields":{"slug":"/알고리즘/기초/"}}},{"node":{"id":"3fc8376d-d467-5b77-9a99-ced2558a07a4","excerpt":"","frontmatter":{"categories":"PROJECT","title":"AI 홈트레이너","date":"July 01, 2021"},"fields":{"slug":"/PROJECT/fit-sibang/"}}}]},"site":{"siteMetadata":{"language":"ko","author":{"name":"한상준","bio":{"role":"개발자","description":["프론트 엔드"],"thumbnail":"profile.png"},"social":{"github":"https://github.com/sangzun-han","linkedIn":"","email":""}}}}},"pageContext":{}},"staticQueryHashes":["1073350324","1562467322","2938748437"]}