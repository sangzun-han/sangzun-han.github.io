{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/프로젝트/market/",
    "result": {"data":{"cur":{"id":"c10a6595-9947-509a-9779-92ff07cbc121","html":"<p>리액트를 이용하여 간단히 몇가지 기능이 있는 마켓을 만들었습니다.</p>\n<h2 id=\"구현사항\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84%EC%82%AC%ED%95%AD\" aria-label=\"구현사항 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구현사항</h2>\n<ul>\n<li>쇼핑 아이템 목록 페이지 구현</li>\n<li>아이템의 상세페이지 구현</li>\n<li>상세페이지 내에서 옵션,갯수 선택 가능</li>\n<li>옵션과 아이템 선택 갯수에 따라 상품의 총액 계산 노출</li>\n<li>장바구니 담기 구현</li>\n<li>아이템 상세에서 장바구니에 담기를 클릭하면 상단에 구현된 장바구니 아이콘 옆에 담긴 상품 갯수 노출</li>\n<li>장바구니 목록 페이지 구현</li>\n<li>장바구니 목록에는 아이템명과 아이템의 옵션, 수량, 개별금액, 총 금액 노출</li>\n<li>총 3개의 페이지 구현 → 목록 / 상세 / 장바구니</li>\n<li>금액은 노출될때 천원단위 콤마 표시</li>\n<li>상품목록 정렬기능</li>\n</ul>\n<h3 id=\"프로젝트를-진행하면서-남겨두었던-기록입니다\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EB%A9%B4%EC%84%9C-%EB%82%A8%EA%B2%A8%EB%91%90%EC%97%88%EB%8D%98-%EA%B8%B0%EB%A1%9D%EC%9E%85%EB%8B%88%EB%8B%A4\" aria-label=\"프로젝트를 진행하면서 남겨두었던 기록입니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝트를 진행하면서 남겨두었던 기록입니다.</h3>\n<hr>\n<p><a href=\"https://www.youtube.com/channel/UCfYXOsh_ySGqR7Wy8Qw1vPg/videos\">Youtube</a>\n<a href=\"https://github.com/sangzun-han/open-market\">Github</a></p>","excerpt":"리액트를 이용하여 간단히 몇가지 기능이 있는 마켓을 만들었습니다. 구현사항 쇼핑 아이템 목록 페이지 구현 아이템의 상세페이지 구현 상세페이지 내에서 옵션,갯수 선택 가능 옵션과 아이템 선택 갯수에 따라 상품의 총액 계산 노출 장바구니 담기 구현 아이템 상세에서 장바구니에 담기를 클릭하면 상단에 구현된 장바구니 아이콘 옆에 담긴 상품 갯수 노출 장바구니 목록 페이지 구현 장바구니 목록에는 아이템명과 아이템의 옵션, 수량, 개별금액, 총 금액 노출 총 3개의 페이지 구현 → 목록 / 상세 / 장바구니 금액은 노출될때 천원단위 콤마 표시 상품목록 정렬기능 프로젝트를 진행하면서 남겨두었던 기록입니다. Youtube\nGithub","frontmatter":{"date":"June 05, 2022","title":"오픈마켓","categories":"프로젝트","author":"sangzun","emoji":"😂"},"fields":{"slug":"/프로젝트/market/"}},"next":{"id":"d1e24eca-7eaf-5bd1-b5de-f75d2b231593","html":"<h1 id=\"1-타입은-값들의-집합\" style=\"position:relative;\"><a href=\"#1-%ED%83%80%EC%9E%85%EC%9D%80-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9\" aria-label=\"1 타입은 값들의 집합 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 타입은 값들의 집합</h1>\n<p>타입스크립트의 타입은 <code class=\"language-text\">할당 가능한 값들의 집합</code>이다.</p>\n<p><code class=\"language-text\">never</code>타입은 값들이 없는 집합 즉 공집합이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x: never = 12; // error</code></pre></div>\n<p><code class=\"language-text\">unknown</code>은 어떠한 값이든 할당할 수 있는 집합 즉 전체집합이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const x: unknown = \"aa\"</code></pre></div>\n<p>그 다음으로 작은 집합은 한가지 값만 포함하는 리터럴타입이다. 두개 혹은 세 개로 묶으려면 <code class=\"language-text\">유니온(union)</code> 타입을 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type A = \"A\";\ntype B = \"B\";\ntype Twelve = 12;\ntype AB = \"A\" | \"B\";</code></pre></div>\n<p><code class=\"language-text\">&amp;</code>연산자는 두 타입의 교집합이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {\n  name: string;\n}\n\ninterface Lifespan {\n  birth: Date;\n  death?: Date;\n}\n\ntype PersonSpan = Person &amp; Lifespan;</code></pre></div>\n<p>위 코드를 보면 공통을 가지는 속성이 없기 때문에 <code class=\"language-text\">never</code>타입이 될것같지만 타입 연산자는 인테페이스의 속성이 아닌 타입의 범위에 적용된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다 따라서 Person과 Lifespan을 둘다 가지는 값은 PersonSpan 타입에 속하게 된다.</p>\n<p>따라서 아래의 코드는 정상적으로 작동한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const ps: PersonSpan = {\n  name: \"Kim\",\n  birth: new Date('1919/01/01'),\n  death: new Date('1920/02/01'),\n};</code></pre></div>\n<p>조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 사용하는것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {\n  name: string;\n}\n\ninterface PersonSpan extends Person {\n  birth: Date;\n  death?: Date;\n}</code></pre></div>\n<p>즉 A는 B를 상속 = A는 B에 할당 가능 = A는 B의 서브타입 = A는 B의 부분집합 모두 같은 의미이다.</p>\n<h1 id=\"2-타입공간-값공간\" style=\"position:relative;\"><a href=\"#2-%ED%83%80%EC%9E%85%EA%B3%B5%EA%B0%84-%EA%B0%92%EA%B3%B5%EA%B0%84\" aria-label=\"2 타입공간 값공간 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 타입공간 값공간</h1>\n<p>타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한곳에 존재한다. 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Cylinder {\n  radius: number;\n  height: number;\n}\n\nconst Cylinder = (radius:number, height:number) => ({radius,height});</code></pre></div>\n<p>위 코드에서 inteface Cylinder에서 Cylinder는 타입으로 쓰인다. const Cylinder에서 Cylinder와 이름은 같지만 아무련 관련도 없다. 이런 부분이 가끔 오류를 야기한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function calculateVolumn(shap: unknown) {\n  if (shape instanceof Cylinder) {\n    shape.radius\n  }\n}</code></pre></div>\n<p>위 코드는 instanceof를 이용해서 shape가 Cylinder타입인지 체크하려고 한다. 그러나 instanceof는 자바스크립트의 런타임 연산자이고, 값에 대해서 연산을 한다. 따라서 instanceof Cylinder는 타입이 아니라 함수를 참조한다.</p>\n<ul>\n<li>모든 값은 타입을 가지지만 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.</li>\n<li>class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.</li>\n</ul>\n<h1 id=\"3-타입-단언--타입-선언\" style=\"position:relative;\"><a href=\"#3-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8--%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8\" aria-label=\"3 타입 단언  타입 선언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 타입 단언 &#x3C; 타입 선언</h1>\n<p>타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {name: string};\n\nconst alice: Person = {name: 'Alice'}; // type: Person\nconst bob = {name: 'Bob'} as Person; // type: Person</code></pre></div>\n<p>두 가지 방법은 결과가 같아 보이지만 그렇지 않다. 첫번째 alice는 변수에 <code class=\"language-text\">타입 선언(: Type)</code>을 붙여서 그 값이 선언된 타입을 명시하는것이고 두번째 as Person은 <code class=\"language-text\">타입 단언(as Type)</code>을 수행한다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.</p>\n<p>타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다. 타입 단언은 강제로 타입을 지정했기 때문에 타입체커는 오류를 무시한다.</p>\n<p>화살표 함수에서 타입선언은 단언문을 쓰지 않고 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {name: string};\n\nconst people: Person[] = ['alice', 'bob', 'jan'].map(\n  (name): Person => ({name})\n)</code></pre></div>\n<h1 id=\"4-객체-래퍼-타입-피하기\" style=\"position:relative;\"><a href=\"#4-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0\" aria-label=\"4 객체 래퍼 타입 피하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 객체 래퍼 타입 피하기</h1>\n<ul>\n<li>기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 쓰인다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.</li>\n<li>타입스크립트 객체 래퍼 타입은 지양하고, 기본형 타입을 사용해야 한다.</li>\n</ul>\n<h1 id=\"5-잉여-속성-체크의-한계\" style=\"position:relative;\"><a href=\"#5-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"5 잉여 속성 체크의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 잉여 속성 체크의 한계</h1>\n<p>타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 타입의 속성이 있는지, 그 외의 속성은 없는지 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Person {\n  name: string;\n  age: number;\n}\n\nconst kim: Person = {\n  name: 'kim',\n  age: 30,\n  gender: \"male\"\n}</code></pre></div>\n<p>변수에 타입을 선언함과 동시에 오브젝트 리터럴로 만들게 되면 <code class=\"language-text\">잉여 속성 체크</code>된다. 하지만 아래의 코드는 잉여 속성 체크가 되지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const kim = {\n  name: 'kim',\n  age: 35,\n  gender: 'male'\n}\n\nconst jun: Person = kim;</code></pre></div>\n<p>정상적으로 jun 변수에 kim이 할당되었고 이 과정에서 잉여 속성 체크는 진행되지 않았다. 잉여 속석 체크는 타입 단언문을 사용할 때도 적용되지 않는다. 따라서 단언문보다 선언문을 사용해야 하는 이유 중 하나이다.</p>\n<p>잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 사용하는 방법이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface Options {\n  darkMode?: boolean;\n  [otherOptions:string]: unknown;\n}\n\nconst o: Options = {darkMode: true};</code></pre></div>\n<h1 id=\"6-함수-표현식에-타입-적용\" style=\"position:relative;\"><a href=\"#6-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%81%EC%9A%A9\" aria-label=\"6 함수 표현식에 타입 적용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 함수 표현식에 타입 적용</h1>\n<p>자바스크립트에서는 함수 문장과 함수 표현식을 다르게 인식한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function rollDice1(sides:number): number {} // 문장\nconst rollDice2 = function(sides: number): number {} // 표현식\nconst rollDice3 = (sides: number): number => {} // 표현식</code></pre></div>\n<p>타입스크립트에서는 함수 표현식을 사용하는것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type DiceRollFn = (sides: number) => number;\nconst rollDice: DiceRollFn = sides => {}</code></pre></div>\n<p>만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아본다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type BinaryFn = (x:number, y:numbe) => number;\n\nconst add: BinaryFn = (a,b) => a+b;\nconst sub: BinaryFn = (a,b) => a-b;\nconst mul: BinaryFn = (a,b) => a*b;\nconst div: BinaryFn = (a,b) => a/b;</code></pre></div>\n<h1 id=\"7-타입과-인터페이스의-차이점\" style=\"position:relative;\"><a href=\"#7-%ED%83%80%EC%9E%85%EA%B3%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"7 타입과 인터페이스의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 타입과 인터페이스의 차이점</h1>\n<p>타입스크립트에서 named type을 정의하는 방법은 두 가지이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Tstate = {\n  name: string;\n  capital: string;\n}\n\ninterface IState = {\n  name: string;\n  capital: string;\n}</code></pre></div>\n<p>대부분의 경우 타입과 인터페이스 어느것을 선택하여 사용해도 상관없다. 그러나 같은 상황에서는 동일한 방법으로 타입을 정의해 일관성을 유지해야 한다.</p>\n<p>type은 일반적으로 interface보다 쓰임새가 많다. type 키워드는 유니온이 될 수도있고 매핑된 타입 또는 조건부 타입같은 기능에 활용되기도 한다. 튜플과 배열 타입도 type 키워드를 이용해 더 간결하게 표현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type Pair = [number,number];\ntype StringList = string[];\ntype NameNums = [string, ...number[]];</code></pre></div>\n<p>type과 interface는 타입을 확장하는 방법에 차이가 있다. type은 <code class=\"language-text\">&amp;</code>연산자 interface는 <code class=\"language-text\">extends</code>를 이용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface IStudent2 extends IStudent  {\n  age: number;\n}\n\ntype TStudent2 = TStudent &amp; {\n  age: number;\n}</code></pre></div>\n<p>또한 interface는 동일한 이름으로 다시 interface를 정의해 확장하는것이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface IState {\n  name: string;\n  capital: string;\n}\n\ninterface IState {\n  population: number;\n}\n\nconst wyoming: IState = {\n  name: \"Wyoming\",\n  capital: \"Cheyenne\",\n  population: 500_500;\n}</code></pre></div>","frontmatter":{"date":"April 22, 2022","title":"02. 타입스크립트 타입 시스템","categories":"typescript","author":"sangzun","emoji":null},"fields":{"slug":"/타입스크립트/2.타입스크립트 설정/"}},"prev":{"id":"5a840c16-b138-5010-844d-f8e0795a2b47","html":"<p>라이브러리나 프레임워크 사용 없이 모던자바스크립트만으로 하루에 하나씩 30일동안 30가지 미니 프로젝트를 만드는 챌린지입니다. 프로젝트 아이디어를 떠올리기 어려워 주제와 디자인이 정해진 미니 프로젝트를 따라 만들어보는것으로 시작했습니다.</p>\n<h3 id=\"01-drum-kit\" style=\"position:relative;\"><a href=\"#01-drum-kit\" aria-label=\"01 drum kit permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01. drum-kit</h3>\n<ul>\n<li><code class=\"language-text\">keydown</code>이벤트를 이용해서 입력값을 받아서 정해진 오디오를 재상한다.</li>\n<li>오디오를 재생할 때 해당 키에 .playing 이라는 클래스를 추가해주고 오디오 재생이 끝나면 .playing클래스를 제거한다.</li>\n<li><code class=\"language-text\">transitionend</code>는 transition의 완료를 감지할 수 있는 이벤트이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const play = (event) => {\n  const audio = document.querySelector(`audio[data-key=\"${event.keyCode}\"]`);\n  const key = document.querySelector(`.key[data-key=\"${event.keyCode}\"]`);\n\n  if (!audio) return;\n  audio.currentTime = 0;\n  audio.play();\n  key.classList.add(\"playing\");\n};\n\nconst removeTransition = (event) => {\n  if (event.propertyName === \"transform\")\n    event.target.classList.remove(\"playing\");\n};\n\nconst pianoKeys = document.querySelectorAll(\".key\");\npianoKeys.forEach((el) =>\n  el.addEventListener(\"transitionend\", removeTransition)\n);\n\nwindow.addEventListener(\"keydown\", play);\n</code></pre></div>","frontmatter":{"date":"June 07, 2022","title":"01. JavaScript Challenge","categories":"챌린지","author":"sangzun","emoji":"😂"},"fields":{"slug":"/챌린지/drumkit/"}},"site":{"siteMetadata":{"siteUrl":"https://github.com/sangzun-han","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/프로젝트/market/","nextSlug":"/타입스크립트/2.타입스크립트 설정/","prevSlug":"/챌린지/drumkit/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}