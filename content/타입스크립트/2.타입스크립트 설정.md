---
emoji:
title: 02. 타입스크립트 타입 시스템
date: '2022-04-22 12:00:00'
author: sangzun
tags: 타입스크립트
categories: typescript
---

# 1. 타입은 값들의 집합

타입스크립트의 타입은 `할당 가능한 값들의 집합`이다.

`never`타입은 값들이 없는 집합 즉 공집합이다.

```
const x: never = 12; // error
```

`unknown`은 어떠한 값이든 할당할 수 있는 집합 즉 전체집합이다.

```
const x: unknown = "aa"
```

그 다음으로 작은 집합은 한가지 값만 포함하는 리터럴타입이다. 두개 혹은 세 개로 묶으려면 `유니온(union)` 타입을 사용한다.

```
type A = "A";
type B = "B";
type Twelve = 12;
type AB = "A" | "B";
```

`&`연산자는 두 타입의 교집합이다.

```
interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersonSpan = Person & Lifespan;
```

위 코드를 보면 공통을 가지는 속성이 없기 때문에 `never`타입이 될것같지만 타입 연산자는 인테페이스의 속성이 아닌 타입의 범위에 적용된다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속한다 따라서 Person과 Lifespan을 둘다 가지는 값은 PersonSpan 타입에 속하게 된다.

따라서 아래의 코드는 정상적으로 작동한다.

```
const ps: PersonSpan = {
  name: "Kim",
  birth: new Date('1919/01/01'),
  death: new Date('1920/02/01'),
};
```

조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 사용하는것이다.

```
interface Person {
  name: string;
}

interface PersonSpan extends Person {
  birth: Date;
  death?: Date;
}
```

즉 A는 B를 상속 = A는 B에 할당 가능 = A는 B의 서브타입 = A는 B의 부분집합 모두 같은 의미이다.

# 2. 타입공간 값공간

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한곳에 존재한다. 심벌은 이름이 같더라도 속하는 공간에 따라 다른 것을 나타낼 수 있기 때문에 혼란스러울 수 있다.

```
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius:number, height:number) => ({radius,height});
```

위 코드에서 inteface Cylinder에서 Cylinder는 타입으로 쓰인다. const Cylinder에서 Cylinder와 이름은 같지만 아무련 관련도 없다. 이런 부분이 가끔 오류를 야기한다.

```
function calculateVolumn(shap: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius
  }
}
```

위 코드는 instanceof를 이용해서 shape가 Cylinder타입인지 체크하려고 한다. 그러나 instanceof는 자바스크립트의 런타임 연산자이고, 값에 대해서 연산을 한다. 따라서 instanceof Cylinder는 타입이 아니라 함수를 참조한다.

- 모든 값은 타입을 가지지만 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두가지로 사용될 수 있다.

# 3. 타입 단언 < 타입 선언

타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두 가지이다.

```
interface Person {name: string};

const alice: Person = {name: 'Alice'}; // type: Person
const bob = {name: 'Bob'} as Person; // type: Person
```

두 가지 방법은 결과가 같아 보이지만 그렇지 않다. 첫번째 alice는 변수에 `타입 선언(: Type)`을 붙여서 그 값이 선언된 타입을 명시하는것이고 두번째 as Person은 `타입 단언(as Type)`을 수행한다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다. 타입 단언은 강제로 타입을 지정했기 때문에 타입체커는 오류를 무시한다.

화살표 함수에서 타입선언은 단언문을 쓰지 않고 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적이다.

```
interface Person {name: string};

const people: Person[] = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
)
```

# 4. 객체 래퍼 타입 피하기

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 쓰인다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 한다.
- 타입스크립트 객체 래퍼 타입은 지양하고, 기본형 타입을 사용해야 한다.

# 5. 잉여 속성 체크의 한계

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 타입의 속성이 있는지, 그 외의 속성은 없는지 확인한다.

```
interface Person {
  name: string;
  age: number;
}

const kim: Person = {
  name: 'kim',
  age: 30,
  gender: "male"
}
```

변수에 타입을 선언함과 동시에 오브젝트 리터럴로 만들게 되면 `잉여 속성 체크`된다. 하지만 아래의 코드는 잉여 속성 체크가 되지 않는다.

```
const kim = {
  name: 'kim',
  age: 35,
  gender: 'male'
}

const jun: Person = kim;
```

정상적으로 jun 변수에 kim이 할당되었고 이 과정에서 잉여 속성 체크는 진행되지 않았다. 잉여 속석 체크는 타입 단언문을 사용할 때도 적용되지 않는다. 따라서 단언문보다 선언문을 사용해야 하는 이유 중 하나이다.

잉여 속성 체크를 원하지 않는다면 인덱스 시그니처를 사용하는 방법이 있다.

```
interface Options {
  darkMode?: boolean;
  [otherOptions:string]: unknown;
}

const o: Options = {darkMode: true};
```

# 6. 함수 표현식에 타입 적용

자바스크립트에서는 함수 문장과 함수 표현식을 다르게 인식한다.

```
function rollDice1(sides:number): number {} // 문장
const rollDice2 = function(sides: number): number {} // 표현식
const rollDice3 = (sides: number): number => {} // 표현식
```

타입스크립트에서는 함수 표현식을 사용하는것이 좋다. 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.

```
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => {}
```

만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아본다.

```
type BinaryFn = (x:number, y:numbe) => number;

const add: BinaryFn = (a,b) => a+b;
const sub: BinaryFn = (a,b) => a-b;
const mul: BinaryFn = (a,b) => a*b;
const div: BinaryFn = (a,b) => a/b;
```
