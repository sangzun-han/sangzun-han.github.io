---
emoji:
title: 01. 타입스크립트 알아보기
date: '2022-04-15 12:00:00'
author: sangzun
tags: 타입스크립트
categories: typescript
---

# 타입스크립트 vs 자바스크립트

모든 자바스크립트 프로그램은 타입스크립트 프로그램이다. 하지만 반대는 성립하지 않는다.

```
function greet(who: string) {
  console.log("Hello", who);
}
```

위 코드에서 `string`은 타입스크립트에서 쓰이는 타입 구문이다. 따라서 자바스크립트에서는 오류를 출력한다.

```
let city = "new york city";
console.log(city.toUppercase());
```

위 코드에서 타입 구문이 없지만 타입 체커는 문제점을 찾아낸다. city 변수가 문자열이라는 것을 알려주지 않아도 타입스크립트는 초기값으로부터 타입을 추론한다.

또한 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다. 하지만 모든 오류를 찾지는 못한다. 타입 체커를 통과해도 오류를 발생시키는 코드는 충분히 존재할 수 있다.

# 1. 타입스크립트 설정

타입스크립트 컴파일러는 많은 설정을 가지고 있다. `tsconfing.json`파일을 통해서 설정하거나 커맨드라인에서 사용할 수 있다.

설정을 사용하기 위해서는 `noImplicitAny`와 `strictNullChecks`를 이해해야 한다.

```
function add(x,y) {
  return a+b;
}

function add(x:nubmer, y:number) {
  return x+y;
}
```

`noImplicitAny`는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 판단한다. noImplicitAny가 해제되어 있을때 위의 첫번째 코드는 유효하다.

타입스크립트는 타입 정보를 가질때 효과적인인 언어기 때문에 noImplicitAny를 설정하는것이 좋다.

`strictNullChecks`는 null과 undefined을 모든 타입에서 허용되는지 여부를 설정한다.

```
const x: number = null;
```

strictNullChecks가 해제되었다면 위의 코드는 유효한 값이지만 strictNullChecks를 설정하면 오류가된다.

# 2. 코드 생성과 타입

- 코드 생성은 타입 시스템과 무관하다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.
- 타입오류가 존재하더라도 컴파일은 가능하다.
- 타입스크립트 타입은 런타임에 사용할 수 없다. 런타임에 타입을 지정하려면 타입 정보 유지를 위한 별도의 방법이 필요하며 일반적으로는 태그된 유니온과 속성 체크 방법을 사용한다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있다.

```
// 속성 체크 방법
interface Square {
    width: number;
}

interface Retangle extends Square {
    height: number;
}

type Shape = Square | Retangle;

function calculateArea(shape:Shape) {
    if ('height' in shape) {
        shape;
        return shape.width * shape.height;
    } else {
        shape;
        return shape.width * shape.width;
    }
}

// 태그된 유니온
interface Square {
    kind: 'square';
    width: number;

}

interface Retangle {
    kind: 'retangle';
    height: number;
    width: number;

}

type Shape = Square | Retangle;

function calculateArea(shape: Shape) {
    if (shape.kind === 'retangle') {
        shape;
        return shape.width * shape.height;
    } else {
        shape;
        return shape.width * shape.width;
    }
}
```

# 3. 구조적 타이핑

`duck typing` : 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는것으로 간주하는 방식

자바스크립트는 덕타이핑 기반이다. 어떤 함수의 매개변수 값이 모두 제대로 주어진다면 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용한다.

```
interface Vector2D {
  x: number;
  y: number;
}

interface NamedVector {
  name: string;
  x: number;
  y: number;
}

function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

const v: NamedVector = {x: 3, y: 4, name: 'Zee' };
calculateLength(v); //5
```

위 코드에서 NamedVector의 구조가 Vector2D와 호환되기 때문에 calculateLength 호출이 가능하다. 즉 타입스크립트 타입시스템은 `구조적으로`타입이 맞기만 한다면 이를 허용한다 이것이 구조적 타이핑이다.

- 자바스크립트는 덕타이핑 기반이고 타입스크립트는 구조적 타이핑을 사용한다.
- 타입은 `봉인` 되어 있지 않다.
- 클래스 또한 구조적 타이핑을 따르고 있으므로 클래스의 인스턴스가 예상과 다를 수 있다.
- 구조적 타이핑은 유닛테스트시에 유용하다.

# 4. any 타입 지양

타입스크립트의 타입 시스템은 `gradual`이고 `optional`이다. 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다. 이것들의 핵심은 `any`다.

- `any`타입을 사용하면 타입체커와 타입스크립트의 여러가지 서비스를 무력화시킨다. any타입은 문제점을 감추고 타입 시스템의 신뢰도를 떨어뜨린다. 사용을 자제하는것이 좋다.
