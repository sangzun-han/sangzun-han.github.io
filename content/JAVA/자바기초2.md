---
emoji: 😂
title: '자바 기초 2'
date: '2022-07-31 20:00:00'
author: sangzun
tags: 자바,JAVA
categories: JAVA
---

## 객체와 클래스

- 현실의 객체가 갖는 속성과 기능은 `추상화` 되어 클래스에 정의된다.
- 클래스는 구체화되어 프로그램의 `객체` 가 된다.
- 내가 필요한 것들(특징,기능)로만 구성된 객체를 만들어낼 수 있는 클래스를 정의
  - ⇒ `추상화`
- 클래스 - 붕어빵틀
- 객체 - 붕어빵

```java
String str = new String("Hello");

String str2 = "Hello"; // 리터럴
String str3 = "Hello"; // 같은값을 가진 String객체가 있기 때문에 str2를 참조
/*
new를 이용한 선언은 힙영역에 String객체가 만들어짐
리터럴은 클래스영역(string,literal,pool)에 만들어진다.
String도 immutable 하다
*/
```

## 객체 메모리 구조

1. static 영역에 static 변수, static 메서드를 올림
2. stack 영역에 참조 변수 선언
3. heap 영역에 객체 생성
   - 객체의 멤버변수만 생성
   - 메서드는 일반 영역에 한번만 생성되며 객체와 링크시켜 놓음
4. 객체의 주소를 stack 영역의 참조변수에 할당

### 메소드 오버로딩

- 메소드이름은 같고, 매개변수 타입이나 개수가 다른 달라 다른 메소드로서 동작
- 같은 기능이지만 상황에 따라 유연하게 사용해야하는 경우
  - Ex) printf, 생성자

### 생성자

- 객체를 생성하고 멤버 변수 초기화, 또는 초기설정
- default 생성자는 어떠한 생성자도 없는 경우에만 컴파일러에 의해 제공

---

# OOP

### Object 클래스

- 모든 클래스의 조상 클래스
  - 별도의 `extends` 선언이 없는 클래스들은 extends Object가 생략
  - 따라서 모든 클래스에는 Object 클래스에 정의된 메서드가 있음

# OOP is A P.I.E

1. Abstraction(추상화)
2. Polymorphism(다형성)
3. Inheritance(상속)

   - 기존 클래스의 자산을 자식 클래스에서 재사용
   - 부모의 생성자와 초기화 블록은 상속하지 않는다.
   - 기존 클래스의 멤버를 물려받기 때문에 코드의 절감
   - `상속의 관계는 is a 관계라고 함`
   - 자바는 단일 상속만 지원

   ```java
   public class Person {
   	String name;

   	void eat() {}
   	void jump() {}
   }

   public class SpiderMan extends Person {
   	boolean isSpider;
   	void fireWeb(){}
   }
   ```

   ![Java](/javaprimary2-12.png)

4. Encapsulation(데이터 은닉과 보호)

### 메서드 오버라이딩(overriding)

- 조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 것

### 오버라이딩 조건

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수, 타입, 순서가 같아야 한다.
3. 리턴 타입이 같아야 한다.
4. 접근 제한자는 부모 보다 범위가 넓거나 같아야 한다.
5. 조상보다 더 큰 예외를 던질수 없다.

```java
public class Person {
	void jump() {
		System.out.println("두 다리로 힘껏 점프");
	}
}

public class Spider {
	void jump() {
		System.out.println("키 * 100만큼 엄청난 점프");
	}
}

public class SpiderMan2 extends Person {
	Spider spider = new Spider();
	boolean isSpider;

	void fireWeb() {...}
	void jump() {
		if (isSpider) spider.jump();
		else System.out.println("두 다리로 힘껏 점프");
	}
}
```

### Annotation

- 컴파일러, JVM, 프레임워크 등이 보는 주석
- 소스코드에 메타 데이터를 삽입하는 형태
  - 소스 코드에 붙여 놓은 라벨
  - 코드에 대한 정보 추가 → 소스 코드의 구조 변경, 환경 설정 정보 추가등의 작업 진행
  ```java
  @Deprecated
  - 컴파일러에게 해당 메서드가 deprecated 되었다고 알려줌
  @Override
  - 컴파일러에게 해당 메서드는 override한 메서드임을 알려줌
  - @Override가 선언된 경우 반드시 super class에 선언 되어있는 메서드 여야 함
  @SuppressWarnings
  - 컴파일러에게 사소한 waring의 경우 신경 쓰지 말라고 알려줌
  ```

## 접근제한자와 데이터 은닉과 보호

- 제한자(modifier)
  - 클래스,변수,메서드 선언부와 함께 사용되어 부가적인 의미 부여
- 종류 : 접근 제한자(public,private,protectedf,default),그 외 제한자
  - 하나의 대상에 여러 제한자를 조합 가능하나 접근 제한자는 하나만 사용 가능
  - 순서는 무관하지만 일반적으로 접근제한자를 맨 앞에 사용

### Final

- final class → 더 이상 확장 할 수 없음, 상속금지 → override방지

```java
final class PerfectClass{...}
// final 클래스는 확장 할 수 없음
public class FinalClassTest extends PerfectClass{...}
```

- final method → 더 이상 재 정의 할 수 없음 → overriding 금지

```java
class ParentClass {
	public final void finalMethod(){}
}

public FinalClassTest extends ParentClass {
	// final 클래스는 오버라이딩 금지
	public void finalMethod() {}
}
```

- final variable → 더 이상 값을 바꿀수 없음 → 상수화

```java
public void finalParameterTest(final String name) {
	System.out.println(name);
	// final 변수는 값 변경 불가능
	name = "hong";
}
```

### 접근 제한자(Access modifier)

- 멤버 등에 사용되며 해당 요소를 외부에서 사용할 수 있는지 설정

![Java](/javaprimary2-1.png)

- method override 조건 확인

```java
class Parent {
	protected void method() {}
}

public class OverrideRule extends Parent {
	@Override
	void method() {} // 조상보다 더 큰 예외를 던질수 없다.
	protected void method() {}
	public void method() {}
}

```

### Encapsulation

- 누군가 정보를 마음대로 바꾼다면?

```java
class UnbelievableUserInfo {
	public String name = "홍길동"; // 이름은 not null
	public int account = 10000;  // 계좌는 0보다 커야함
}

public class UnbelievalbeTest {
	public static void main(String[] args) {
			UnbelievableUserInfo info = new UnbelievableUserInfo();
			info.name = null;
			info.account = -1000;
	}
}
```

- 외부에서 변수에 직접 접근하기때문에 정보가 보호되지 못한다.
- 공개되는 메서드를 통한 접근 통로 마련 : `setter/getter` → 메서드에 정보 보호 로직 작성

```java
class UnbelievableUserInfo {
	//이름은 null이 될 수 없음.
	private String name = "홍길동";
	// 계좌는 0보다 커야 함.

	private int account = 10000;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		if(name != null) this.name = name;
		else System.out.println("제대로 된 이름을 넣어!");
	}

	public int getAccount() {
		return account;
	}

	public void setAccount(int account) {
		if(account >= 0) this.account = account;
		else System.out.println("마이너스 통장은 안돼!!");
	}

	// TODO: name 과 account에 부적절한 값이 할당되지 못하도록 처리하시오.
	//  name과 account 는 private으로 변경되어야 한다.
    // END:
}

public class UnbelievableTest {
	public static void main(String[] args) {
		UnbelievableUserInfo info = new UnbelievableUserInfo();
		System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
		info.setName(null);
		info.setAccount(-1000);
		System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
	}
}
```

### 객체의 생성 제어와 Singleton 디자인 패턴

- 객체의 생성을 제한해야 한다면?
- 여러개의 객체가 필요없는 경우
  - 객체를 구별할 필요가 없는 경우 = 수정 가능한 멤버변수가 없고 기능만 있는 경우 `stateless 객체`
- 객체를 계속 생성/삭제 하는데 많은 비용이 들어서 재사용이 유리한 경우

Singloton 디자인 패턴

- 외부에서 생성자에 접근 금지 → 생성자의 접근 제한자를 private으로 설정
- 내부에서는 private에 접근 가능하므로 직접 객체 생성 → 멤버 변수이므로 private 설정
- 외부에서 private member에 접근 가능한 getter생성 → setter 필요하지 않음
- 객체없이 외부에서 접근할 수 있도록 getter와 변수에 static 추가
- 외부에서는 언제나 getter를 통해서 객체를 참조하므로 하나의 객체 재사용

```java
class SingletonClass {
	// TODO:SingletonClass에 Singleton Design Pattern을 적용하시오.
	// stateless 한 클래스 : 상태를 가지지 않고 기능만 가짐
	// END:
	private SingletonClass() {}

	private static SingletonClass sc = new SingletonClass();
	public static SingletonClass getSingleTonClass() {
		return sc;
	}

	public void sayHello() {
		System.out.println("Hello");
	}
}

public class SingletonTest {
	public static void main(String[] args) {
		// TODO:SingletonClass를 사용해보세요.
		SingletonClass sc = SingletonClass.getSingleTonClass();
		sc.sayHello();
		// END:
	}
}
```

# 다형성 (Polymorphism)

- 하나의 객체가 많은 타입을 가질 수 있는 성질
- `상속 관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 레퍼런스 할 수 있다.`

![Java](/javaprimary2-2.png)

```java
SpiderMan onlyOne = new SpiderMan();
SpiderMan sman = onlyOne; // 1

Person person = onlyOne // 2

Object obj = onlyOne // 3

Venom venom = onlyOne;
```

1. onlyOne은 SpiderMan 타입인가?
   1. 예
2. onlyOne은 Person 타입인가?
   1. 예
3. onlyOne은 Object 타입인가?
   1. 예
4. onlyOne은 Venom 타입인가?
   1. 아니요

### 다형성 활용 예시

### 1. 다른타입의 객체를 다루는 배열

- 배열의 특징 : 같은 타입의 데이터를 묶음으로 다룬다.
- 다형성으로 다른 타입의 데이터를 하나의 배열로 관리

```java
void beforePoly() {
	Person[] persons = new Person[10];
	persons[0] = new Person();
	SpiderMan[] spiderMans = new SpiderMan[10];
	spiderMans[0] = new SpiderMan();
}

void afterPoly() {
	Person[] persons = new Person[10];
	persons[0] = new Person();
	persons[1] = new SpiderMan();
}
```

- Object는 모든 클래스의 조상 → Object 배열은 어떤 타입의 객체라도 다 저장할 수 있음

### 2. 매개변수의 다형성

- 메서드가 호출되기 위해서는 메서드이름과 매개변수가 맞아야 한다.
- 조상을 파라미터로 처리한다면 객체의 타입에 따라 메서드를 만들필요가 없다.

## 다형성과 참조형 객체의 형 변환

- 메모리에 있는 것과 사용할 수 있는 것의 차이

![Java](/javaprimary2-3.png)

- 메모리에 있더라도 참조하는 변수의 타입에 따라 접근할 수 있는 내용이 제한됨
- 작은 집에서 큰집으로 → 묵시적 캐스팅
- 자손타입의 객체를 조상 타입으로 참조 : 형변환 생략 가능
  - why? 조상의 모든 내용이 자식에 있기 때문

```java
Phone phone = new Phone();
Object obj = phone;
```

- 큰집에서 작은집으로 → 명시적 캐스팅
- 조상 타입을 자손타입으로 참조 : 형변환 생략 불가

```java
Phone phone = new SmartPhone();
SmartPhone sPhone = (SmartPhone)phone;
```

![Java](/javaprimary2-4.png)

- 무늬만 SpiderMan인 Person
- 메모리의 객체는 fireWeb()이 없음

—> 조상을 무작정 자손으로 바꿀수는 없다.

`instanceof` : 실제 메모리에 있는 객체가 특정 클래스 타입인지 boolean으로 리턴

```java
Person person = new Person();
SpiderMan sman = (SpiderMan)person;
sman.fireWeb();

if(person instanceof SpiderMan) SpiderMan sman = (SpiderMan)perosn;
```

### 참조 변수의 레벨에 따른 객체의 멤버 연결

```java
class SuperClass {
	String x = "super";

	public void method() {
		System.out.println("super class method");
	}
}

class SubClass extends SuperClass {
	String x = "sub";

	@Override
	public void method() {
		System.out.println("sub class method");
	}
}

public class MemberBindingTest {
	public static void main(String[] args) {
		SubClass subClass = new SubClass();
		System.out.println(subClass.x);
		subClass.method();

		SuperClass superClass = subClass;
		System.out.println(superClass.x);
		superClass.method();
	}
}
```

- 상속관계에서 객체의 멤버 변수가 중복 될 때
  - 참조 변수의 타입에 따라 연결이 달라짐
- 상속관계에서 객체의 메소드가 중복될 때(메서드가 override 되었을 때)
  - 무조건 자식 클래스의 메서드가 호출됨 → virtual method invocation
  - 최대한 메모리에 생성된 실제 객체에 최적화된 메서드가 동작

## 추상 클래스

- `abstract` 클래스는 상속 전용의 클래스

### 사용이유?

- abstract 클래스는 구현의 강제를 통해 프로그램의 안정성 향상

## Interface

- 최고 수준의 추상화 단계 : 일반 메서드는 모두 `abstract` 형태
  - JDK 8에서 default method와 static method 추가
- 형태

  - 클래스와 유사하게 interface 선언
  - 멤버 구성

    - 모든 멤버 변수는 `public static final` 이며 생략 가능
    - 모든 메서드는 `public abstract` 이며 생략 가능

    ```java
    public interfcae MyInterfcae {
    	public static final int MEMBER1 = 10;
    	int MEMBER2 = 10;

    	public abstract void method1(int param);
    	void method2(int pararm);
    }

    ```

- 인터페이스 상속

  - 클래스와 마찬가지로 extends를 이용해 상속이 가능
  - 클래스와 다른점은 인터페이스는 다중 상속이 가능

    - why? 헷갈릴 메서드 구현 자체가 없다.
      ![Java](/javaprimary2-6.png)

    ```java
    interface Fightable {
    	int fire();
    }

    interface Transformable {
    	void changeShape(boolean isHeroMode);
    }

    public interface Heroable extends Fightable, Trasformable {
    	void upgrade();
    }
    ```

  ## 인터페이스 구현과 객체 참조

  - 클래스에서 implemets키워드를 사용해서 interface 구현
  - implements 한 클래스는
    - 모든 abstract 메서드를 override해서 구현하거나
    - 구현하지 않을 경우 abstract 클래스를 명시해줘야함
  - 인터페이스도 하나의 타입 → 다형성 가능

## Interface 필요성

- 구현의 강제로 표준화 처리
  - abstract 메서드 사용

![Java](/javaprimary2-7.png)

- 인터페이스를 통한 간접적인 클래스 사용으로 손쉬운 모듈 교체 지원
- 서로 상속의 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장

![Java](/javaprimary2-8.png)
![Java](/javaprimary2-9.png)

![Java](/javaprimary2-10.png)

![Java](/javaprimary2-11.png)

- 모듈 간 독립적 프로그래밍 가능 → 개발 기간 단축
  - 구현할 내용에 대한 협의

### default method

- 인터페이스에 선언 된 구현부가 있는 일반 메서드
  - 메서드 선언부에 default modifer 추가 후 메서드 구현부 작성
  - 접근 제한자는 public으로 한정됨(생략 가능)
- 필요성
  - 기존에 interfcace 기반으로 동작하는 라이브러리의 interface에 추가해야 하는 기능이 발생
  - 기존 방식으로라면 모든 구현체들이 추가되는 메서드를 override 해야함
  - default 메서드는 abstract가 아니므로 반드시 구현해야 할 필요는 없어짐
- default method의 충돌
  - JDK 1.7이하의 인터페이스 구현부가 없으므로 충돌이 없었음
  - 1.8부터 default method가 생기면서 동일한 이름을 갖는 구현부가 있는 메서드가 충돌
  - method 우선순위
    - super class의 method의 우선 : spuer class가 구체적인 메서드를 갖는 경우 default method 무시된다.
    - interface간의 충돌 : 하나의 interface에서 default method를 제공하고 다른 interface에서도 같은 이름의 메서드가 있을 때 sub class는 반드시 override해서 충돌 해결

## static method

- interface에 선언된 static method
