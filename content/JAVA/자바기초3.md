---
emoji: 😂
title: '자바 기초 3'
date: '2022-07-31 22:00:00'
author: sangzun
tags: 자바,JAVA
categories: JAVA
---

## Generic

- 다양한 타입의 객체를 다루는 메서드, 컬렉션 클래스에서 컴파일시에 타입 체크
- 미리 사용할 타입을 명시해서 형 변환을 하지 않아도 되게함
  - 객체의 타입에 대한 안전성 향상 및 형 변환의 번거로움 감소

## Generic 표현

- 클래스 또는 인터페이스 선언시 <>에 타입 파라미터 표시
- ex) public class className<T> {}
- 타입 파라미터
  - 특별한 의미의 알파벳 보다는 단순히 임의의 참조형 타입을 말함
    - T : reference Type, E: Element, K: Key, V: Value
- 객체 생성
  - 변수 쪽과 생성 쪽의 타입은 반드시 같아야 함
  ```java
  ClassName<Number> generic = new ClassName<Number>();
  ClassName<Number> generic2 = new ClassNameM<>();
  ```
- type parameter의 제한

  - 계산기 프로그램 구현시 Number이하의 타입으로만 제한

    - type parameter 선언 뒤 extends와 함께 상위 타입 명시

    ```java
    class NumberBox<T extends Number> {
    	public void addSomes(T... ts) {
    		double d = 0;
    		for(T t: ts) {
    			d += T.doubleValue();
    		}
    		System.out.println("총 합은: " + d);
    	}
    }

    public class ExtendsTest {
    	public void main(String[] args) {
    		NumberBox<Number>
    	}
    }
    ```

- Generic Type 객체를 할당받을 때
  - Generic type<?> → 타입에 대한 제한 없음(Object)
  - Generic type<? extends T> → T 또는 T를 상속받은 타입들만 사용 가능
  - Geneirc type <? super T> → T 또는 T의 조상 타입만 사용 가능

## Generic Method

- 파라미터와 리턴타입으로 type parameter를 갖는 메서드

  - 메서드 리턴 타입앞에 타입 파라미터 변수 선언

  ```java
  public class TypeParameterMethodTest<T> {
  	T some;
  	public TypeParameterMethodTest(T some) {
  		this.some = some;
  	}

  	public <P> void method1(P p) {...}
  	public <P> void method2(P p) {
  		return p
  	}

  	public static void main(String[] args) {
  		TypeParameterMethodTest<String> tpmt = new TypeParameterMethodTest<>("Hello");
  		tpmt.method1(10)
  		tpmt.<Long>method2(20);
  	}
  }
  ```

## I/O와 Stream

- 데이터는 한쪽에서 주고 한쪽에서 받는 구조로 되어있음
  - 이때 입력과 출력의 끝단 : 노드
  - 두 노드를 연결하고 데이터를 전송할 수 있는 개념 : Stream
  - 스트림은 `단방향` 으로만 통신이 가능하며 하나의 스트림으로 입력과 출력을 같이 처리할 수 없음

### Node Stream의 종류와 naming

- NodeStream : node에 연결되는 스트림
- 데이터 타입에 따라 XXStream,XXer

### 보조스트림

- Filter Stream, Processing Stream
- 다른 스트림에 부가적인 기능을 제공하는 스트림
- 스트림 체이닝(Stream Chaining)
  - 필요에 따라 여러 보조 스트림을 연결해서 사용 가능
- 사용할 스트림의 결정 과정
  - 노드가 무엇인가? → 타입은 문자열인가 바이트인가? → 방향이 무엇인가? → 추가 기능이 필요한가?
  - 영화 파일을 빠른 속도로 이동시키고 싶다면?
    - File → byte → 읽기,쓰기 → FileInputStream, FileOutputStrea
  - 키보드에서 유니코드 문자를 안전하고 빠르게 읽고 싶다면?
    - keyboard → byte → 읽기 → InputStream(System.in) → InputStreamReader → BufferedReader
  - 메모리의 객체를 파일로 저장하고 싶다면?
    - File → byte → 쓰기 → FileOutputStream → ObjectOutputStream

### 객체 직렬화

- 객체를 파일등에 저장하거나 네트워크로 전송하기 위해 연속적인 데이터로 변환
- 반대의 경우는 역직렬화
- 직렬화 되기 위한 조건
  - Serializable 인터페이스를 구현할 것
  - 클래스의 모든 멤버가 Serializable 인터페이스를 구현해야 함
  - 직렬화 해서 제외하려는 멤버는 transient 선언
- serialVersionUID
  - 클래스의 변경 여부를 파악하기 위한 유일 키
  - 직렬화 할때의 UID와 역 직렬화할때의 UID가 다를 경우 예외 발생
  - 직렬화되는 객체에 UID가 설정되지 않았을 경우 컴파일러가 자동 생성
    - 멤버 변경으로 인한 컴파일 시마다 변경 → InvalidClassException 초래
  - 직렬화되는 객체에 대해서 serialVersionUID 설정 권장

## 공공데이터 XML

- csv (comma separated value) : 용량이 작지만 구조적이지 못함
- XML (Extensible markup language) : 구조적,정확한 문법이 필요, 큰용량
- Json(javascript Object notation) : 구조를 가지며 객체로 다른 언어와 호환

### XML

- Markup Language
  - 태그등을 이용하여 문서나 데이터의 구조를 명시하는 언어
  - HTML, SGML, …
- HTML과 달리 필요에 따라서 태그를 확장해서 사용 가능
- 정확한 문법을 지켜야 동작 : Well formed

### 기본문법

- 문서의 시작은`<?xml version=”1.0” encoding=”UTF-8”?>`로 한다
- 반드시 root element가 존재해야 한다
  - 나머지 태그들은 tree 형태로 구성
- 시작태그와 종료태그는 일치해야 한다
- 시작태그는 key-value 구조의 속성을 가질 수 있다.
  - 속성 값은 “”또는 ‘’로 묶어서 표현
- 태그는 대소문자를 구분

### valid

- xml 태그는 자유롭게 생성하기 때문에 최초 작성자의 의도대로 작성되는지 확인할 필요
  - 문서의 구조와 적절한 요소, 속성들의 개수, 순서들이 잘 지켜졌는가
  - DTD 또는 Schema를 이용해서 문서의 규칙 작성

## 문서의 Parsing - SAX

### 파싱

- 문서에서 필요한 정보를 얻기 위해 태그를 구별하고 내용을 추출하는 과정
  - 전문적인 parser 활용
- SAX parser
  - Simple API for XML parser
  - 문서를 읽으면서 태그의 시작, 종료등 이벤트 기반으로 처리하는 방식
- DOM parser
  - Document Object Model
  - 문서를 다 읽고 난 후 문서 구조 전체를 자료구조에 저장하여 탐색하는 방식
- SAX는 빠르고 한번에 처리하기 때문에 다양한 탐색이 어렵다
- DOM은 다양한 탐색이 가능하지만 느리고 무거우며 큰 문서를 처리하기 어렵다.

### DOM parsing

- 전체 문서를 읽어 tree구조를 메모리에 올려놓음
- 여러번의 탐색 시 문서를 다시 읽어들일 필요 없음
  - 재탐색 시 유리
- 여러 검색 api를 통한 다양한 탐색이 가능
- 문서의 크기가 커지면 메모리 사용량이 늘어남
  - 큰 문서를 처리하는데 불리

### SAX parsing

- 단순 한 번의 검색 시 빠르게 처리가 가능
- 이벤트 기반의 탐색 방식
  - character 이벤트, 시작태그와 종료태그 만날 시 이벤트 발생
-

### JSON

- javascript Object Notation
- 간결한 문법, 단순한 텍스트, 적은 용량으로 대부분의 언어, 대부분의 플랫폼에서 사용 가능
- 객체를 key-value의 쌍으로 관리

## Swing

- Java Application에서 사용되는 GUI를 제공하는 추상적으로 정의된 도구 모음
- Container
  - 다른 컴포넌트들은 배치하기 위한 컴포넌트
  - Container는 다른 Container를 포함할 수 잇고 나중에 복합적인 Layout을 구성할 수 있게 한다.
  - JFrame : 독립적으로 사용될 수 있으며 타이틀과 사이즈를 조절할 수 있는 버튼을 가짐
  - JPanel : 반드시 다른 Container에 포함되어야 하며 복합적인 레이아웃 구성에 사용
- 다른 Component
  - JButton b;
  - JLabel l;
  - JTextField f;
  - JTable table;
  - JList list;

### Layout과 LayoutManager

- Layout : Component들을 Container에 어떻게 배치할 것인가
- LayoutManager : Container별로 Component의 위치와 크기, 배치 방식을 결정하는 객체
- FlowLayout
  - JPanel의 기본 LayoutManager
  - 요소를 가로로 물 흐르듯이 배치
- BoardLayout
  - JFrame의 기본 LayoutManager;
  - 특별한 영역, North,South,West,East,Center에 각각의 컴포넌트들을 배치한다.
    - Component들을 배치할 대는 영역을 지정(BoardLayout.CENTER or “CENTER”)
    - 사용하지 않는 공간은 크기가 0\*0이 되고 Center가 기본이다.
    - 각각의 영역에는 하나의 Component들을 담을 수 있고 중복해서 담을 경우는 마지막에 담은 컴포넌트만 보인다.
    - 크기를 조절할 때 North와 South는 좌우로, East와 West는 상하로만 늘어난다. Center는 양방향

### 이벤트 처리 클래스

- XX Listener
  - 이벤트 처리에 대한 메서드들을 정의한 인터페이스로 handler는 이 인터페이스를 구현
  - 하나의 component에 여러개의 event handler를 붙일 수 있다.
    - Implements ActionListener, WindowListener
- XX EventAdapter
  - Listener를 implements를 할 경우 사용하지도 않는 이벤트 핸들러 까지 다 구현해야 하는 단점
  - xxxEventAdapter implments XXListener
