---
emoji: 😂
title: '시뮬레이션과 구현'
date: '2022-08-20 01:00:00'
author: sangzun
tags: 알고리즘
categories: 알고리즘
---

시뮬레이션과 구현문제들 풀이에 어려움을 겪어서 푼 문제들을 어떻게 접근해서 풀었는지 모두 기록합니다.

### 백준 14499. 주사위 굴리기

- 처음 주사위의 모든 면은 0
- 주사위를 굴렸을 때 이동한 칸에 쓰여있는게 0 이라면 주사위 바닥면에 적혀있는 숫자를 복사한다.
- 주사위를 굴렸을 때 이동한 칸에 쓰여있는게 0이 아니라면 주사위 바닥면에 이동한 칸에 있는 숫자를 복사한다.
- 범위를 벗어나면 무시하며 출력도 하지 않는다.

위의 내용들이 주사위 굴리기 문제의 조건들입니다.

이 문제에서 주사위를 굴리는 방법은 동쪽, 서쪽, 남쪽, 북쪽 4가지 경우 밖에 존재하지 않습니다. 아래 그림을 보면서 한번 이해를 해보면 될것같습니다.
![주사위돌리기](/백준14891-1.jpg)

주사위를 동쪽, 서쪽으로 굴리면 2,5는 고정이 된채로 다른 숫자들이 움직이는걸 알 수 있습니다.

또한 주사위를 남쪽,북쪽으로 굴리면 4,3은 고정이 된채로 다른 숫자들이 움직입니다.

예를들어 주사위를 동쪽으로 굴린다고 가정해보겠습니다.

- 1은 3위치로 움직입니다.
- 3은 6위치로 움직입니다.
- 4는 1위치로 움직입니다.
- 6은 4위치로 움직입니다.

이렇게 동쪽, 서쪽, 남쪽, 북쪽으로 굴릴때 어디로 이동하는지 그림을 그려가면서 모두 파악합니다.

```Java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {
  // 1은 동쪽 2는 서쪽 3은 남쪽 4는 북쪽을 뜻하며
  // 인덱스 번호에 맞도록 0번째에는 0을 추가해 인덱스 크기를 늘렸습니다.
	static int[] dx = {0,0,0,-1,1};
	static int[] dy = {0,1,-1,0,0};

	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(st.nextToken()); // 세로
		int M = Integer.parseInt(st.nextToken()); // 가로
		int x = Integer.parseInt(st.nextToken()); // 주사위 놓은 곳 x좌표
		int y = Integer.parseInt(st.nextToken()); // 주사위 놓은 곳 y좌표
		int K = Integer.parseInt(st.nextToken()); // 명령의 개수
		int[][] map = new int[N][M];

		for(int i=0; i<N; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j=0; j<M; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}

    // 주사위의 숫자는 6개지만 주사위는 1부터 시작하므로 배열의크기를 7로 설정합니다.
		int[] dice = new int[7];
		st = new StringTokenizer(br.readLine());
		for(int i=0; i<K; i++)

      // d는 어디로 굴릴지 1,2,3,4의 값으로 들어오며 순서대로 동쪽, 서쪽, 남쪽, 북쪽을 뜻합니다.
			int d = Integer.parseInt(st.nextToken());
			int nx =  x + dx[d];
			int ny =  y + dy[d];

      // 범위를 벗어날 경우에는 무시하기 때문에 범위를 벗어나는 조건을 가장 먼저 체크합니다.

			// 지도 밖으로 나갔을 때는 다음 반복으로
			if(nx < 0 || nx >= N || ny < 0 || ny >= M) continue;

			// d==1 일경우 동쪽
			if(d==1) {
				int temp = dice[1];
				dice[1] = dice[4];
				dice[4] = dice[6];
				dice[6] = dice[3];
				dice[3] = temp;
			} else if(d==2) { // d==2 일경우 서쪽
				int temp = dice[1];
				dice[1] = dice[3];
				dice[3] = dice[6];
				dice[6] = dice[4];
				dice[4] = temp;
			} else if(d==3) { // d==3 일경우 남쪽
				int temp = dice[1];
				dice[1] = dice[5];
				dice[5] = dice[6];
				dice[6] = dice[2];
				dice[2] = temp;
			} else if(d==4) { // d==4일경우 북쪽
				int temp = dice[1];
				dice[1] = dice[2];
				dice[2] = dice[6];
				dice[6] = dice[5];
				dice[5] = temp;
      }

      // 주사위를 굴린뒤 주사위의 위치를 바꿔줍니다.
			x = nx;
			y = ny;

      // 현재 주사위가 위치한 곳의 값이 0 이라면 주사위 바닥면 숫자를 기록해줍니다.
      // 현재 주사위가 위차한 곳의 값이 0이 아니라면 주사위 바닥면의 숫자를 현재 위치한 지도값으로 바꾼후 0으로 바꿔줍니다.

			if(map[x][y] == 0) {
				map[x][y] = dice[6];
			} else {
				dice[6] = map[x][y];
				map[x][y] = 0;
			}
			System.out.println(dice[1]);
		}
	}
}

```

### 백준 14891 톱니바퀴

- 총 8개의 톱니바퀴를 가지고 있는 톱니바퀴가 4개로 일렬로 정렬

  -> 이차원 배열로 나타내며 배열[i][j] = i번째 톱니바퀴의 정보를 갖고있습니다

- 반시계 방향으로 회전한다면 i번째 배열의 값들을 모두 왼쪽으로 1칸씩 이동시켜줍니다.
- 시계방향으로 회전한다면 i번째 배열의 값들을 모두 오른쪽으로 1칸씩 이동시켜줍니다.
- 회전을 한 뒤 맞닿은 톱니의 극이 다르다면 회전방향과 반대로 회전합니다.

위의 내용들이 문제들의 조건입니다. 생각해볼것은 톱니바퀴의 `회전은 동시에` 일어납니다.
즉 회전을 할 톱니바퀴를 찾았다고 그 톱니바퀴를 먼저 회전시켜버린다면 문제의 조건을 만족하지 못하게됩니다.

따라서 톱니바퀴 하나가 회전할때 다른 톱니바퀴들을 어떻게 되는지 모두 조사를 해본뒤에 한꺼번에 회전을 시켜줍니다.

시계방향은 1, 반시계방향은 -1, 회전하지않음은 0 이고, 회전은 회전방향과 반대로 회전하므로
회전을 해야한다면 -를 붙여서 회전 방향을 정해줍니다.

```Java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main {

  // 톱니바퀴의 수는 4개로 고정되있으며 그 값들은 모두 8개의 값을 가지고 있다.
	static int N = 4;
	static int M = 8;
	public static void main(String[] args) throws Exception{
		int[][] map = new int[N][M];
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		for(int i=0; i<N; i++) {
			String s = br.readLine();
			for(int j=0; j<M; j++) {
				map[i][j] = s.charAt(j) - '0';
			}
		}

		int K = Integer.parseInt(br.readLine()); // K번 회전
		int ans = 0;
		for(int i=0; i<K; i++) {
			st = new StringTokenizer(br.readLine());
			int gear = Integer.parseInt(st.nextToken())-1; // 톱니바퀴 번호
			int dir = Integer.parseInt(st.nextToken()); // 회전 방향

			// 톱니바퀴는 동시에 회전을 해야한다.
			// 따라서 각 톱니바퀴가 어떤 방향으로 회전하는지 구한다.

			int[] d = new int[N]; // 톱니바퀴의 회전 정보
			d[gear] = dir; // 현재 선택된 톱니바퀴의 회전방향을 배열에 저장

			// 현재 선택된 톱니바퀴의 왼쪽에 위치한 모든 톱니바퀴의 회전 정보를 조사
			for(int k=gear-1; k>=0; k--) {
				if(map[k][2] != map[k+1][6]) {
					d[k] = -d[k+1];
				} else break;
			}

			// 현재 선택된 톱니바퀴의 오른쪽에 위치한 모든 톱니바퀴의 회전 정보를 조사
			for(int k=gear+1; k<N; k++) {
				if(map[k][6] != map[k-1][2]) {
					d[k] = -d[k-1];
				} else break;
			}

			for(int k=0; k<N; k++) {
				if(d[k] == 0) continue;

				// 시계방향 회전
				if(d[k] == 1) {
					int temp  = map[k][7];
					for(int l=7; l>=1; l--) {
						map[k][l] = map[k][l-1];
					}
					map[k][0] = temp;
				}
				// 반시계 방향 회전
				else if (d[k] == -1) {
					int temp = map[k][0];
					for(int l=0; l<7; l++) {
						map[k][l] = map[k][l+1];
					}
					map[k][7] = temp;
				}
			}
		}


		if(map[0][0]==1) ans +=1;
		if(map[1][0]==1) ans +=2;
		if(map[2][0]==1) ans +=4;
		if(map[3][0]==1) ans +=8;

		System.out.println(ans);
	}
}

```
