---
emoji: 😂
title: '알고리즘 기초 - 재귀함수'
date: '2022-08-01 00:00:00'
author: sangzun
tags: 알고리즘
categories: 알고리즘
---

## 반복과 재귀

- 반복과 재귀는 유사한 작업을 수행할 수 있다.
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다.

### 재귀 함수 (recursive function)

1. 함수에 대한 정의를 명확히 `What`
2. 평평하게 로직을 바라보기 `Flat`
3. 각 재귀의 실행을 결정하는 결정요인(값)은 `매개변수`로 선언한다.
4. 종료조건 존재?

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수 `자신을 통해 자신을 정의`
- 일반적으로 재귀적 정의를 이용해서 재귀함수를 구현
- 재귀적 프로그램을 작성하는 것은 반복구조에 비해 간결하고 이해하기 쉬움
- 함수 호출은 프로그램 메모리 구조에서 `스택`을 사용
- 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하 발생
  | | 재귀 | 반복 |
  | -------------- | ----------------------------------- | --------------------- |
  | 종료 | 재귀 함수 호출이 종료되는 base case | 반복문의 종료 조건 |
  | 수행시간 | (상대적) 느림 | 빠름 |
  | 메모리 공간 | (상대적) 많이 사용 | 적게 사용 |
  | 소스 코드 길이 | 짧고 간결 | 길다 |
  | 소스 코드 형태 | 선택 구조(if … else) | 반복 구조(for, while) |
  | 무한 반복시 | 스택 오버플로우 | cpu를 반복해서 점유 |

### 피보나치 수열

- 이전의 두 수 합을 다음 항으로 하는 수열
  - F0 = 0, F1 = 1
  - Fn = Fn-1 + fn-2 (n≥2)

```java
// 중복 호출
fibo(n)
	if n<2 return n
	else return fibo(n-1) + fibo(n-2)

/*
memoization
이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록
전체적인 실행속도를 빠르게하는 기술.
*/
```

### 하노이탑

```java
/*
n개의 원판을 이동시켜라
1. 위에서부터 n-1까지 임시기둥으로 옮기기
2. n 원판을 목적기둥으로 옮기기
3. 임시기둥에 있는 n-1개의 원판을 목적기둥으로 옮기기
*/
hanoi(int n, int start, int temp, int end){
	if (n==0) return
	// 위 ~ n-1 이동
	hanoi(n-1, start, end, temp);
	// n 이동
	// n-1을 n위에 이동
	hanoi(n-1, temp,start,end)
}
```

## 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열

`nPr` = n _ (n-1) _ (n-2) _ (n-3) _ … \* (n-r+1)

`npn` = n!

`순서에 의미가 있다면 순열` `순서에 의미가 없다면 조합`

ex) 1~9까지 숫자 한번씩 사용해서 4자리의 비밀번호를 만든다. →9P4 (순열)

ex) 1~9까지 여러번 사용해서 4자리의 비밀번호를 만든다 →9**𝛱**4 (중복순열)

ex) 복권 70개의 숫자중 5개를 뽑는다. → 70C5 (조합)

```java
// {1,2,3]을 포함하는 모든 순열을 생성하는 함수
numbers[] : // 순열 저장 배열
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수

if cnt == 3:
	순열 생성 완료
else
	for i from 1 to 3
		if isSelcted[i] == true then continue
		numbers[cnt] = i
		isSelected[i] = true
		perm(cnt+1)
		isSelected[i] = false
	end for

```

### 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

`nCr` = n! / (n-r)!\*r!

- 조합의 수가 많아지는 경우는 r의값이 n/2

```java
{1,2,3,4} 중 원소 3개를 포함하는 모든 조합을 생성
for i from 1 to 4
	for j to i+1 to 4
		for k from j+1 to 4
				print(i,j,k)
		end for
	end for
end for

// nCr -> n개의 원소 중 r개 원소를 갖는 조합 생성
input[] : n개의 원소를 가지고 있는 배열
numbers[] : r개의 크기의 배열, 조합이 저장될 배열

comb(cnt,start) // cnt: 현재까지 뽑은 조합 원소 개수, start: 조합 시도할 원소의 시작 인덱스
	if cnt == r:
			조합생성 완료
	else
			for i from start to n-1
				numbers[cnt] = input[i]
				comb(cnt+1,i+1)
			end for
```

### 주사위 던지기 1

- 주사위를 3번 던져서 나올 수 있는 모든 경우 → `중복순열`
- n𝜫r

```java
첫번째 두번째 세번재
6 * 6 * 6 = 216가지
6𝜫3주사위
```

### 주사위 던지기 2

- 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 경우 단 123,132,321같은 결과는 서로 다른 경우로 봄 → `순열`

```java
6P3 = 6*5*4 = 120가지
```

### 주사위 던지기 3

- 주사위를 3번 던진 결과가 다음과 같이 중복되는 경우를 제외하고 나올 수 있는 모든 경우(112,121,211 → 중복되는 경우) → `중복조합`

```java
6H3 = 6+3-1C3 = 8C3  = 56가지
nHr = n+r-1Cr
```

### 주사위 던지기 4

- 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우 단 123,132,321와 같은 경우는 중복되는 경우로봄 → `조합`

```java
6C3 = 30가지
```

## 부분 집합

- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘이 원소들의 그룹에서 최적의 부분집합을 찾는 것 ex) knapsack
- 부분집합의 수
  - 집합의 원소가 n개일때 공집합을 포함한 부분집합의 개수는 2^n개 이다.

```java
input[] : 숫자 배열
isSelected[] : 부분 집합에 포함 / 비포함 여부 저장

```
