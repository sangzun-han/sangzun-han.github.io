---
emoji: 😂
title: '알고리즘 기초'
date: '2022-08-01 00:00:00'
author: sangzun
tags: 알고리즘
categories: 알고리즘
---

## 반복과 재귀

- 반복과 재귀는 유사한 작업을 수행할 수 있다.
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다.

### 재귀 함수 (recursive function)

1. 함수에 대한 정의를 명확히 `What`
2. 평평하게 로직을 바라보기 `Flat`
3. 각 재귀의 실행을 결정하는 결정요인(값)은 `매개변수`로 선언한다.
4. 종료조건 존재?

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수 `자신을 통해 자신을 정의`
- 일반적으로 재귀적 정의를 이용해서 재귀함수를 구현
- 재귀적 프로그램을 작성하는 것은 반복구조에 비해 간결하고 이해하기 쉬움
- 함수 호출은 프로그램 메모리 구조에서 `스택`을 사용
- 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하 발생
  | | 재귀 | 반복 |
  | -------------- | ----------------------------------- | --------------------- |
  | 종료 | 재귀 함수 호출이 종료되는 base case | 반복문의 종료 조건 |
  | 수행시간 | (상대적) 느림 | 빠름 |
  | 메모리 공간 | (상대적) 많이 사용 | 적게 사용 |
  | 소스 코드 길이 | 짧고 간결 | 길다 |
  | 소스 코드 형태 | 선택 구조(if … else) | 반복 구조(for, while) |
  | 무한 반복시 | 스택 오버플로우 | cpu를 반복해서 점유 |

### 피보나치 수열

- 이전의 두 수 합을 다음 항으로 하는 수열
  - F0 = 0, F1 = 1
  - Fn = Fn-1 + fn-2 (n≥2)

```java
// 중복 호출
fibo(n)
	if n<2 return n
	else return fibo(n-1) + fibo(n-2)

/*
memoization
이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록
전체적인 실행속도를 빠르게하는 기술.
*/
```

### 하노이탑

```java
/*
n개의 원판을 이동시켜라
1. 위에서부터 n-1까지 임시기둥으로 옮기기
2. n 원판을 목적기둥으로 옮기기
3. 임시기둥에 있는 n-1개의 원판을 목적기둥으로 옮기기
*/
hanoi(int n, int start, int temp, int end){
	if (n==0) return
	// 위 ~ n-1 이동
	hanoi(n-1, start, end, temp);
	// n 이동
	// n-1을 n위에 이동
	hanoi(n-1, temp,start,end)
}
```

## 1. 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개 중 r개를 택하는 순열

`nPr` = n _ (n-1) _ (n-2) _ (n-3) _ … \* (n-r+1)

`npn` = n!

`순서에 의미가 있다면 순열` `순서에 의미가 없다면 조합`

ex) 1~9까지 숫자 한번씩 사용해서 4자리의 비밀번호를 만든다. →9P4 (순열)

ex) 1~9까지 여러번 사용해서 4자리의 비밀번호를 만든다 →9**𝛱**4 (중복순열)

ex) 복권 70개의 숫자중 5개를 뽑는다. → 70C5 (조합)

```java
// {1,2,3]을 포함하는 모든 순열을 생성하는 함수
numbers[] : // 순열 저장 배열
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수

if cnt == 3:
	순열 생성 완료
else
	for i from 1 to 3
		if isSelcted[i] == true then continue
		numbers[cnt] = i
		isSelected[i] = true
		perm(cnt+1)
		isSelected[i] = false
	end for

```

## 2. 조합

- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

`nCr` = n! / (n-r)!\*r!

- 조합의 수가 많아지는 경우는 r의값이 n/2

```java
{1,2,3,4} 중 원소 3개를 포함하는 모든 조합을 생성
for i from 1 to 4
	for j to i+1 to 4
		for k from j+1 to 4
				print(i,j,k)
		end for
	end for
end for

// nCr -> n개의 원소 중 r개 원소를 갖는 조합 생성
input[] : n개의 원소를 가지고 있는 배열
numbers[] : r개의 크기의 배열, 조합이 저장될 배열

comb(cnt,start) // cnt: 현재까지 뽑은 조합 원소 개수, start: 조합 시도할 원소의 시작 인덱스
	if cnt == r:
			조합생성 완료
	else
			for i from start to n-1
				numbers[cnt] = input[i]
				comb(cnt+1,i+1)
			end for
```

### 주사위 던지기 1

- 주사위를 3번 던져서 나올 수 있는 모든 경우 → `중복순열`
- n𝜫r

```java
첫번째 두번째 세번재
6 * 6 * 6 = 216가지
6𝜫3주사위
```

### 주사위 던지기 2

- 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 경우 단 123,132,321같은 결과는 서로 다른 경우로 봄 → `순열`

```java
6P3 = 6*5*4 = 120가지
```

### 주사위 던지기 3

- 주사위를 3번 던진 결과가 다음과 같이 중복되는 경우를 제외하고 나올 수 있는 모든 경우(112,121,211 → 중복되는 경우) → `중복조합`

```java
6H3 = 6+3-1C3 = 8C3  = 56가지
nHr = n+r-1Cr
```

### 주사위 던지기 4

- 주사위를 3번 던져서 모두 다른 수가 나올 수 있는 모든 경우 단 123,132,321와 같은 경우는 중복되는 경우로봄 → `조합`

```java
6C3 = 30가지
```

## 3. 부분 집합

- 집합에 포함된 원소들을 선택하는 것
- 다수의 중요 알고리즘이 원소들의 그룹에서 최적의 부분집합을 찾는 것 ex) knapsack
- 부분집합의 수
  - 집합의 원소가 n개일때 공집합을 포함한 부분집합의 개수는 2^n개 이다.

```java
input[] : 숫자 배열
isSelected[] : 부분 집합에 포함 / 비포함 여부 저장

```

## 4.Linked List / Tree

### 1. 리스트

- 순서를 가진 데이터의 집합을 가리키는 추상차료형(abstract data type) → 순서가 있다(index관리, 넣는 위치에 맞게 유지)
- 동일한 데이터를 가지고 있어도 상관없다. → 데이터 중복 허용
- 구현방법에 따라 두가지로 나뉜다.
  - 순차 리스트 : 배열을 기반으로 구현된 리스트
    - 단순배열을 이용한 순차리스트를 구현해 사용하는 경우 자료의 삽입,삭제 연산과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요하다
    - 원소의 개수가 많고 삽입/삭제 연산이 빈번하게 일어날수록 시간이 크게 증가
  - 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트
    - 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 각 원소를 연결하여 하나의 전체적인 자료구조를 이룸
  - 연결리스트 기분 구조
    - 노드 : 연결리스트에서 하나의 원소
    - 구성요소
      - 데이터 필드 : 원소의 값을 저장
      - 링크필드 : 다음 노드의 참조값을 저장
    - 헤드 : 연결리스트의 첫 노드에 대한 참조값을 갖고 있음 (dummy node 또는 첫 노드)
    ```java
    class Node<T> {
    	T data;
    	Node<T> link;
    }
    ```

### 2. 단순 연결 리스트

```java
// 첫번째 노드로 삽입하는 알고리즘

addtoFirst(L,i) // 리스트 헤드 L, 원소 i
	new = createNode(); // 빈 노드 생성
	new.data = i; // 데이터 필드
	new.link = L; // 링크
	L = new;
```

### 단순 연결 리스트 구현

- 컬렉션 API를 쓰면 직접 구현하지 않아도 된다는 장점이 있지만, 필요에 따라 직접 구현하는 경우 컬렉션 API에 비해 향상된 성능을 기대할 수 있다.
- 그래프 문제 해결을 위해 연결 리스트를 구현하여 인접 리스트로 활용할 수 있다.- 링크가 한 개
- 중간부터 reference 된 경우 모든 노드를 탐색할 수 없음 - 이전 노드를 찾으려면 처음부터 `현재 노드를 가리키는 노드`를 발견할 때 까지 탐색해야 함 - `링크 필드가 Null인 경우 마지막 노드`

### 삽입 연산

위치에 따라 알고리즘이 달라질 수 있다. → 첫 번째 노드로 삽입 (공백 리스트든, 아니든 똑같음)

1.  새로 노드 만들기

2.  데이터 필드 작성

3.  리스트의 처음으로 지정하도록 링크

4.  head가 가지고 있는 링크를 새로 생성한 노드의 링크 필드에 복사

5.  head의 링크 필드에 새로 생성한 노드를 할당

### 삭제 연산

첫 번째 노드 삭제

1. 삭제할 노드의 링크 필드를 head에 복사
2. 삭제할 노드의 링크 필드에 null 저장 -> 삽입이든 삭제든 논리적 순서를 유지하기만 하면 됨.

### 3. 이중 연결 리스트

### 4. 트리

- 비선형 구조
- 원소들 간에 1:n 관계를 가지는 자료구조
- 원소들 간에 계층관계를 가지는 계층형 자료구조
- 상위원소에서 하위원소로 내려가면서 확장되는 트리 모양의 구조
- 노드 : 트리의 원소
  - 노드 중 최상위 노드를 루트(root)라 한다
  - 나머지 노드들은 n≥0개의 분리 집합으로 분리 될 수 있다.
- 간선 : 노드와 노드를 연결하는 선
- 트리는 사이클이 없는 그래프
- 형제노드 : 같은 부모 노드의 자식 노드들
- 조상 노드 : 간선을 따라 노드까지 이르는 경로에 있는 모든 노드들
- 서브트리 : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들
- `차수(degree)`
  - 노드의 차수 : 노드에 연결된 자식 노드의 수(자식노드로의 간선의 수)
  - 트리의 차수 : 트리에 있는 차수 중에서 가장 큰 값
  - 단말 노드 : 차수가 0인 노드
- `높이`
  - 노드의 높이 : 루트에서 노드에 이르는 간선의 수. (= 노드의 레벨)
  - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값

### 5. 이진 트리

- 차수가 2인 트리
- 각 노드가 자식 노드를 최대 2개 까지만 가질 수 있는 트리
  - 왼쪽 자식 노드
  - 오른쪽 자식 노드
- 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리
- `특성`
  - 높이 i 에서의 노드의 최대 개수는 2^i개
  - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는(h+1)개가 되며 최대 개수는 (2^h+1 - 1)개

### 포화 이진 트리 (Perfect Binary Tree)

- 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
- 높이 h일때 최대의 노드 개수인 2^h+1 - 1의 노드를 가진 이진 트리
- 루트를 1번으로 하여 2^h+1 -1 까지 정해진 위치에 대한 노드 번호를 가짐

### 완전 이진 트리(Complete Binary Tree)

- 높이가 h이고 노드 수가 n일 때(단 h+1 ≤ n < 2^h+1 - 1) 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리 → 단말노드 제외하고 꽉 차있는 트리

### 편향 이진 트리 (Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가진 이진 트리

### `노드 번호의 성질`

- 노드번호가 i인 노드의 부모 노드 번호 : i/2
- 노드 번호가 i인 노드의 왼쪽 자식 번호 : 2\*i
- 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 : 2\*i+1
- 레벨 n의 노드 번호 시작번호 : 2^n

### 배열을 이용한 이진 트리

- 노드 번호를 배열의 인덱스로 사용
- 높이고 h인 이진 트리를 위한 배열의 크기는
  - 레벨 i의 최대 노드 수는 : 2^i
  - 따라서 모든 노드의 수는 : 2^h+1 -1
  - 배열의 크기는 2^h+1

### 트리 탐색 - BFS(너비 우선 탐색)

- `너비` : 루트에서 자신까지 오는 사용되는 간선 수
- 루트 노드의 자식 노드들을 먼저 모두 차레로 방문한 후에 방문했던 자식 노드들을 기준으로 하여 다시 해당 노드의 자식노드들을 차레로 방문하는 방식
- 인접한 노드들에 대해 탐색을 한 후 차레로 다시 BFS를 진행해야 하므로 `FIFO` 형태의 큐를 활용

```java
BFS()
	큐 생성
	루트 v를 큐에 삽입
	while (큐가 비어 있지 않은 경우) {
		t = 큐의 첫번째 원소
		t 방문
		for(t와 연결된 모든 간선에 대해) {
				u = t의 자식 노드
				u를 큐에 삽입
		}
	}

```

1. A에서 시작 그의 자식노드들을 queue에 저장 `queue={B,C,D}`
2. A의 자식노드들을 차례대로 방문하면서 그의 자식들을 모두 큐에 넣음 `queue={E,F,G,H,I}`

### 탐색 순서

`queue={A}`

`queue={B,C,D}`

`queue={C,D,E,F}`

`queue={D,E,F}`

`queue={E,F,G,H,I}`

→ `queue를 stack으로 변경하면 DFS`

### 트리 탐색 - DFS(깊이 우선 탐색)

- 루트 노드에서 출발해서 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색 → 가장 마지막에 만났던 갈림길의 노드로 되돌아가서 다시 DFS을 반복해야 하므로 재귀적으로 구현하거나 스택사용해서 구현

```java
DFS(v)
	v 방문;
	for(v의 모든 자식 노드 w) {
		DFS(w);
	}
end DFS()
```

## 6. 힙(heap)

- 완전 이진 트리에 있는 노드 중에서 키값(data)이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해 만든 자료구조

### 최대힙(max heap)

- 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 부모 노드의 키 값 ≥ 자식 노드의 키 값
- 루트 노드 : 키 값이 가장 큰 노드

### 최소힙(min heap)

- 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
- 부모 노드의 키 값 ≤ 자식 노드의 키 값
- 루트 노트 : 키 값이 가장 작은 노드

### 힙이 아닌 이진 트리의 예

- 트리 1 : 완전 이진 트리가 아니기 때문에 힙이 아니다.
- 트리 2 : 완전 이진 트리 O → 최소힙,최대힙도 아님

### 힙 연산 - 삽입(최대힙)

1. 삽입 할 자리 확장 → 완전 이진 트리를 만족하도록 가장 마지막 노드에
2. 값을 저장했을 때 최대힙을 만족하는지 확인

### 힙 연산 - 삭제(최대힙)

1. 루트 노트의 원소 값 삭제
2. 마지막 노드 삭제
3. 자비리 바꾸기
4. 자리 확정

### 우선순위 큐

- 우선 순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나감
  1. 원소 자체를 기준으로 힙 구성
  2. 비교 도우미를 기준으로 힙 구성

### java.util.PriorityQueue

- 최대 Heap : 가장 큰 값을 기준으로 먼저 나옴
- 최소 Heap : 가장 작은 값을 기준으로 먼저 나옴

### 힙정렬

- 힙 자료구조를 이용해서 이진 트리와 유사한 방법으로 수행
  1. 하나의 값을 힙에 삽입한다.
  2. 힙에서 순차적으로 값을 하나씩 제거한다.
- n개의 노드 삽입 연산 + n개의 노드 삭제 연산
- 따라서 전체 정렬은 O(NlogN)

## 7. Brute-force

- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
  - 수행속도는 느리지만 해답을 찾아내지 못할 확률은 없다.
- 상대적으로 빠른 시간에 문제해결을 할 수 있다
- 일반적으로 경우의 수가 상대적으로 작을 때 유용

### Baby-gin 문제

- 0 ~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
- 그리고 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다.
- 6자리의 숫자를 입력받아 baby-gin여부를 판단하는 프로그램

## 입력 예

```java
667767
054060
101123
```

1. `정렬` : 중복값, 값의 연속성 체크 가능 → 예외가 존재한다. (완전검색을 이용하자)
2. 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)

### 여행 계획 문제

1. 출발지, 도착지를 선택하면 모든 도시를 여행시켜줌 (여행자는 어느 여행 코스로 다녀야 최소비용일까) → `순열`
2. 3개의 도시를 선택하면 3개 도시의 숙박비를 지원해줌 (여행자는 숙박비 지원만 고려했을 때 어느 도시를 선택해야 할까) → `조합`
3. 여행경비 70만원이 있다. 여행경비를 넘지 않으면서 최대 만족도를 갖도록 선택 → `부분집합`

### 비트마스킹을 통한 순열 생성 - 정수와 비트연산자 사용

```java
// nPn -> N개의 원소로 만들 수 있는 모든 순열 생성
input[] : 숫자 배열
numbers[] : 순열 저장 배열

perm(cnt, flag): // cnt: 현재까지 뽑은 순열 원소의 개수, flag : 선택된 원소에 대한 비트정보 표현
	if cnt == N
		순열 생성끝
	else
		for i from 0 to N-1
			if(flag & 1<<i) != then continue
			numbers[cnt] = input[i]
			perm(cnt+1, flag | 1<<i)
		end for
end perm()

```

`&` : 비트단위로 AND 연산

`<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다.

`|` : 비트 단위로 OR 연산 ( 비트 중 하나라도 1이면 1)

ex) 1<<2 = 100(2) = 4

→ 비트마스킹에 이용하는 <<는 2배로 증가시키기 위함이 아닌 `자리이동` 을 시키기 위해 사용한다.

→ 비트마스킹에 이용하는 &는 조건판단을 위해 주로 사용

→ 비트마스킹에 이용하는 | 는 상태를 누적시키기 위해 사용

### 현 순열에서 사전 순으로 다음 순열 생성 - NextPermutation

- 배열을 오름차순으로 정렬한 후 시작한다.
  1. 뒤쪽부터 탐색하며 교환위치(i-1)찾기 (i : 꼭대기)
  2. 뒤쪽부터 탐색하며 교환위치(i-1)와 교환할 큰 값 위치(j) 찾기
  3. 두 위치 값(i-1, j) 교환
  4. 꼭대기위치(i)부터 맨 뒤까지 오름차순 정렬
  - 주의 사항 : NextPermutation 사용 전에 숫자배열을 오름차순으로 정렬하여 `가장 작은 순열 한번 처리`

### 부분집합 응용(바이너리 카운팅)

- 원소수에 해당하는 N개의 비트열을 이용한다.
- n번째 비트값이 1이면 n번째 원소가 포함되었음을 의미한다.

```java
int[] arr = {3,6,7,1,5,4};
int n = arr.length;

for(int i=0; i<(1<<n); i++) { // 1 << n 부분집합의 개수
	for(int j=0; j<n; j++) { // 원소의 수만큼 비트를 비교
		if(i & (1<<j) != 0) {
				print(arr[j]+" ":)
		}
	}
}
```

## 7. Greedy

Q. 손님이 지불한 금액에서 물건값을 제한 차액을 지불하는 문제 → 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

→ A. 큰 단위 지폐,동전을 준다.

- greedy는 최적해를 구하는데 사용되는 근시안적인 방법
- 최적화문제란 가능한 해들 중에서 가장 좋은 해를 찾는 문제이며 일반적으로 머리 속에 떠오로는 생각을 검증없이 바로 구현하면 `Greedy` 접근이 된다.
- 여러 경우중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는것을 선택해 나가는 방식으로 진행해서 최종적인 해답에 도달한다.
- 하지만 `그것이 최적이라는 보장은 없다`
- Greedy는 최적해로 갈 수 있음을 증명해야 한다.
- `optimal substructure property` : 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
- 원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해

```markdown
물건값 : 1200원
받은돈 : 2000원
거스롬돈 : 800원

(500,400,100,50,10)
-> 큰 수부터 간다면 500원 1개 100원 3개 -> 4개
-> 하지만 400원 2개 -> 최소 동전의 개수
```

### 배낭 짐싸기(Knapsack)

- 도둑을 훔칠 물건을 배낭에 담아올 계획이다. 배낭은 담을 수 있는 물건의 총 무게(W)가 정해져 있다.
- 창고에는 여러개(n)의 물건들이 있고 각각의 물건에는 무게와 값이 정해져 있다.
- 배낭이 수용할 수 있는 무게를 초과하지 않으면서 값이 최대가 되는 물건을 담자.

```markdown
S = {item1,item2 ...} 물건들의 집합
wi : itemi의 무게
Pi = itemi의 값
W : 배낭이 수용 가능한 총 무게

0-1 Kanpsack

- 배낭에 물건을 통째로 담아야 하는 문제(배낭에 물건을 담는다, 담지않는다)
- 물건을 쪼갤 수 없는 경우
  Fractional Knapsack
- 물건을 부분적으로 담는 것이 허용되는 문제
- 물건을 쪼갤 수 있는 경우
```

- 0-1 Knapsack 대한 완전 검색
  - 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다.
  - 부분집합의 총 무게가 W를 초과하는 집합들은 버리고 나머지 집합에서 총 값이 가장 큰 집합을 선택한다. `Big O(2ⁿ)`
- 0-1 Knapsack 대한 Greedy
  - 값이 비싼 물건부터 채운다 → 최적 X
  - 무게가 가벼운 물건부터 채운다. → 최적 X
  - 무게당 값이 높은 순서로 물건을 채운다 → 최적 X
- Fractional Knapsack
  - 물건의 일부를 잘라서 담을 수 있다.
  - 무게당 값이 높은 순서로 물건을 채운다 → 최적 O

### 회의실 배정

- 회의는 시작시간과 종료시간이 있고 회의시간이 겹치는 회의들은 동시에 열릴 수없다.
- 가능한 많은 회의가 열리기 위해서는 회의들을 어떻게 배정할까?

```markdown
10
1 4
1 6
6 10
5 7
3 8
5 9
3 5
8 11
2 13
12 14
```

- `(종료 시간 순,시작시간 순)으로 활동들을 정렬한다`

```markdown
A : 활동들의 집합
S : 선택된 회의들 집합
si : i회의의 시작시간
fi : i회의의 종료시간

Sort A
S = {A1} // 첫 회의
j = 1 // 선택된 활동 집합중 마지막 활동(마지막 회의)
for i in 2 -> n // 2번째회의 ~ 마지막회의
if fj <= si
S = S U {Ai}
j = i
```

### 대표적인 탐욕 기법의 알고리즘

`Prim, Kruskal, Dijkstra`

### 문제

{500,100,50,10,5,1} 동전이 있다. 자판기에서 최대한 많은 동전을 사용하는 경우를 구해보자

```markdown
입력

- 첫줄에는 자판기에서 구입하려는 음료수의 값 W가 주어진다.
- 둘째줄에는 나동전씨가 가지고 있는 500,100,50,10,5,1원짜리 동전들의 개수를
  순서대로 나타낸다.
- 각각의 동전 개수는 1이상 50이하이다. 정수들 사이에는 빈칸이 하나있다.
- 어떠한 동전들의 조합으로도 정확한 음료수의 값이 될 수 없는 경우는 입력으로
  주어지지 않는다.

출력

- 첫줄에는 음료수의 값 W를 지불하기 위해 사용되어질 최대 동전의 수를 출력한다.
- 사용되지않는 동전단위의 경우는 0을 출력한다.

입력 예
13
4 5 2 6 3 4

출력 예
5
0 0 0 0 2 3
```

가장작은 동전단위 사용 → 그다음 작은 단위 동전 사용 → 최적의 해 X

- 보유한 동전으로 가능한 금액 계산
- 나머지 금액을 동전 최소로

## 8. 분할정복

### 문제

n개의 동전들 중에 가짜 동전이 하나 포함되어 잇다. 가짜 동전은 진짜 동전에 비해 아주 조금 가볍다. 진짜 동전들의 무게가 동일하다고 할때 양팔 저울을 이용해서 가짜 동전을 찾자

- 양팔 저울을 최소로 사용해서 가짜 동전을 찾는 방법은 무엇인가?
  - 절반씩 나누어서 계산함
  - 짝수일 때는 N/2, 홀수일 때는 임의의 한개 빼서 무게 잼

### 전략

`분할(Divide)` : 해결할 문제를 여러개의 작은 부분으로 나눈다.

`정복(Conquer)` : 나눈 작은 문제를 각각 해결한다.

`통합(Combine)` : 해결된 해답을 모은다.

### 문제

- 술래가 병뚜껑 속 숫자를 확인한 후, 다음 사람부터 숫자를 맞히기 시작한다. 술래는 Up 또는 Down을 통해 게임에 참여한 사람들이 병뚜껑 속 숫자에 점점 가까워질 수 있도록 힌트를 제시한다.

### 이진검색(Binary Search)

→ 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

`이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.`

- 순차탐색시 `O(N)`
- 이진탐색시 `O(logN)`

```java
binarySearch(S[], n, key)
	start = 0
	end = n-1

	while start<=end
		mid = (start+end)/2
		if(S[mid] == key
				return mid
		else if(S[mid] < key)
				start = mid + 1
		else if(S[mid] > key)
				end = mid - 1
	return -1
```

```java
binarySearch(S[], start, end, key)
	if start > end
		reutnr -1
	else
		mid = (start+end)/2
		if(s[mid]==key)
				return key
		else if(S[mid] < key)
				return binarysearch(S[], mid+1, end, key)
		else
				return binarysearch(S[], start, mid-1, key)
```

`java.util.Arrays.binarySearch` : 이진탐색 API, 못찾았을경우 음수의값 반환 존재한다면 있어야 하는 자리의 인덱스

## 9. 백트래킹

### N-Queen 문제

n\*n 장기판에서 배치한 Queen들이 서로 위협하지 않도록 n개의 Queen을 배치하는 문제

- 퀸 8개를 크기 8의 체스판 안에 서로를 공격할 수 없도록 배치하는 모든 경우를 구하는 문제
- `64C8` : 4426165368 중에서 실제 해의 수는 92개

### 백트래킹

- 모든 조합을 시도해서 문제의 해를 찾는다.
- 해를 얻을 때까지 모든 가능성을 시도한다.
- 모든 가능성은 하나의 트리 `(상태공간트리)` 처럼 구성할 수 있으며, 가지 중에 해결책이 있다.
- 여러가지들이 존재하는 상황에서 하나의 가지를 선택한다.
- 선택이 이루어지면 새로운 선택지들의 집합이 생성된다.
- 반복하면서 최종상태에 도달 → 보통 재귀함수로 구현

→ 노드수 만큼 호출, 재귀의 깊이는 대부분 N, 지수형태의 시간복잡도를 갖는다.

- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 간다.
- `유망(promising)` : 어떤 노드를 방문했을 때 그 노드를 포함한 경로가 해답이 될 수 있다.
- `가지치기(pruning)` : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가능할 수 있다.

### 부분집합의 합 문제 1

- 유한 개의 정수로 이루어진 집합이 있을 때 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 몇번이나 있는지를 알아내는 문제
- 완전검색 기법으로 풀기위해서는 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산

### 부분집합의 합 문제 2

- 유한 개의 자연수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한값이 21이 되는 경우가 몇번이나 있는지를 알아내는 문제
- 백트래킹으로 풀 수 있다.

## 10. 그래프

### 친구 관계

- A의 친구는 E,G,J이고 E의 친구는 A,D,H이다.
- A의 친구 중에 친구가 가장 많은 친구는 누구이고 몇명(A포함)인가?
- (D-E), (F-G), (N-B,I,L), (G-A,C,D,H), (I-J,H), (B-D,I,K,L), (M-I,J), (E-A,H), (C-B,I,L), (J-A,G)

- 그래프는 아이템들과 이들 사이의 연결 관계를 표현한다.
- `정점(Vertex)` : 그래프의 구성요소로 하나의 연결점
- `간선(Edge)` : 두 정점을 연결하는 선
- `차수(Degree)` : 정점에 연결된 간선의 수
- 그래프는 정점들의 집합과 이들을 연결하는 간선들의 집합으로 구성된 자료구조
  - V : 정점의 개수 E: 그래프에 포함된 간선의 개수
  - V개의 정점을 가지는 그래프는 최대 V\*(V-1)/2 간선이 가능 `무향그래프`
  - 5개 정점이 있는 그래프의 최대 간선수는 10개이다.
- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기에 용이하다.

### 그래프 유형

- 무향 그래프 (양방향)
- 유향 그래프 (단방향)
- 가중치 그래프
- 사이클 없는 방향 그래프
- 완전 그래프 : 정점들에 대해 가능한 모든 간선들을 가진 그래프
- 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
- 트리도 그래프이다.
  - 각 노드는 최대 하나의 부모 노드가 존재할 수 있다.
  - 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다.
  - 두 노드 사이에는 유일한 경로가 존재한다.
- 인접(Adjancency)
  - 두 개의 정점에 간선이 존재하면 서로 인접해 있다고 한다.
  - 완전 그래프에 속한 임의의 두 정점들은 서로 인접해 있다.
- 경로(Path)란 어떤 정점 A에서 시작하여 다른정점 B로 끝나는 순회로 두 정점 사이를 잇는 간선들을 순서대로 나열한것
- `싸이클 (Cycle)` : 경로의 시작 정점과 끝 정점이 같음

### 그래프 표현

- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬
  - V \* V 크기의 2차원 배열을 이용해서 간선 정보를 저장
  - 인접행렬로 희소그래프를 표현하면 `공간의 낭비` `탐색 비효율성`
- 인접 리스트
  - 각 정점마다 다른 정점으로 나가는 간선의 정보를 저장
- 간선 리스트
  - 간선의 정보를 객체로 표현하여 리스트에 저장

### 인접행렬

- 두 정점을 연결하는 간선의 유무를 행렬로 표현
  - V \* V 정방 행렬
    - 가중치 有 그래프 : boolean[]
    - 가중치 無 그래프 : 인접여부 + 가중치
  - 행 번호와 열 번호는 그래프의 정점에 대응
  - 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
  - 무향 그래프
    - i번째 행의 합 = i번째 열의 합 = Vi의 차수 (대칭으로 값 채운다)
  - 유향 그래프
    - 행 i의 합 = Vi의 진출 차수
    - 열 i의 합 = Vi의 진입 차수

## 11. 그래프 2

### 서로소 집합(Disjoint-set)

- 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들이다. 다시 말해 교집힙이 없다.
- 집합에 속한 하나의 특정 멤버를 통해 각 집합들은 구분한다. 이를 `대표자(representative)` 라 한다.
- 서로소 집합을 표현하는 방법
  - 연결 리스트
  - 트리
- 서로소 집합 연산
  - Make-set(x) : 집합 생성 (x를 원소로 갖는)
  - Find-set(x) : x가 속한 집합 찾기
  - Union(x,y) : x,y 원소를 하나의 집합으로 만들기
- 서로소 집합 예시

```markdown
Make-set(x)
Make-set(y)
Make-set(a)
Make-set(b)
--> 원소 크기가 1인 배열로 모두 만든다. (서로소)

Union(x,y)
Union(a,b)
--> (x,y) x를 대표자로, (a,b) a를 대표자로

Find-set(y)
--> y가 속해있는 집합을 찾음 return x
Find-set(b)
--> b가 속해있는 집합을 찾음 return a

Union(x,a)
--> (a,b,x,y) x를 대표자로
```

- 서로소 집합 표현 - 연결리스트
  - 같은 집합의 원소들은 하나의 연결리스트로 관리한다.
  - 연결리스트의 맨 앞의 원소를 집합의 대표 원소로 삼는다.
  - 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다.
- 서로소 집합 표현 - 트리
  - 같은 집합의 원소들을 하나의 트리로 표현한다.
  - 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다.
- 서로소 집합에 대한 연산
  - Rank를 이용한 Union
    - 각 노드는 자신을 루트로 하는 subtree의 높이를 rank로 저장한다.
    - 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙힌다.
  - Path compression
    - Find-set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어준다.

### 최소 신장 트리(MST)

- 그래프에서 최소 비용 문제
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리
  - 무향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장트리
  - N개의 정점을 가진 그래프에서 N개의 정점을 모두 연결하기 위해 N-1개 간선을 선택하여 만든 트리

### KRUSKAL 알고리즘 (그리디)

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  - 최초 모든 간선을 가중치에 따라 오름차순으로 정렬
  - 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴 (사이클이 존재하면 다음으로 가중치가 낮은 간선 선택)
  - n-1개의 간선이 선택될때까지 (2)를 반복
  - `Big O(eloge)`

```markdown
G.V : 그래프의 정점 집합
G.E : 그래프의 간선 집합

MST-KRUSKAL(G, w)
FOR vertex v in G.V
Make-Set(v)
G.E에 포함된 간선들을 가중치 w를 이용한 오름차순 정렬
FOR 가중치가 낮은 간선 (u,v) G.E 선택(n-1)개
IF Find-set(u) != Find-set(v)
Union(u,v)
```

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class KruskalTest {

	static class Edge implements Comparable<Edge>{
		int from,to,weight;

		Edge(int from, int to, int weight) {
			this.from = from;
			this.to = to;
			this.weight = weight;
		}

		@Override
		public int compareTo(Edge o) {
			return this.weight - o.weight;
		}
	}

	static int[] parents;
	static int V,E;
	static Edge[] edgeList;

	// 크기가 1인 서로소 집합 생성
	static void make() {
		parents = new int[V];
		for(int i=0; i<V; i++) { // 모든 노드가 자신을 부모로 하는(대표자) 집합으로 만듦
			parents[i] = i;
		}
	}

	// a의 대표자 찾기
	static int find(int a) {
		if(parents[a] == a) return a;
		return parents[a] = find(parents[a]); // 우리의 대표자를 나의 부모로 : path compression
	}

	// return값 : true ==> union 성공
	static boolean union(int a, int b) {
		int aRoot = find(a);
		int bRoot = find(b);
		if(aRoot==bRoot) return false;
		parents[bRoot] = aRoot;
		return true;
	}

	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		V = Integer.parseInt(st.nextToken());
		E = Integer.parseInt(st.nextToken());

		edgeList = new Edge[E];

		for(int i=0; i<E; i++) {
			st = new StringTokenizer(br.readLine());
			edgeList[i] = new Edge(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));

		}
		make();
		Arrays.sort(edgeList); // 가중치 오름차순으로 정렬

		int result = 0;
		int count = 0;
		for(Edge edge: edgeList) {
			if(union(edge.from, edge.to)) {
				result += edge.weight;
				if(++count == V-1) break;
			}
		}
		System.out.println(result);

	}
}
```

### PRIM 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
  1. 임의의 정점 하나 선택해서 시작
  2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
  3. 모든 정점이 선택될 때 까지 1,2번 반복
  4. 인접행렬 `Big O(2V^2)` , 인접리스트 :`Big O(V^2 + E)`
  5. 인접리스트에 우선순위 큐를 사용한다면 `Big O(V+E)logV`
  6. 상황에 따라 PQ를 사용해도 더 느려지는 경우도 있다.

E : V^2에 가까움 (완전그래프) → 인접리스트에 이점이 없다.

E < V^2일때는 인접리스트

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class PrimAdjList {

	static class Node {
		int vertex,weight; // 나와 연결된 정점번호, 가중치
		Node next; // 연결리스트를 구하기 위한

		Node(int vertex, int weight, Node next) {
			this.vertex = vertex;
			this.weight = weight;
			this.next = next;
		}
	}

	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int V = Integer.parseInt(st.nextToken());
		int E = Integer.parseInt(st.nextToken());

		Node[] adjList = new Node[V]; // 각 정점별 인접리스트

		for(int i=0; i<E; i++ ) {
			st =  new StringTokenizer(br.readLine());
			int from = Integer.parseInt(st.nextToken());
			int to = Integer.parseInt(st.nextToken());
			int weight = Integer.parseInt(st.nextToken());

			// 무향 처리
			adjList[from] = new Node(to,weight, adjList[from]);
			adjList[to] = new Node(from,weight, adjList[to]);
		}

		// 프림 알고리즘에 필요한 자료 구조
		int[] minEdge = new int[V]; // 각 정점입장에서 신장트리에 포함된 정점과의 간선 비용중 최소
		boolean[] visited = new boolean[V]; // 신장트리 포함여부

		Arrays.fill(minEdge, Integer.MAX_VALUE); // 최소값 관리하기 위해 큰 값 세팅

		// 1. 임의의 시작점 처리, 0번 정점을 시작점
		minEdge[0] = 0;
		int result = 0; //최소 신장트리 비용 누적

		// V개의 정점 처리하면 끝
		for(int c=0; c<V; c++) {

			// step 1. 신장트리의 구성에 포함되지 않은 정점 중 최소비용 정점 선택
			int min = Integer.MAX_VALUE;
			int minVertex = -1;
			for(int i=0; i<V; i++) {
				if(!visited[i] && min > minEdge[i]) {
					min = minEdge[i];
					minVertex = i;
				}
			}

			// step 2. 신장트리에 추가
			visited[minVertex] = true;
			result += min;

			// step 3. 신장트리에 새롭게 추가되는 정점과 신장트리에 포함되지 않은 정점들의 기존 최소비용과 비교해서 갱신
			// 신장트리에 새롭게 추가되는 정점의 모든 인접정점 들여다 보며 처리
			for(Node temp= adjList[minVertex]; temp != null; temp = temp.next) {
				if(!visited[temp.vertex] && minEdge[temp.vertex] > temp.weight) {
					minEdge[temp.vertex] = temp.weight;
				}
			}
		}
		System.out.println(result);

	}
}
```

```java
package a0825.add;

import java.util.*;
import java.io.*;
public class PrimPQ {

	public static void main(String[] args)throws Exception{

		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[][] graph = new int[N][N];
		boolean[] visited = new boolean[N];
		int[] minEdge = new int[N];

		for(int i=0; i<N; i++) {
			for(int j=0; j<N; j++) {
				graph[i][j] = sc.nextInt();
			}
			minEdge[i] = Integer.MAX_VALUE;
		}



		int result = 0;
		int cnt = 0;
		PriorityQueue<int[]> queue = new PriorityQueue<>((o1,o2) -> Integer.compare(o1[1], o2[1]));
		queue.offer(new int[] {0,0}); // 정점, 가중치
		minEdge[0] = 0;
		while(!queue.isEmpty()) {
			int[] cur = queue.poll();
			int min = cur[1];
			int minV = cur[0];

			if(visited[minV]) continue;
			visited[minV] = true;
			result += min;
			if(cnt++ == N-1) break;

			for(int j=0; j<N; j++) {
				if(!visited[j] && graph[minV][j] != 0 && minEdge[j] > graph[minV][j]) {
					minEdge[j] = graph[minV][j];
					queue.offer(new int[] {j,minEdge[j] });
				}
			}
		}

		System.out.println(result);
		sc.close();
	}

}
```

## 12. 최단경로

### 최단 경로 정의

- 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점까지의 최단 경로

→ 가중치가 없을때는 BFS, 가중치가 있을때는 최소비용 갱신

### 다익스트라 알고리즘

- 음의 가중치를 허용허지 않음

### 벨만-포드 알고리즘

- 음의 가중치 허용

### 플로이드-워샬 알고리즘

- 모든 정점들에 대한 최단 경로

### 다익스트라 알고리즘 (그리디)

- 시작정점에서 다른 모든 정점으로의 최단 경로를 구하는 알고리즘
- 시작 정점에서의 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
- 그리디 알고리즘으로 MST의 프림 알고리즘과 유사하다.

```markdown
s: 시작정점, A: 인접행렬, D: 시작정점에서의 거리
V : 정점 집합, U : 선택된 정점 집합

Dijkstra(s,A,D)
U = {s};
// D[i] : s(출발)정점에서 i까지 오는데 소요되는 최소 비용

    FOR 모든 정점 v
    	D[v] = A[s][v] // 간선이 없다면 INF로 표시되어야 가능

    While U != V

    	// 처리되지 않은 정점중 출발지 ~ 자신 비용 최소인 정점 찾기
    	D[w]가 최소인 정점 w ∈ V-U를 선택

    	U = U ∪ {w}
    	FOR w에 인접한 모든 미방문 정점 v
    		D[v] = min(D[v], D[w] + A[w][v])
```

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Dijkstra {
	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int V = Integer.parseInt(br.readLine());

		int[][] adjMatrix = new int[V][V];

		for(int i=0; i<V; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			for(int j=0; j<V; j++) {
				adjMatrix[i][j] = Integer.parseInt(st.nextToken());
			}
		}

		// start -> end로의 최단 경로
		int start = 0; // 출발정점
		int end = V-1; // 도착정점

		// 다익스트라 알고리즘에 필요한 자료구조
		int[] D = new int[V]; // 출발지에서 자신으로 오는데 소요되는 최소비용
		boolean[] visited = new boolean[V]; // 처리한 정점 여부

		// 모든 거리 비용 무한대로 초기화
		Arrays.fill(D, Integer.MAX_VALUE);

		// 출발정점 처리
		D[start] = 0;

		int min,minVertex;

		for(int i=0; i<V; i++) {
			// step 1. 미방문 정점 중 출발지에서 자신으로의 비용이 최소인 정점 선택 (방문해야 하는 나머지 정점 중 출발지에서 가장 가까운 정점 찾기)
			min = Integer.MAX_VALUE;
			minVertex = -1;

			for(int j=0; j<V; j++) {
				if(!visited[j] && min > D[j]) {
					min = D[j];
					minVertex = j;
				}
			}

			// step 2. 방문 처리
			visited[minVertex] = true;
//			if(minVertex == end) break; // 문제가 start - end로의 최단이면 탈출
			// step 3. 선택된 정점을 경유지로 해서 미방문 정점들로 가는 비용을 따져보고 기존 최적해보다 유리하면 갱신
			for(int j=0; j<V; j++) {
				if(!visited[j] && adjMatrix[minVertex][j] > 0 && D[j] > D[minVertex] + adjMatrix[minVertex][j]) {
					D[j] = D[minVertex] + adjMatrix[minVertex][j];
				}
			}

		}
		System.out.println(D[end]);
	}
}
```

```java
package a0825.add;

import java.util.*;
import java.io.*;
public class DijkstraPQ {

	public static void main(String[] args)throws Exception{

		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[][] graph = new int[N][N];
		boolean[] visited = new boolean[N];
		int[] dist = new int[N];

		for(int i=0; i<N; i++) {
			for(int j=0; j<N; j++) {
				graph[i][j] = sc.nextInt();
			}
			dist[i] = Integer.MAX_VALUE;
		}


		PriorityQueue<int[]> queue = new PriorityQueue<>((o1,o2) -> Integer.compare(o1[1], o2[1]));
		dist[0] = 0;
		queue.offer(new int[] {0,0});
		while(!queue.isEmpty()) {
			int[] cur = queue.poll();
			int min = cur[1];
			int minV = cur[0];
			if(visited[minV]) continue;

			visited[minV] = true;

			if(minV == N-1) break;

			for(int j=0; j<N; j++) {
				if(!visited[j] && graph[minV][j] != 0 && dist[j] > min + graph[minV][j]) {
					dist[j] = min + graph[minV][j];
					queue.offer(new int[] {j,dist[j]});
				}
			}
		}
		System.out.println(Arrays.toString(dist));
		sc.close();
	}

}
```

### 위상 정렬(Topology Sort)

- 유향 그래프에서만 가능
- 유향 그래프의 정점들을 변의 방향을 거스리지 않도록 나열하는 것
- 위상정렬은 순서가 정해져 있는 작업들을 차례대로 수행해야 할 때, 그 순서를 결정해 주는 알고리즘이다.
- 위상 정렬을 가장 잘 설명해 줄 수 있는 예로 교육과정의 선수과목 구조를 예로 들 수 있다.
- 만약 특정 수강 과목에 선수과목이 있다면 그 선수과목부터 수강해야 하므로 특정 과목들을 수강해야 할때 위상 정렬을 통해 올바른 수강 순서를 찾아낼 수 있다.
- 반드시 그래프의 순환이 존재하지 않아야 한다.

### 위상정렬 - BFS 사용

1. 진입 차수가 0인 노드를 큐에 모도 넣는다.
2. 큐에서 진입 차수가 0인 노드를 꺼내어 자신과 인접한 노드의 간선을 제거한다.
   1. 인접한 노드의 진입 차수를 1 감소시킨다.
3. 간선 제거 후 진입 차수가 0이 된 노드를 큐에 넣는다.

진입차수 > 0 ⇒ 선행 작업 有, 진입 차수 = 0 ⇒ 선행 작업 無

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;
import java.util.StringTokenizer;

public class TopologySort {
	static class Node {
		int vertex;
		Node next;
		Node(int vertex, Node next) {
			this.vertex = vertex;

			this.next = next;
		}
	}

	static int V,E;
	static Node[] adjList;
	static int[] inDegree;
	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		V = Integer.parseInt(st.nextToken());
		E = Integer.parseInt(st.nextToken());

		adjList = new Node[V+1]; // 각 정점별 인접리스트
		inDegree = new int[V+1]; // 각 정점별 진입차수

		for(int i=0; i<E; i++ ) {
			st =  new StringTokenizer(br.readLine());
			int from = Integer.parseInt(st.nextToken());
			int to = Integer.parseInt(st.nextToken());


			// 유향 그래프
			adjList[from] = new Node(to, adjList[from]);
			inDegree[to]++;
		}
		ArrayList<Integer> list = topologySort();

		if(list.size()==V) { // 위상정렬 완성
			System.out.println(list);
		} else {
			System.out.println("cycle");
		}
	}

	private static ArrayList<Integer> topologySort() {
		ArrayList<Integer> list = new ArrayList<>();
		Queue<Integer> queue = new ArrayDeque<>();

		// 진입차수가 0인 정점 큐에 넣기
		for(int i=1; i<=V; i++) {
			if(inDegree[i]==0 ) queue.offer(i);
		}

		// BFS
		while(!queue.isEmpty()) {
			int cur = queue.poll();
			list.add(cur);

			for(Node temp= adjList[cur]; temp != null; temp = temp.next) {
				if(--inDegree[temp.vertex]==0) queue.offer(temp.vertex);
			}
		}
		return list;
	}
}
```
